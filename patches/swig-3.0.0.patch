diff -rupN swig-3.0.0.orig/Examples/Makefile.in swig-3.0.0/Examples/Makefile.in
--- swig-3.0.0.orig/Examples/Makefile.in	2014-03-17 01:49:54.000000000 +0400
+++ swig-3.0.0/Examples/Makefile.in	2014-10-11 22:09:36.000000000 +0400
@@ -1743,3 +1743,42 @@ d_clean:
 	rm -f *_wrap* *~ .~* $(RUNME) $(RUNME).exe `find . -name \*.d | grep -v $(RUNME).d`
 	rm -f core @EXTRA_CLEAN@
 	rm -f *.@OBJEXT@ *@SO@
+
+##################################################################
+#####                       AS3                             ######
+##################################################################
+
+# Set this to the path to your flascc sdk root
+ALCSDK=$(prefix)/../
+ifneq (,$(USE_ASC))
+	LEGACY_ASC=-use-legacy-asc
+else
+	LEGACY_ASC=
+endif
+
+# ----------------------------------------------------------------
+# Build an avmshell projector (C)
+# ----------------------------------------------------------------
+
+as3: $(SRCS) ../main.c
+	$(SWIG) -as3 $(SWIGOPT) $(INTERFACEPATH)
+	$(ALCSDK)/usr/bin/gcc -c $(CFLAGS) $(LEGACY_ASC) $(SRCS) ../main.c $(ISRCS) $(INCLUDES)
+	$(ALCSDK)/usr/bin/gcc -enable-debugger $(LEGACY_ASC) -o $(TARGET) *.o $(AS_SRCS)
+
+# ----------------------------------------------------------------
+# Build an avmshell projector (C++)
+# ----------------------------------------------------------------
+
+as3_cpp: $(CXXSRCS) ../main.c
+	$(SWIG) -as3 -c++ $(SWIGOPT) $(INTERFACEPATH)
+	$(ALCSDK)/usr/bin/g++ -c $(CFLAGS) $(LEGACY_ASC) $(CXXSRCS) ../main.c \
+		$(ICXXSRCS) $(INCLUDES)
+	$(ALCSDK)/usr/bin/g++ -enable-debugger $(LEGACY_ASC) -o $(TARGET) *.o $(AS_SRCS)
+
+# -----------------------------------------------------------------
+# Cleaning the AS3 examples
+# -----------------------------------------------------------------
+
+as3_clean:
+	rm -f *_wrap* *.abc *.o `find . -name \*.as | grep -v runme.as`
+
diff -rupN swig-3.0.0.orig/Examples/as3/addressof/Makefile swig-3.0.0/Examples/as3/addressof/Makefile
--- swig-3.0.0.orig/Examples/as3/addressof/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/addressof/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/addressof/example.c swig-3.0.0/Examples/as3/addressof/example.c
--- swig-3.0.0.orig/Examples/as3/addressof/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/addressof/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,6 @@
+#include <stdio.h>
+#include "example.h"
+
+void printPointer(struct Bar *number){
+    printf("printPointer: %d\n", number->num);
+}
\ No newline at end of file
diff -rupN swig-3.0.0.orig/Examples/as3/addressof/example.h swig-3.0.0/Examples/as3/addressof/example.h
--- swig-3.0.0.orig/Examples/as3/addressof/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/addressof/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,5 @@
+struct Bar {
+	int num;
+};
+
+void printPointer(struct Bar *number);
diff -rupN swig-3.0.0.orig/Examples/as3/addressof/example.i swig-3.0.0/Examples/as3/addressof/example.i
--- swig-3.0.0.orig/Examples/as3/addressof/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/addressof/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,14 @@
+/* File : example.i */
+#ifdef SWIG
+%module ExampleModule
+
+%{
+    #include "example.h"
+%}
+
+%include "example.h"
+#else
+#include "example.h"
+#endif
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/addressof/runme.as swig-3.0.0/Examples/as3/addressof/runme.as
--- swig-3.0.0.orig/Examples/as3/addressof/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/addressof/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,22 @@
+package SWIGExample {
+    import avmplus.System;
+    import com.adobe.flascc.CModule;
+
+    public function ASMain() {
+        
+        var addr:int = CModule.malloc(BarValue.size);
+        var bar = new BarValue(CModule.ram, addr);
+        
+        ExampleModule.printPointer(bar.addressOf());
+        ExampleModule.printPointer(addr);
+
+        bar.num = 5;
+        
+        ExampleModule.printPointer(bar.addressOf());
+        ExampleModule.printPointer(addr);
+
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/argout/Makefile swig-3.0.0/Examples/as3/argout/Makefile
--- swig-3.0.0.orig/Examples/as3/argout/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/argout/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/argout/example.c swig-3.0.0/Examples/as3/argout/example.c
--- swig-3.0.0.orig/Examples/as3/argout/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/argout/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,8 @@
+/* File : example.c */
+
+/* Returns values in the x and y pointers */
+void getpoint(int *x, int *y) {
+    *x = 1;
+    *y = 2;
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/argout/example.i swig-3.0.0/Examples/as3/argout/example.i
--- swig-3.0.0.orig/Examples/as3/argout/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/argout/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,23 @@
+/* File : example.i */
+%module ExampleModule
+
+%typemap(in, numinputs=0) (int *x, int *y) (int tempx, int tempy) {
+    $1 = &tempx;
+    $2 = &tempy;
+}
+
+%typemap(astype) (void getpoint) "Object";
+%typemap(asreturn) (void getpoint) {
+    AS3_ReturnAS3Var($input);
+}
+
+%typemap(argout) (int *x, int *y) {
+    inline_as3("var $result = {'x': CModule.read32(%0), "
+               "'y': CModule.read32(%1)};"
+                : : "r"($1), "r"($2));
+}
+
+%inline %{
+extern void getpoint(int *x, int *y);
+%}
+
diff -rupN swig-3.0.0.orig/Examples/as3/argout/runme.as swig-3.0.0/Examples/as3/argout/runme.as
--- swig-3.0.0.orig/Examples/as3/argout/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/argout/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,10 @@
+package SWIGExample {
+    import avmplus.System;
+    public function ASMain() {
+        var pt = ExampleModule.getpoint();
+        Trace('The point is (' + pt.x + ', ' + pt.y + ')');
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/array/Makefile swig-3.0.0/Examples/as3/array/Makefile
--- swig-3.0.0.orig/Examples/as3/array/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/array/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/array/example.c swig-3.0.0/Examples/as3/array/example.c
--- swig-3.0.0.orig/Examples/as3/array/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/array/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,25 @@
+/* File : example.c */
+
+#include <stdio.h>
+#include "example.i"
+
+/* A global variable */
+int foo[5];
+
+void print_doubles(struct doubles *d) {
+    int i;
+    d->array_member[5] = 1.23;
+    for (i = 0; i < 10; i++) {
+        printf("%.2f ", d->array_member[i]);
+    }
+    printf("\n");
+}
+
+void print_chars(struct chars *c) {
+    int i;
+    for (i = 0; i < 10; i++) {
+        printf("%c ", c->char_member[i]);
+    }
+    printf("\n");
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/array/example.i swig-3.0.0/Examples/as3/array/example.i
--- swig-3.0.0.orig/Examples/as3/array/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/array/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,33 @@
+/* File : example.i */
+#ifdef SWIG
+%module ExampleModule
+
+%{
+#include <stdio.h>
+%}
+
+%inline %{
+extern int foo[5];
+%}
+
+%immutable stdout;
+#endif
+
+struct doubles {
+    char a;
+    double array_member[10];
+};
+
+struct chars {
+    double d;
+    char char_member[10];
+};
+
+struct simple {
+    int a;
+    double d;
+};
+
+void print_doubles(struct doubles *);
+void print_chars(struct chars *);
+
diff -rupN swig-3.0.0.orig/Examples/as3/array/runme.as swig-3.0.0/Examples/as3/array/runme.as
--- swig-3.0.0.orig/Examples/as3/array/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/array/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,42 @@
+package SWIGExample {
+    import avmplus.System;
+    import com.adobe.flascc.CModule;
+    import flash.utils.ByteArray;
+
+    public function ASMain() {
+  
+        var d = new DoublesValue();
+        var dptr = CModule.malloc(DoublesValue.size);
+
+        var doubles = new ByteArray();
+        doubles.endian = "littleEndian";
+        for (var i = 0; i < 10; i++) {
+            doubles.writeDouble(1 + i / 2);
+        }
+        doubles.position = 0;
+        d.array_member = doubles;
+        d.write(dptr);
+        
+        ExampleModule.print_doubles(dptr);
+
+        CModule.free(dptr);
+
+        var c = new CharsValue();
+        var cptr = CModule.malloc(CharsValue.size);
+
+        var chars = new ByteArray();
+        for (var i = 0; i < 10; i++) {
+            chars.writeByte(65 + i);
+        }
+        chars.position = 0;
+        c.char_member = chars;
+        c.write(cptr);
+        ExampleModule.print_chars(cptr);
+
+        CModule.free(cptr);
+
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/as3import/Makefile swig-3.0.0/Examples/as3/as3import/Makefile
--- swig-3.0.0.orig/Examples/as3/as3import/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/as3import/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/as3import/example.c swig-3.0.0/Examples/as3/as3import/example.c
--- swig-3.0.0.orig/Examples/as3/as3import/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/as3import/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,10 @@
+#include <stdio.h>
+#include "example.h"
+
+void printNumber(int i){
+    printf("printNumber: 4==%d\n", i);
+}
+
+void printNumber2(int i){
+    printf("printNumber2: 4==%d\n", i);
+}
\ No newline at end of file
diff -rupN swig-3.0.0.orig/Examples/as3/as3import/example.h swig-3.0.0/Examples/as3/as3import/example.h
--- swig-3.0.0.orig/Examples/as3/as3import/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/as3import/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,4 @@
+
+
+void printNumber(int i);
+void printNumber2(int i);
diff -rupN swig-3.0.0.orig/Examples/as3/as3import/example.i swig-3.0.0/Examples/as3/as3import/example.i
--- swig-3.0.0.orig/Examples/as3/as3import/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/as3import/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,31 @@
+/* File : example.i */
+#ifdef SWIG
+%module ExampleModule
+
+// When the generated wrapper for a function needs custom imports
+// You can add them via the as3import directive. Multiple namespaces
+// should be comma delimited.
+%as3import("flash.utils.ByteArray") printNumber;
+
+%as3import("foo.package1,foo.package2") printNumber2;
+
+
+%typemap(in) (int i) {	
+	int newBufferSize = 0;
+    
+	// Simple test to make sure that we can access a static property of ByteArray
+	inline_as3("%0 = (ByteArray.defaultObjectEncoding) + 1;\n": "=r"(newBufferSize));
+	
+	$1 = newBufferSize;
+}
+
+%{
+#include "example.h"
+%}
+
+%include "example.h"
+#else
+#include "example.h"
+#endif
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/as3import/runme.as swig-3.0.0/Examples/as3/as3import/runme.as
--- swig-3.0.0.orig/Examples/as3/as3import/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/as3import/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,16 @@
+package SWIGExample {
+    import avmplus.System;
+    import com.adobe.flascc.CModule;
+
+    public function ASMain() {
+        
+		// note that the SWIG file ignores this input from ActionScript 
+		// and passes the value of a static ByteArray member to C instead
+        ExampleModule.printNumber(1111);
+        ExampleModule.printNumber2(2222);
+        
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/ascall/Makefile swig-3.0.0/Examples/as3/ascall/Makefile
--- swig-3.0.0.orig/Examples/as3/ascall/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/ascall/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/ascall/example.c swig-3.0.0/Examples/as3/ascall/example.c
--- swig-3.0.0.orig/Examples/as3/ascall/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/ascall/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,26 @@
+/* File : example.c */
+static int (*callback)();
+static int (*callback2)(int, double);
+static double (*callback3)();
+
+void set_callback(int (*func)()) {
+    callback = func;
+}
+
+void set_callback2(int (*funct)(int, double)) {
+    callback2 = funct;
+}
+
+void set_callback3(double (*func)()) {
+    callback3 = func;
+}
+
+void do_call() {
+    int i = callback();
+    printf("callback returned %d to c\n", i);
+    int j = callback2(123, 8.76);
+    printf("callback2 returned %d to c\n", j);
+    double d = callback3();
+    printf("callback3 returned %f to c\n", d);
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/ascall/example.h swig-3.0.0/Examples/as3/ascall/example.h
--- swig-3.0.0.orig/Examples/as3/ascall/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/ascall/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,5 @@
+
+void set_callback(int (*func)());
+void set_callback2(int (*funct)(int, double));
+void set_callback3(double (*func)());
+void do_call();
diff -rupN swig-3.0.0.orig/Examples/as3/ascall/example.i swig-3.0.0/Examples/as3/ascall/example.i
--- swig-3.0.0.orig/Examples/as3/ascall/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/ascall/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,9 @@
+/* File : example.i */
+%module ExampleModule
+
+#ifdef SWIG
+%include "example.h"
+#else
+#include "example.h"
+#endif
+
diff -rupN swig-3.0.0.orig/Examples/as3/ascall/runme.as swig-3.0.0/Examples/as3/ascall/runme.as
--- swig-3.0.0.orig/Examples/as3/ascall/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/ascall/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,28 @@
+package SWIGExample {
+    import avmplus.System;
+
+    function mycallback():int {
+        Trace('callback');
+        return 4321;
+    }
+
+    function mycallback2(a:int, b:Number):int {
+        Trace('callback2, got ' + a + ', ' + b);
+        return 1234;
+    }
+
+    function mycallback3():Number {
+        return 12.3456;
+    }
+    
+    public function ASMain() {
+        ExampleModule.set_callback(mycallback);
+        ExampleModule.set_callback2(mycallback2);
+        ExampleModule.set_callback3(mycallback3);
+        ExampleModule.do_call();
+
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/callback/example.cxx swig-3.0.0/Examples/as3/callback/example.cxx
--- swig-3.0.0.orig/Examples/as3/callback/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/callback/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,4 @@
+/* File : example.cxx */
+
+#include "example.h"
+
diff -rupN swig-3.0.0.orig/Examples/as3/callback/example.h swig-3.0.0/Examples/as3/callback/example.h
--- swig-3.0.0.orig/Examples/as3/callback/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/callback/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,23 @@
+/* File : example.h */
+
+#include <cstdio>
+#include <iostream>
+
+class Callback {
+public:
+	virtual ~Callback() { std::cout << "Callback::~Callback()" << std:: endl; }
+	virtual void run() { std::cout << "Callback::run()" << std::endl; }
+};
+
+
+class Caller {
+private:
+	Callback *_callback;
+public:
+	Caller(): _callback(0) {}
+	~Caller() { delCallback(); }
+	void delCallback() { delete _callback; _callback = 0; }
+	void setCallback(Callback *cb) { delCallback(); _callback = cb; }
+	void call() { if (_callback) _callback->run(); }
+};
+
diff -rupN swig-3.0.0.orig/Examples/as3/callback/example.i swig-3.0.0/Examples/as3/callback/example.i
--- swig-3.0.0.orig/Examples/as3/callback/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/callback/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,13 @@
+/* File : example.i */
+%module(directors="1") example
+%{
+#include "example.h"
+%}
+
+%include "std_string.i"
+
+/* turn on director wrapping Callback */
+%feature("director") Callback;
+
+%include "example.h"
+
diff -rupN swig-3.0.0.orig/Examples/as3/check.list swig-3.0.0/Examples/as3/check.list
--- swig-3.0.0.orig/Examples/as3/check.list	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/check.list	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,53 @@
+# see top-level Makefile.in
+#callback
+class
+constants
+contract
+#docstrings
+enum
+#exception
+#exceptproxy
+#extend
+funcptr
+funcptr2
+#functor
+#import
+#import_template
+#java
+#libffi
+#multimap
+#operator
+outptr
+#pointer
+reference
+simple
+#smartptr
+#std_vector
+#std_map
+#swigrun
+template
+#varargs
+#variables
+
+# These tests written for the as3 module
+struct
+ctors
+ascall
+nspace
+string
+array
+stdint
+static
+
+suppressoverride
+funcptr3
+multi
+overloadop
+funcptr4
+argout
+addressof
+reserved
+template2
+package
+as3import
+copyconstructor
diff -rupN swig-3.0.0.orig/Examples/as3/class/Makefile swig-3.0.0/Examples/as3/class/Makefile
--- swig-3.0.0.orig/Examples/as3/class/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/class/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,20 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+CXXSRCS    = example.cxx
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+LIBS	   = -lm
+
+all::
+	$(MAKE) -f $(TOP)/Makefile CXXSRCS='$(CXXSRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3_cpp
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+
+check: all
+	./$(TARGET)
+
diff -rupN swig-3.0.0.orig/Examples/as3/class/example.cxx swig-3.0.0/Examples/as3/class/example.cxx
--- swig-3.0.0.orig/Examples/as3/class/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/class/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,28 @@
+/* File : example.c */
+
+#include "example.h"
+#define M_PI 3.14159265358979323846
+
+/* Move the shape to a new location */
+void Shape::move(double dx, double dy) {
+  x += dx;
+  y += dy;
+}
+
+int Shape::nshapes = 0;
+
+double Circle::area(void) {
+  return M_PI*radius*radius;
+}
+
+double Circle::perimeter(void) {
+  return 2*M_PI*radius;
+}
+
+double Square::area(void) {
+  return width*width;
+}
+
+double Square::perimeter(void) {
+  return 4*width;
+}
diff -rupN swig-3.0.0.orig/Examples/as3/class/example.h swig-3.0.0/Examples/as3/class/example.h
--- swig-3.0.0.orig/Examples/as3/class/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/class/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,39 @@
+/* File : example.h */
+
+class Shape {
+public:
+  Shape() {
+    nshapes++;
+  }
+  virtual ~Shape() {
+    nshapes--;
+  };
+  double  x, y;   
+  void    move(double dx, double dy);
+  virtual double area(void) = 0;
+  virtual double perimeter(void) = 0;
+  static  int nshapes;
+};
+
+class Circle : public Shape {
+private:
+  double radius;
+public:
+  Circle(double r) : radius(r) { };
+  virtual double area(void);
+  virtual double perimeter(void);
+};
+
+class Square : public Shape {
+private:
+  double width;
+public:
+  Square(double w) : width(w) { };
+  virtual double area(void);
+  virtual double perimeter(void);
+};
+
+
+
+
+  
diff -rupN swig-3.0.0.orig/Examples/as3/class/example.i swig-3.0.0/Examples/as3/class/example.i
--- swig-3.0.0.orig/Examples/as3/class/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/class/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,18 @@
+/* File : example.i */
+#ifdef SWIG
+%module ExampleModule
+
+%{
+#include "example.h"
+%}
+
+/* Let's just grab the original header file here */
+%include "example.h"
+
+#else
+/* This is what clang sees */
+#include "example.h"
+
+#endif
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/class/runme.as swig-3.0.0/Examples/as3/class/runme.as
--- swig-3.0.0.orig/Examples/as3/class/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/class/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,47 @@
+package SWIGExample {
+
+    import avmplus.System;
+
+    public function ASMain() {
+        // Object creation
+        Trace("Creating some objects:");
+        var c = Circle.create(10);
+        Trace("Created circle " + c);
+        var s = Square.create(10);
+        Trace("Created square " + s);
+
+        // Access a static member
+        Trace("\nA total of " + + Shape.nshapes + " shapes were created");
+        
+        // Member data access
+
+        // Set the location of the object
+        c.x = 20;
+        c.y = 30;
+        s.y = -10;
+        s.y = 5;
+
+        Trace("\nHere is their current position:");
+        Trace("    Circle = (" + c.x + ", " + c.y + ")");
+        Trace("    Square = (" + s.x + ", " + s.y + ")");
+
+        // Call some methods
+        Trace("\nHere are some properties of the shapes:");
+        for each (var o in [c, s]) {
+            Trace("    " + o);
+            Trace("        area      = " + o.area());
+            Trace("        perimeter = " + o.perimeter());
+        }
+        
+        Trace("\nGuess I'll clean up now");
+        
+        // Note: this invokes the virtual destructor
+        c.destroy();
+        s.destroy();
+
+        Trace(Shape.nshapes + " shapes remain");
+        Trace("Goodbye");
+
+        return 0;
+    }
+}
diff -rupN swig-3.0.0.orig/Examples/as3/complexcpp/example.cxx swig-3.0.0/Examples/as3/complexcpp/example.cxx
--- swig-3.0.0.orig/Examples/as3/complexcpp/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/complexcpp/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,145 @@
+/* File : example.cxx */
+
+#include <stdio.h>
+#include "example.h"
+
+// PRINT POINTER
+
+void printPointer(struct Bar *number){
+    printf("printPointer: %d\n", number->num);
+}
+
+// SUPPRESS OVERRIDE
+
+class base { 
+protected: 
+virtual ~base(){} 
+}; 
+
+class derived : public base { 
+public: 
+virtual ~derived() {} 
+}; 
+
+// MULTI TYPEMAP
+
+void print_str(int len, char *str) {
+  char buf[len + 1];
+  snprintf(buf, len + 1, "%s", str);
+  printf("%s\n", buf);
+} 
+
+// COPY CONSTRUCTOR
+
+void CRectangle::set_values (int a, int b) {
+    x = a;
+    y = b;
+}
+
+// constructor
+CRectangle::CRectangle(){
+    x = 2;
+    y = 2;
+}
+
+// copy constructor
+CRectangle::CRectangle(const CRectangle& c){
+    printf("in copy constructor\n"); // output of this test should include this string
+    x = c.x;
+    y = c.y;
+}
+
+int createRectAndGetArea() {
+    // call the normal constructor
+    CRectangle rect1;
+    rect1.set_values(3, 4);
+    
+    // call the copy constructor
+    CRectangle rect2 = rect1;
+    
+    // return the area (should be 3*4=12)
+    return rect2.area();
+}
+
+// AS3 IMPORT
+
+void printNumber(int i){
+    printf("printNumber: 4==%d\n", i);
+}
+
+void printNumber2(int i){
+    printf("printNumber2: 4==%d\n", i);
+} 
+
+// SDTINT
+/* Some global variables */
+int32_t a;
+int_least16_t b;
+int_fast8_t c;
+uint8_t d;
+intptr_t e;
+
+ 
+// NESTED CPP
+/*
+int MotorCar::DesignOpinion::AceDesignCount = 0;
+int MotorCar::DesignOpinion::TotalDesignCount = 0;
+
+int MotorCar::DesignOpinion::PercentScore() {
+  return AceDesignCount*100/TotalDesignCount;
+}
+
+MotorCar::Wheels::Wheels(Shape shape, size_t count) : shape(shape), count(count) {}
+
+MotorCar::WindScreen::WindScreen(bool opaque) : opaque(opaque) {}
+
+MotorCar::MotorCar(const std::string &name, const Wheels &wheels, const WindScreen &windscreen) : name(name), wheels(wheels), windscreen(windscreen) {}
+
+MotorCar MotorCar::DesignFromComponents(const std::string &name, const Wheels &wheels, const WindScreen &windscreen) {
+  MotorCar car = MotorCar(name, wheels, windscreen);
+  DesignOpinion::TotalDesignCount++;
+  if (car.wheels.Opinion().itrocks && car.windscreen.Opinion().itrocks)
+    DesignOpinion::AceDesignCount++;
+  return car;
+}
+
+MotorCar::DesignOpinion MotorCar::Wheels::Opinion() {
+  DesignOpinion opinion;
+  opinion.itrocks = true;
+  if (shape == Square) {
+    opinion.itrocks = false;
+    opinion.reason = "you'll have a few issues with wheel rotation";
+  }
+  if (count <= 2) {
+    opinion.reason += opinion.itrocks ? "" : " and ";
+    opinion.itrocks = false;
+    opinion.reason += "a few more wheels are needed for stability";
+  }
+  if (opinion.itrocks)
+    opinion.reason = "your choice of wheels was top notch";
+
+  return opinion;
+}
+
+MotorCar::DesignOpinion MotorCar::WindScreen::Opinion() {
+  DesignOpinion opinion;
+  opinion.itrocks = !opaque;
+  opinion.reason = opinion.itrocks ? "the driver will have a commanding view out the window" : "you can't see out the windscreen";
+  return opinion;
+}
+
+std::string MotorCar::WillItWork() {
+  DesignOpinion wh = wheels.Opinion();
+  DesignOpinion ws = windscreen.Opinion();
+  std::string willit;
+  if (wh.itrocks && ws.itrocks) {
+    willit = "Great car design because " + wh.reason + " and " + ws.reason;
+  } else {
+    willit = "You need a rethink because ";
+    willit += wh.itrocks ? "" : wh.reason;
+    willit += (!wh.itrocks && !ws.itrocks) ? " and " : "";
+    willit += ws.itrocks ? "" : ws.reason;
+  }
+  return willit;
+}
+*/
\ No newline at end of file
diff -rupN swig-3.0.0.orig/Examples/as3/complexcpp/example.h swig-3.0.0/Examples/as3/complexcpp/example.h
--- swig-3.0.0.orig/Examples/as3/complexcpp/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/complexcpp/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,104 @@
+/* File : example.h */
+
+#include <cstdio>
+#include <iostream>
+#include <stdint.h> 
+
+// EXTENDS
+
+typedef float float32;
+
+class BaseClass
+{
+public:
+	BaseClass()/*{}*/;
+
+	virtual ~BaseClass() {}
+    
+	virtual void DrawCircle(float32 radius) = 0;
+    
+	virtual void DrawSegment() = 0;
+    
+	void DrawConcrete() {};
+
+protected:
+	int m_drawFlags;
+};
+
+class ExtendedClass : public BaseClass {
+public:
+	ExtendedClass() {}
+	~ExtendedClass() {}
+    void DrawCircle(float32 radius) {}
+	void DrawSegment() {}
+};
+
+// COPY CONSTRUCTOR
+
+class CRectangle {
+    int x, y;
+public:
+    void set_values (int,int);
+    int area () {return (x*y);}
+    CRectangle();
+    CRectangle(const CRectangle& c);
+};
+
+int createRectAndGetArea();
+  
+// PRINT POINTER
+
+struct Bar {
+	int num;
+};
+
+void printPointer(struct Bar *number); 
+
+// AS3 IMPORT
+
+void printNumber(int i);
+void printNumber2(int i);  
+
+// NESTED CPP
+
+/** Design a motor car from various components */
+/*struct MotorCar {
+
+  struct DesignOpinion {
+    bool itrocks;
+    std::string reason;
+    static int AceDesignCount;
+    static int TotalDesignCount;
+    static int PercentScore();
+  };
+
+  struct Wheels {
+    enum Shape { Round, Square };
+    Wheels(Shape shape, size_t count);
+    DesignOpinion Opinion();
+  private:
+    Shape shape;
+    size_t count;
+  };
+
+  struct WindScreen {
+    WindScreen(bool opaque);
+    DesignOpinion Opinion();
+  private:
+    bool opaque;
+  };
+
+  static MotorCar DesignFromComponents(const std::string &name, const Wheels &wheels, const WindScreen &windscreen);
+
+  std::string Name() {
+    return name;
+  }
+
+  std::string WillItWork();
+
+private:
+  MotorCar(const std::string &name, const Wheels &wheels, const WindScreen &windscreen);
+  std::string name;
+  Wheels wheels;
+  WindScreen windscreen;
+};*/
\ No newline at end of file
diff -rupN swig-3.0.0.orig/Examples/as3/complexcpp/example.i swig-3.0.0/Examples/as3/complexcpp/example.i
--- swig-3.0.0.orig/Examples/as3/complexcpp/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/complexcpp/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,237 @@
+/* File : example.i */
+%module example
+
+%{
+#include "example.h"    
+#include <AS3/AS3++.h>
+#include <Flash++.h>  
+%}
+
+%feature("autodoc");
+
+%text %{
+AS3 AUTODOC TEST
+%} 
+
+// STDINT
+
+%include <stdint.i> 
+
+%inline %{
+extern int32_t a;
+extern int_least16_t b;
+extern int_fast8_t c;
+extern uint8_t d;
+extern intptr_t e;
+%} 
+
+// COPY CONSTRUCTOR
+
+/* Ignore the Copy Constructor */
+%ignore CRectangle(const CRectangle& c);
+
+// AS3 IMPORT
+
+// When the generated wrapper for a function needs custom imports
+// You can add them via the as3import directive. Multiple namespaces
+// should be comma delimited.
+%as3import("flash.utils.ByteArray") printNumber;
+
+%as3import("foo.package1,foo.package2") printNumber2;
+
+
+%typemap(in) (int i) {	
+	int newBufferSize = 0;
+    
+	// Simple test to make sure that we can access a static property of ByteArray
+	inline_as3("%0 = (ByteArray.defaultObjectEncoding) + 1;\n": "=r"(newBufferSize));
+	
+	$1 = newBufferSize;
+}
+ 
+
+// CONSTANTS
+
+/* A few preprocessor macros */
+
+#define    ICONST      42
+#define    FCONST      2.1828
+#define    CCONST      'x'
+#define    CCONST2     '\n'
+#define    SCONST      "Hello World"
+#define    SCONST2     "\"Hello World\""
+
+/* This should work just fine */
+#define    EXPR        ICONST + 3*(FCONST)
+
+/* This shouldn't do anything */
+#define    EXTERN      extern
+
+/* Neither should this (BAR isn't defined) */
+#define    FOO         (ICONST + BAR)
+
+/* The following directives also produce constants */
+
+%constant int iconst = 37;
+%constant double fconst = 3.14;
+%constant int b = ICONST;
+
+// SUPPRESSOVERRIDE
+
+// Because no destructor is exposed in the base class
+// we must suppress the use of the AS3 override keyword
+// when wrapping the derived class's destructor
+%as3suppressoverride derived::~derived; 
+
+// MULTI TYPEMAP
+
+%typemap(in) (int len, char *str) {
+    AS3_MallocString($2, $input);
+    AS3_StringLength($1, $input);
+};
+
+%typemap(astype) (int len, char *str) "String";
+
+%typemap(freearg) (int len, char *str) {
+    printf("cleaning up\n");
+    free($2);
+};
+
+%inline %{
+extern void print_str(int len, char *str);
+%} 
+    
+// GRAB HEADER
+
+%include "example.h"
+
+// INTEROP
+
+%{ 
+ 
+////
+//
+// Get a property of an ActionScript object in C++
+//
+////
+ 
+void getDelta() __attribute__((used,
+    annotate("as3import:flash.events.MouseEvent"),
+    annotate("as3sig:public function getDelta(m:MouseEvent):int"),
+    annotate("as3package:utils")));
+ 
+void getDelta()
+{
+    // marshall the AS3 parameter into a C++ variable
+    AS3::local::var mouseEvent;
+    AS3_GetVarxxFromVar(mouseEvent, m);
+ 
+    // now that we have it in C++ let's get a property on that object
+    AS3::local::var propertyName = AS3::local::internal::new_String("delta");
+    AS3::local::var outputValue = AS3::local::internal::getproperty(mouseEvent, propertyName);
+ 
+    // convert the var to a scalar
+    int output = AS3::local::internal::int_valueOf(outputValue);
+ 
+    // return that scalar value
+    AS3_Return(output);
+} 
+ 
+////
+//
+// Set a property on an ActionScript object in C++
+//
+////
+ 
+void setDelta() __attribute__((used,
+    annotate("as3import:flash.events.MouseEvent"),
+    annotate("as3sig:public function setDelta(m:MouseEvent):void"),
+    annotate("as3package:utils")));
+ 
+void setDelta()
+{
+    // marshall the AS3 parameter into a C++ variable
+    AS3::local::var mouseEvent;
+    AS3_GetVarxxFromVar(mouseEvent, m);
+ 
+    // now that we have it in C++ let's set a property on that object
+    AS3::local::var propertyName = AS3::local::internal::new_String("delta");
+    AS3::local::var newValue = AS3::local::internal::new_int(5);
+    AS3::local::internal::setproperty(mouseEvent, propertyName, newValue);
+}
+ 
+ 
+////
+//
+// Call a method of an ActionScript object in C++
+//
+////
+ 
+void getString() __attribute__((used,
+    annotate("as3import:flash.events.MouseEvent"),
+    annotate("as3sig:public function getString(m:MouseEvent):String"),
+    annotate("as3package:utils")));
+ 
+void getString()
+{
+    // marshall the AS3 parameter into a C++ variable
+    AS3::local::var mouseEvent;
+    AS3_GetVarxxFromVar(mouseEvent, m);
+ 
+    // demonstrate how to call a function of that object from C++
+    AS3::local::var functionName = AS3::local::internal::new_String("toString");
+    // first get the property of the object called "toString" which is a Function var
+    AS3::local::var function = AS3::local::internal::getproperty(mouseEvent, functionName);
+ 
+    // then call that Function object (in this case it takes no parameters)
+    AS3::local::var output = AS3::local::internal::call(function, AS3::local::internal::_null, 0, NULL);
+ 
+    // Since AS3_Return (as shown in getDelta()) can only accept a scalar value we need
+    // to marshall this C++ object into an ActionScript String and return it using AS3_ReturnVar
+    AS3_DeclareVar(asOutputString, String);
+    AS3_CopyVarxxToVar(asOutputString, output);
+    AS3_ReturnAS3Var(asOutputString);
+}
+
+%}
+
+// EXTENDS
+
+%{
+    BaseClass::BaseClass() {}
+%}
+
+
+// with inline we both declare class and wrapper at once
+%inline %{ 
+
+class SpecialClass : public BaseClass {
+public:
+	SpecialClass() {}
+	~SpecialClass() {}
+    void DrawCircle(float32 radius) {}
+	void DrawSegment() {}
+};
+
+%}
+
+// declare class and wrapper separately
+%{ 
+
+class ExtraClass : public BaseClass {
+public:
+	ExtraClass() {}
+	~ExtraClass() {}
+    void DrawCircle(float32 radius) {}
+	void DrawSegment() {}
+};
+
+%}
+
+class ExtraClass : public BaseClass {
+public:
+	ExtraClass() {}
+	~ExtraClass() {}
+    void DrawCircle(float32 radius) {}
+	void DrawSegment() {}
+};
diff -rupN swig-3.0.0.orig/Examples/as3/constants/Makefile swig-3.0.0/Examples/as3/constants/Makefile
--- swig-3.0.0.orig/Examples/as3/constants/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/constants/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/constants/example.i swig-3.0.0/Examples/as3/constants/example.i
--- swig-3.0.0.orig/Examples/as3/constants/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/constants/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,27 @@
+/* File : example.i */
+%module ExampleModule
+
+/* A few preprocessor macros */
+
+#define    ICONST      42
+#define    FCONST      2.1828
+#define    CCONST      'x'
+#define    CCONST2     '\n'
+#define    SCONST      "Hello World"
+#define    SCONST2     "\"Hello World\""
+
+/* This should work just fine */
+#define    EXPR        ICONST + 3*(FCONST)
+
+/* This shouldn't do anything */
+#define    EXTERN      extern
+
+/* Neither should this (BAR isn't defined) */
+#define    FOO         (ICONST + BAR)
+
+/* The following directives also produce constants */
+
+%constant int iconst = 37;
+%constant double fconst = 3.14;
+%constant int b = ICONST;
+
diff -rupN swig-3.0.0.orig/Examples/as3/constants/runme.as swig-3.0.0/Examples/as3/constants/runme.as
--- swig-3.0.0.orig/Examples/as3/constants/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/constants/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,22 @@
+package SWIGExample {
+import avmplus.System;
+
+public function ASMain() {
+    Trace("ICONST = " + ExampleModule.ICONST + " (should be 42)");
+    Trace("FCONST = " + ExampleModule.FCONST + " (should be 2.1828)");
+    Trace("CCONST = " + ExampleModule.CCONST + " (should be 'x')");
+    Trace("CCONST = " + ExampleModule.CCONST2 + "(this should be on a new line)");
+    Trace("SCONST = " + ExampleModule.SCONST + " (should be 'Hello World')");
+    Trace("SCONST2 = " + ExampleModule.SCONST2 + " (should be '\"Hello World\"')");
+    Trace("EXPR = " + ExampleModule.EXPR + " (should be 48.5484)");
+    Trace("iconst = " + ExampleModule.iconst + " (should be 37)");
+    Trace("fconst = " + ExampleModule.fconst + " (should be 3.14)");
+    Trace("b = " + ExampleModule.b + " (should be 42)");
+
+    Trace("EXTERN = " + ExampleModule.EXTERN + " (should be undefined)");
+    Trace("FOO = " + ExampleModule.FOO + " (should be undefined)");
+
+    return 0;
+}
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/contract/Makefile swig-3.0.0/Examples/as3/contract/Makefile
--- swig-3.0.0.orig/Examples/as3/contract/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/contract/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/contract/example.c swig-3.0.0/Examples/as3/contract/example.c
--- swig-3.0.0.orig/Examples/as3/contract/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/contract/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,23 @@
+/* File : example.c */
+
+/* A global variable */
+double Foo = 3.0;
+
+/* Compute the greatest common divisor of positive integers */
+int gcd(int x, int y) {
+  int g;
+  g = y;
+  while (x > 0) {
+    g = x;
+    x = y % x;
+    y = g;
+  }
+  return g;
+}
+
+int fact(int n) {
+  if (n <= 0) return 1;
+  return n*fact(n-1);
+}
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/contract/example.i swig-3.0.0/Examples/as3/contract/example.i
--- swig-3.0.0.orig/Examples/as3/contract/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/contract/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,21 @@
+/* File : example.i */
+%module ExampleModule
+
+%contract gcd(int x, int y) {
+require:
+	x >= 0;
+	y >= 0;
+}
+
+%contract fact(int n) {
+require:
+	n >= 0;
+ensure:
+	fact >= 1;
+}
+
+%inline %{
+extern int    gcd(int x, int y);
+extern int    fact(int n);
+extern double Foo;
+%}
diff -rupN swig-3.0.0.orig/Examples/as3/contract/runme.as swig-3.0.0/Examples/as3/contract/runme.as
--- swig-3.0.0.orig/Examples/as3/contract/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/contract/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,18 @@
+
+package SWIGExample {
+    import avmplus.System; 
+
+    public function ASMain() {
+        var x = 42, y = 105;
+        var g = ExampleModule.gcd(x, y);
+        Trace('The gcd of ' + x + ' and ' + y + ' is ' + g);
+        
+        Trace('Foo = ' + ExampleModule.Foo);
+        ExampleModule.Foo = 3.1415926;
+        Trace('Foo = ' + ExampleModule.Foo);
+
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/copyconstructor/Makefile swig-3.0.0/Examples/as3/copyconstructor/Makefile
--- swig-3.0.0.orig/Examples/as3/copyconstructor/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/copyconstructor/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,20 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+CXXSRCS    = example.cxx
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+LIBS	   = -lm
+
+all::
+	$(MAKE) -f $(TOP)/Makefile CXXSRCS='$(CXXSRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3_cpp
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+
+check: all
+	./$(TARGET)
+
diff -rupN swig-3.0.0.orig/Examples/as3/copyconstructor/example.cxx swig-3.0.0/Examples/as3/copyconstructor/example.cxx
--- swig-3.0.0.orig/Examples/as3/copyconstructor/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/copyconstructor/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,34 @@
+/* File : example.cxx */
+#include <stdio.h>
+#include "example.h"
+
+
+void CRectangle::set_values (int a, int b) {
+    x = a;
+    y = b;
+}
+
+// constructor
+CRectangle::CRectangle(){
+    x = 2;
+    y = 2;
+}
+
+// copy constructor
+CRectangle::CRectangle(const CRectangle& c){
+    printf("in copy constructor\n"); // output of this test should include this string
+    x = c.x;
+    y = c.y;
+}
+
+int createRectAndGetArea() {
+    // call the normal constructor
+    CRectangle rect1;
+    rect1.set_values(3, 4);
+    
+    // call the copy constructor
+    CRectangle rect2 = rect1;
+    
+    // return the area (should be 3*4=12)
+    return rect2.area();
+}
diff -rupN swig-3.0.0.orig/Examples/as3/copyconstructor/example.h swig-3.0.0/Examples/as3/copyconstructor/example.h
--- swig-3.0.0.orig/Examples/as3/copyconstructor/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/copyconstructor/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,14 @@
+/* File : example.h */
+
+class CRectangle {
+    int x, y;
+public:
+    void set_values (int,int);
+    int area () {return (x*y);}
+    CRectangle();
+    CRectangle(const CRectangle& c);
+};
+
+int createRectAndGetArea();
+
+  
diff -rupN swig-3.0.0.orig/Examples/as3/copyconstructor/example.i swig-3.0.0/Examples/as3/copyconstructor/example.i
--- swig-3.0.0.orig/Examples/as3/copyconstructor/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/copyconstructor/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,22 @@
+/* File : example.i */
+#ifdef SWIG
+%module ExampleModule
+
+%{
+#include "example.h"
+%}
+
+
+/* Ignore the Copy Constructor */
+%ignore CRectangle(const CRectangle& c);
+
+/* Let's just grab the original header file here */
+%include "example.h"
+
+#else
+/* This is what clang sees */
+#include "example.h"
+
+#endif
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/copyconstructor/runme.as swig-3.0.0/Examples/as3/copyconstructor/runme.as
--- swig-3.0.0.orig/Examples/as3/copyconstructor/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/copyconstructor/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,10 @@
+package SWIGExample {
+
+    import avmplus.System;
+
+    public function ASMain() {
+        Trace("output: " + ExampleModule.createRectAndGetArea());
+        
+        return 0;
+    }
+}
diff -rupN swig-3.0.0.orig/Examples/as3/ctors/Makefile swig-3.0.0/Examples/as3/ctors/Makefile
--- swig-3.0.0.orig/Examples/as3/ctors/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/ctors/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,20 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+CXXSRCS    = 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example_wrap
+LIBS	   = -lm
+
+all::
+	$(MAKE) -f $(TOP)/Makefile CXXSRCS='$(CXXSRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3_cpp
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+
+check: all
+	./$(TARGET)
+
diff -rupN swig-3.0.0.orig/Examples/as3/ctors/example.h swig-3.0.0/Examples/as3/ctors/example.h
--- swig-3.0.0.orig/Examples/as3/ctors/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/ctors/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,23 @@
+/* File : example.h */
+
+class A {
+public:
+  A() {
+    printf("A ctor\n");
+  }
+};
+
+class B : public A {
+public:
+  B() {
+    printf("B ctor\n");
+  }
+};
+
+class C : public B {
+public:
+  C() {
+    printf("C ctor\n");
+  }
+};
+
diff -rupN swig-3.0.0.orig/Examples/as3/ctors/example.i swig-3.0.0/Examples/as3/ctors/example.i
--- swig-3.0.0.orig/Examples/as3/ctors/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/ctors/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+/* File : example.i */
+#ifdef SWIG
+%module ExampleModule
+
+%{
+#include <stdio.h>
+#include "example.h"
+%}
+
+/* Let's just grab the original header file here */
+%include "example.h"
+
+#else
+/* This is what clang sees */
+#include "example.h"
+
+#endif
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/ctors/runme.as swig-3.0.0/Examples/as3/ctors/runme.as
--- swig-3.0.0.orig/Examples/as3/ctors/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/ctors/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,8 @@
+package SWIGExample {
+    import avmplus.System;
+    public function ASMain() {
+        // Object creation
+        C.create();
+        return 0;
+    }
+}
diff -rupN swig-3.0.0.orig/Examples/as3/enum/Makefile swig-3.0.0/Examples/as3/enum/Makefile
--- swig-3.0.0.orig/Examples/as3/enum/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/enum/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+CXXSRCS    = example.cxx 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile CXXSRCS='$(CXXSRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3_cpp
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET)
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/enum/example.cxx swig-3.0.0/Examples/as3/enum/example.cxx
--- swig-3.0.0.orig/Examples/as3/enum/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/enum/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,37 @@
+/* File : example.c */
+
+#include "example.h"
+#include <stdio.h>
+
+void Foo::enum_test(speed s) {
+  if (s == IMPULSE) {
+    printf("IMPULSE speed\n");
+  } else if (s == WARP) {
+    printf("WARP speed\n");
+  } else if (s == LUDICROUS) {
+    printf("LUDICROUS speed\n");
+  } else {
+    printf("Unknown speed\n");
+  }
+}
+
+void enum_test(color c, Foo::speed s) {
+  if (c == RED) {
+    printf("color = RED, ");
+  } else if (c == BLUE) {
+    printf("color = BLUE, ");
+  } else if (c == GREEN) {
+    printf("color = GREEN, ");
+  } else {
+    printf("color = Unknown color!, ");
+  }
+  if (s == Foo::IMPULSE) {
+    printf("speed = IMPULSE speed\n");
+  } else if (s == Foo::WARP) {
+    printf("speed = WARP speed\n");
+  } else if (s == Foo::LUDICROUS) {
+    printf("speed = LUDICROUS speed\n");
+  } else {
+    printf("speed = Unknown speed!\n");
+  }
+}
diff -rupN swig-3.0.0.orig/Examples/as3/enum/example.h swig-3.0.0/Examples/as3/enum/example.h
--- swig-3.0.0.orig/Examples/as3/enum/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/enum/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,13 @@
+/* File : example.h */
+
+enum color { RED, BLUE, GREEN };
+
+class Foo {
+ public:
+  Foo() { }
+  enum speed { IMPULSE, WARP, LUDICROUS };
+  void enum_test(speed s);
+};
+
+void enum_test(color c, Foo::speed s);
+
diff -rupN swig-3.0.0.orig/Examples/as3/enum/example.i swig-3.0.0/Examples/as3/enum/example.i
--- swig-3.0.0.orig/Examples/as3/enum/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/enum/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,11 @@
+/* File : example.i */
+%module ExampleModule
+
+%{
+#include "example.h"
+%}
+
+/* Let's just grab the original header file here */
+
+%include "example.h"
+
diff -rupN swig-3.0.0.orig/Examples/as3/enum/runme.as swig-3.0.0/Examples/as3/enum/runme.as
--- swig-3.0.0.orig/Examples/as3/enum/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/enum/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,34 @@
+package SWIGExample {
+    import avmplus.System;
+
+    public function ASMain() {
+        // Object creation
+
+        // Print out the values of some enums
+        Trace("*** color ***");
+        Trace("    RED    = " + ExampleModule.RED);
+        Trace("    BLUE   = " + ExampleModule.BLUE);
+        Trace("    GREEN  = " + ExampleModule.GREEN);
+
+        Trace("\n*** Foo:speed ***");
+        Trace("    Foo_IMPULSE   = " + Foo.IMPULSE);
+        Trace("    Foo_WARP      = " + Foo.WARP);
+        Trace("    Foo_LUDICROUS = " + Foo.LUDICROUS);
+
+        Trace("\nTesting use of enums with functions\n");
+
+        ExampleModule.enum_test(ExampleModule.RED, Foo.IMPULSE);
+        ExampleModule.enum_test(ExampleModule.BLUE, Foo.WARP);
+        ExampleModule.enum_test(ExampleModule.GREEN, Foo.LUDICROUS);
+        ExampleModule.enum_test(1234, 5678);
+
+        Trace("\nTesting use of enum with class methods");
+        var f = Foo.create();
+        
+        f.enum_test(Foo.IMPULSE);
+        f.enum_test(Foo.WARP);
+        f.enum_test(Foo.LUDICROUS);
+    
+        return 0;
+    }
+}
diff -rupN swig-3.0.0.orig/Examples/as3/extend/example.cxx swig-3.0.0/Examples/as3/extend/example.cxx
--- swig-3.0.0.orig/Examples/as3/extend/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/extend/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,4 @@
+/* File : example.cxx */
+
+#include "example.h"
+
diff -rupN swig-3.0.0.orig/Examples/as3/extend/example.h swig-3.0.0/Examples/as3/extend/example.h
--- swig-3.0.0.orig/Examples/as3/extend/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/extend/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,56 @@
+/* File : example.h */
+
+#include <cstdio>
+#include <iostream>
+#include <vector>
+#include <string>
+#include <cmath>
+
+class Employee {
+private:
+	std::string name;
+public:
+	Employee(const char* n): name(n) {}
+	virtual std::string getTitle() { return getPosition() + " " + getName(); }
+	virtual std::string getName() { return name; }
+	virtual std::string getPosition() const { return "Employee"; }
+	virtual ~Employee() { printf("~Employee() @ %p\n", this); }
+};
+
+
+class Manager: public Employee {
+public:
+	Manager(const char* n): Employee(n) {}
+	virtual std::string getPosition() const { return "Manager"; }
+};
+
+
+class EmployeeList {
+	std::vector<Employee*> list;
+public:
+	EmployeeList() {
+		list.push_back(new Employee("Bob"));
+		list.push_back(new Employee("Jane"));
+		list.push_back(new Manager("Ted"));
+	}
+	void addEmployee(Employee *p) {
+		list.push_back(p);
+		std::cout << "New employee added.   Current employees are:" << std::endl;
+		std::vector<Employee*>::iterator i;
+		for (i=list.begin(); i!=list.end(); i++) {
+			std::cout << "  " << (*i)->getTitle() << std::endl;
+		}
+	}
+	const Employee *get_item(int i) {
+		return list[i];
+	}
+	~EmployeeList() { 
+		std::vector<Employee*>::iterator i;
+		std::cout << "~EmployeeList, deleting " << list.size() << " employees." << std::endl;
+		for (i=list.begin(); i!=list.end(); i++) {
+			delete *i;
+		}
+		std::cout << "~EmployeeList empty." << std::endl;
+	}
+};
+
diff -rupN swig-3.0.0.orig/Examples/as3/extend/example.i swig-3.0.0/Examples/as3/extend/example.i
--- swig-3.0.0.orig/Examples/as3/extend/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/extend/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,15 @@
+/* File : example.i */
+%module(directors="1") example
+%{
+#include "example.h"
+%}
+
+%include "std_vector.i"
+%include "std_string.i"
+
+/* turn on director wrapping for Manager */
+%feature("director") Employee;
+%feature("director") Manager;
+
+%include "example.h"
+
diff -rupN swig-3.0.0.orig/Examples/as3/flashpp/example.cxx swig-3.0.0/Examples/as3/flashpp/example.cxx
--- swig-3.0.0.orig/Examples/as3/flashpp/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/flashpp/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,3 @@
+/* File : example.cxx */
+
+#include "example.h"
\ No newline at end of file
diff -rupN swig-3.0.0.orig/Examples/as3/flashpp/example.h swig-3.0.0/Examples/as3/flashpp/example.h
--- swig-3.0.0.orig/Examples/as3/flashpp/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/flashpp/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,23 @@
+/* File : example.h */
+
+#include <cstdio>
+#include <iostream>
+
+typedef float float32;
+
+class BaseClass
+{
+public:
+	BaseClass()/*{}*/;
+
+	virtual ~BaseClass() {}
+    
+	virtual void DrawCircle(float32 radius) = 0;
+    
+	virtual void DrawSegment() = 0;
+    
+	void DrawConcrete() {};
+
+protected:
+	int m_drawFlags;
+};
diff -rupN swig-3.0.0.orig/Examples/as3/flashpp/example.i swig-3.0.0/Examples/as3/flashpp/example.i
--- swig-3.0.0.orig/Examples/as3/flashpp/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/flashpp/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,38 @@
+/* File : example.i */
+%module example
+
+%{
+    #include "example.h"
+    #include <AS3/AS3++.h>
+#include <Flash++.h>
+%}
+
+%include "example.h"
+
+%{
+    BaseClass::BaseClass() {}
+%}
+
+// with inline we both declare class and wrapper at once
+%inline %{ 
+
+class SpecialClass : public BaseClass {
+public:
+    AS3::ui::var drawArea;
+    AS3::ui::flash::display::Shape canvas;
+	SpecialClass() {
+        AS3_Trace("SpecialClass::Created");
+        AS3::local::var s = AS3::local::internal::new_String("SpecialClass loaded.");
+        AS3::local::internal::trace(s);
+        AS3::ui::flash::display::Stage stage = AS3::ui::internal::get_Stage();
+        canvas = AS3::ui::flash::display::Shape::_new();
+        drawArea = canvas;
+    }
+	~SpecialClass() {AS3_Trace("SpecialClass::Destroyed");}
+    void DrawCircle(float32 radius) {}
+    int getInteger() {return 1000;}
+	void DrawSegment() {}
+    
+};
+
+%}
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr/Makefile swig-3.0.0/Examples/as3/funcptr/Makefile
--- swig-3.0.0.orig/Examples/as3/funcptr/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr/example.c swig-3.0.0/Examples/as3/funcptr/example.c
--- swig-3.0.0.orig/Examples/as3/funcptr/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,20 @@
+/* File : example.c */
+
+int do_op(int a, int b, int (*op)(int,int)) {
+  return (*op)(a,b);
+}
+
+int add(int a, int b) {
+  //__asm__ volatile("throw('what: ' + new Error().getStackTrace());");
+  return a+b;
+}
+
+int sub(int a, int b) {
+  return a-b;
+}
+
+int mul(int a, int b) {
+  return a*b;
+}
+
+int (*funcvar)(int,int) = add;
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr/example.h swig-3.0.0/Examples/as3/funcptr/example.h
--- swig-3.0.0.orig/Examples/as3/funcptr/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,9 @@
+/* file: example.h */
+
+extern int do_op(int,int, int (*op)(int,int));
+extern int add(int,int);
+extern int sub(int,int);
+extern int mul(int,int);
+
+extern int (*funcvar)(int,int);
+
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr/example.i swig-3.0.0/Examples/as3/funcptr/example.i
--- swig-3.0.0.orig/Examples/as3/funcptr/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,16 @@
+/* File : example.i */
+%module ExampleModule
+%{
+#include "example.h"
+%}
+
+/* Wrap a function taking a pointer to a function */
+extern int  do_op(int a, int b, int (*op)(int, int));
+
+/* Now install a bunch of "ops" as constants */
+%constant int (*ADD)(int,int) = add;
+%constant int (*SUB)(int,int) = sub;
+%constant int (*MUL)(int,int) = mul;
+
+extern int (*funcvar)(int,int);
+
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr/runme.as swig-3.0.0/Examples/as3/funcptr/runme.as
--- swig-3.0.0.orig/Examples/as3/funcptr/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,22 @@
+package SWIGExample {
+import avmplus.System;
+public function ASMain() {
+    var a = 37;
+    var b = 42;
+
+    // Now call our C function with a bunch of callbacks
+    Trace("Trying some C callback functions");
+    Trace("    a        = " + a);
+    Trace("    b        = " + b);
+    Trace("    ADD(a,b) = " + ExampleModule.do_op(a, b, ExampleModule.ADD));
+    Trace("    SUB(a,b) = " + ExampleModule.do_op(a, b, ExampleModule.SUB));
+    Trace("    MUL(a,b) = " + ExampleModule.do_op(a, b, ExampleModule.MUL));
+
+    Trace("Here is what the C callback function objects look like in AS");
+    Trace("    ADD      = " + ExampleModule.ADD);
+    Trace("    SUB      = " + ExampleModule.SUB);
+    Trace("    MUL      = " + ExampleModule.MUL);
+
+    return 0;
+}
+}
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr2/Makefile swig-3.0.0/Examples/as3/funcptr2/Makefile
--- swig-3.0.0.orig/Examples/as3/funcptr2/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr2/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr2/example.as swig-3.0.0/Examples/as3/funcptr2/example.as
--- swig-3.0.0.orig/Examples/as3/funcptr2/example.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr2/example.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,97 @@
+
+/* Function pointers support */
+package SWIGExample {
+import flash.utils.Dictionary;
+import com.adobe.flascc.CModule;
+
+var _SWIG_AS3Func2Ptr:Dictionary = new Dictionary();
+var _SWIG_AS3Ptr2Func:Dictionary = new Dictionary();
+
+function SWIG_AS3RegASCallWrapper(ptr:int, wrapper:Function):void {
+    if (_SWIG_AS3Ptr2Func[ptr]) {
+        throw("tried to register AS-callable wrapper for existing AS wrapper");
+    }
+    _SWIG_AS3Func2Ptr[wrapper] = ptr;
+    _SWIG_AS3Ptr2Func[ptr] = wrapper;
+}
+
+// Returns Function objects callable from AS
+function SWIG_AS3GetASCallWrapper(ptr:int):Function {
+    if (_SWIG_AS3Ptr2Func[ptr]) {
+        return _SWIG_AS3Ptr2Func[ptr];
+    } else {
+        return null;
+    }
+}
+
+function SWIG_AS3RegCCallWrapper(func:Function, wrapper:Function):void {
+    var ptr:int;
+    
+    if (_SWIG_AS3Func2Ptr[func]) {
+        throw("tried to register C-callable wrapper for native C function");
+    }
+
+    ptr = CModule.allocFunPtrs(1, 4);
+    CModule.regFun(ptr, wrapper);
+    _SWIG_AS3Func2Ptr[func] = ptr;
+    _SWIG_AS3Ptr2Func[ptr] = func;
+
+}
+
+// Returns a C function pointer corresponding to an Actionscript-callable 
+// wrapper Function. (The C function is callable from C, of course).
+function SWIG_AS3GetCCallPtr(func:Function):int {
+    if (_SWIG_AS3Func2Ptr[func]) {
+        return _SWIG_AS3Func2Ptr[func];
+    } else {
+        return 0;
+    }
+}
+} /* package */
+
+
+
+package {
+import SWIGExample.*;
+import flash.utils.ByteArray;
+
+
+public class example {
+	public static function do_op(a:int, b:int, op:Function):int {
+		return _wrap_do_op(a, b, op);
+	}
+
+	public static function get add():Function{
+		return _wrap_add();
+	}
+
+	public static function add(arg1:int, arg2:int):int {
+		return _wrap_add(arg1, arg2);
+	}
+
+	public static function get sub():Function{
+		return _wrap_sub();
+	}
+
+	public static function sub(arg1:int, arg2:int):int {
+		return _wrap_sub(arg1, arg2);
+	}
+
+	public static function get mul():Function{
+		return _wrap_mul();
+	}
+
+	public static function mul(arg1:int, arg2:int):int {
+		return _wrap_mul(arg1, arg2);
+	}
+
+	public static function set funcvar(funcvar:Function):void {
+		_wrap_funcvar_set(funcvar);
+	}
+
+	public static function get funcvar():Function {
+		return _wrap_funcvar_get();
+	}
+
+}
+} /* package */
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr2/example.c swig-3.0.0/Examples/as3/funcptr2/example.c
--- swig-3.0.0.orig/Examples/as3/funcptr2/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr2/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+/* File : example.c */
+
+int do_op(int a, int b, int (*op)(int,int)) {
+  return (*op)(a,b);
+}
+
+int add(int a, int b) {
+  return a+b;
+}
+
+int sub(int a, int b) {
+  return a-b;
+}
+
+int mul(int a, int b) {
+  return a*b;
+}
+
+int (*funcvar)(int,int) = add;
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr2/example.h swig-3.0.0/Examples/as3/funcptr2/example.h
--- swig-3.0.0.orig/Examples/as3/funcptr2/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr2/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,9 @@
+/* file: example.h */
+
+extern int do_op(int,int, int (*op)(int,int));
+extern int add(int,int);
+extern int sub(int,int);
+extern int mul(int,int);
+
+extern int (*funcvar)(int,int);
+
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr2/example.i swig-3.0.0/Examples/as3/funcptr2/example.i
--- swig-3.0.0.orig/Examples/as3/funcptr2/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr2/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,18 @@
+/* File : example.i */
+%module ExampleModule
+%{
+#include "example.h"
+%}
+
+/* Wrap a function taking a pointer to a function */
+extern int  do_op(int a, int b, int (*op)(int, int));
+
+/* Now install a bunch of "ops" as constants */
+%callback("%(upper)s");
+int add(int, int);
+int sub(int, int);
+int mul(int, int);
+%nocallback;
+
+extern int (*funcvar)(int,int);
+
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr2/runme.as swig-3.0.0/Examples/as3/funcptr2/runme.as
--- swig-3.0.0.orig/Examples/as3/funcptr2/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr2/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,31 @@
+package SWIGExample {
+import avmplus.System;
+
+public function ASMain() {
+    var a = 37;
+    var b = 42;
+
+    // Now call our C function with a bunch of callbacks
+    Trace("Trying some C callback functions");
+    Trace("    a        = " + a);
+    Trace("    b        = " + b);
+    Trace("    ADD(a,b) = " + ExampleModule.do_op(a, b, ExampleModule.ADD));
+    Trace("    SUB(a,b) = " + ExampleModule.do_op(a, b, ExampleModule.SUB));
+    Trace("    MUL(a,b) = " + ExampleModule.do_op(a, b, ExampleModule.MUL));
+
+    Trace("Here is what the C callback function objects look like in AS");
+    Trace("    ADD      = " + ExampleModule.ADD);
+    Trace("    SUB      = " + ExampleModule.SUB);
+    Trace("    MUL      = " + ExampleModule.MUL);
+
+    Trace("Call the wrappers directly...");
+    Trace("    add(a,b) = " + ExampleModule.add(a, b));
+    Trace("    sub(a,b) = " + ExampleModule.sub(a, b));
+
+    Trace("Call the Function objects directly...");
+    Trace("    add(a,b) = " + ExampleModule.ADD(a, b));
+    Trace("    sub(a,b) = " + ExampleModule.SUB(a, b));
+
+    return 0;
+}
+}
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr3/Makefile swig-3.0.0/Examples/as3/funcptr3/Makefile
--- swig-3.0.0.orig/Examples/as3/funcptr3/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr3/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr3/example.as swig-3.0.0/Examples/as3/funcptr3/example.as
--- swig-3.0.0.orig/Examples/as3/funcptr3/example.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr3/example.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,97 @@
+
+/* Function pointers support */
+package SWIGExample {
+import flash.utils.Dictionary;
+import com.adobe.flascc.CModule;
+
+var _SWIG_AS3Func2Ptr:Dictionary = new Dictionary();
+var _SWIG_AS3Ptr2Func:Dictionary = new Dictionary();
+
+function SWIG_AS3RegASCallWrapper(ptr:int, wrapper:Function):void {
+    if (_SWIG_AS3Ptr2Func[ptr]) {
+        throw("tried to register AS-callable wrapper for existing AS wrapper");
+    }
+    _SWIG_AS3Func2Ptr[wrapper] = ptr;
+    _SWIG_AS3Ptr2Func[ptr] = wrapper;
+}
+
+// Returns Function objects callable from AS
+function SWIG_AS3GetASCallWrapper(ptr:int):Function {
+    if (_SWIG_AS3Ptr2Func[ptr]) {
+        return _SWIG_AS3Ptr2Func[ptr];
+    } else {
+        return null;
+    }
+}
+
+function SWIG_AS3RegCCallWrapper(func:Function, wrapper:Function):void {
+    var ptr:int;
+    
+    if (_SWIG_AS3Func2Ptr[func]) {
+        throw("tried to register C-callable wrapper for native C function");
+    }
+
+    ptr = CModule.allocFunPtrs(1, 4);
+    CModule.regFun(ptr, wrapper);
+    _SWIG_AS3Func2Ptr[func] = ptr;
+    _SWIG_AS3Ptr2Func[ptr] = func;
+
+}
+
+// Returns a C function pointer corresponding to an Actionscript-callable 
+// wrapper Function. (The C function is callable from C, of course).
+function SWIG_AS3GetCCallPtr(func:Function):int {
+    if (_SWIG_AS3Func2Ptr[func]) {
+        return _SWIG_AS3Func2Ptr[func];
+    } else {
+        return 0;
+    }
+}
+} /* package */
+
+
+
+package {
+import SWIGExample.*;
+import flash.utils.ByteArray;
+
+
+public class example {
+	public static function do_op(a:int, b:int, op:Function):int {
+		return _wrap_do_op(a, b, op);
+	}
+
+	public static function get add():Function{
+		return _wrap_add();
+	}
+
+	public static function add(arg1:int, arg2:int):int {
+		return _wrap_add(arg1, arg2);
+	}
+
+	public static function get sub():Function{
+		return _wrap_sub();
+	}
+
+	public static function sub(arg1:int, arg2:int):int {
+		return _wrap_sub(arg1, arg2);
+	}
+
+	public static function get mul():Function{
+		return _wrap_mul();
+	}
+
+	public static function mul(arg1:int, arg2:int):int {
+		return _wrap_mul(arg1, arg2);
+	}
+
+	public static function set funcvar(funcvar:Function):void {
+		_wrap_funcvar_set(funcvar);
+	}
+
+	public static function get funcvar():Function {
+		return _wrap_funcvar_get();
+	}
+
+}
+} /* package */
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr3/example.c swig-3.0.0/Examples/as3/funcptr3/example.c
--- swig-3.0.0.orig/Examples/as3/funcptr3/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr3/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,7 @@
+/* File : example.c */
+#include "example.h"
+
+snes_audio_chunk_t foo;
+
+void set_blah(blah x) {}
+void snes_set_audio_chunk( void (*chunk)(int *a, int b)) {}
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr3/example.h swig-3.0.0/Examples/as3/funcptr3/example.h
--- swig-3.0.0.orig/Examples/as3/funcptr3/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr3/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,11 @@
+/* file: example.h */
+
+//typedef void (*snes_audio_chunk_t)(int16_t *chunk, int32_t size);
+typedef void (*snes_audio_chunk_t)(int *chunk, int size);
+typedef int (*blah)();
+
+extern snes_audio_chunk_t foo;
+
+//void snes_set_audio_chunk(snes_audio_chunk_t);
+void set_blah(blah);
+void snes_set_audio_chunk( void (*chunk)(int *a, int b));
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr3/example.i swig-3.0.0/Examples/as3/funcptr3/example.i
--- swig-3.0.0.orig/Examples/as3/funcptr3/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr3/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,8 @@
+/* File : example.i */
+%module ExampleModule
+%{
+#include "example.h"
+%}
+
+%include "example.h"
+
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr3/runme.as swig-3.0.0/Examples/as3/funcptr3/runme.as
--- swig-3.0.0.orig/Examples/as3/funcptr3/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr3/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,8 @@
+package SWIGExample {
+import avmplus.System;
+
+public function ASMain() {
+    // This test just compiles the wrappers, without a runtime component.
+    return 0;
+}
+}
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr3/runme.py swig-3.0.0/Examples/as3/funcptr3/runme.py
--- swig-3.0.0.orig/Examples/as3/funcptr3/runme.py	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr3/runme.py	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,24 @@
+# file: runme.py
+
+import example 
+
+a = 37
+b = 42
+
+# Now call our C function with a bunch of callbacks
+
+print "Trying some C callback functions"
+print "    a        =", a
+print "    b        =", b
+print "    ADD(a,b) =", example.do_op(a,b,example.ADD)
+print "    SUB(a,b) =", example.do_op(a,b,example.SUB)
+print "    MUL(a,b) =", example.do_op(a,b,example.MUL)
+
+print "Here is what the C callback function objects look like in Python"
+print "    ADD      =", example.ADD
+print "    SUB      =", example.SUB
+print "    MUL      =", example.MUL
+
+print "Call the functions directly..."
+print "    add(a,b) =", example.add(a,b)
+print "    sub(a,b) =", example.sub(a,b)
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr4/Makefile swig-3.0.0/Examples/as3/funcptr4/Makefile
--- swig-3.0.0.orig/Examples/as3/funcptr4/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr4/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+CXXSRCS    = example.cxx
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile CXXSRCS='$(CXXSRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3_cpp
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr4/example.as swig-3.0.0/Examples/as3/funcptr4/example.as
--- swig-3.0.0.orig/Examples/as3/funcptr4/example.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr4/example.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,97 @@
+
+/* Function pointers support */
+package SWIGExample {
+import flash.utils.Dictionary;
+import com.adobe.flascc.CModule;
+
+var _SWIG_AS3Func2Ptr:Dictionary = new Dictionary();
+var _SWIG_AS3Ptr2Func:Dictionary = new Dictionary();
+
+function SWIG_AS3RegASCallWrapper(ptr:int, wrapper:Function):void {
+    if (_SWIG_AS3Ptr2Func[ptr]) {
+        throw("tried to register AS-callable wrapper for existing AS wrapper");
+    }
+    _SWIG_AS3Func2Ptr[wrapper] = ptr;
+    _SWIG_AS3Ptr2Func[ptr] = wrapper;
+}
+
+// Returns Function objects callable from AS
+function SWIG_AS3GetASCallWrapper(ptr:int):Function {
+    if (_SWIG_AS3Ptr2Func[ptr]) {
+        return _SWIG_AS3Ptr2Func[ptr];
+    } else {
+        return null;
+    }
+}
+
+function SWIG_AS3RegCCallWrapper(func:Function, wrapper:Function):void {
+    var ptr:int;
+    
+    if (_SWIG_AS3Func2Ptr[func]) {
+        throw("tried to register C-callable wrapper for native C function");
+    }
+
+    ptr = CModule.allocFunPtrs(1, 4);
+    CModule.regFun(ptr, wrapper);
+    _SWIG_AS3Func2Ptr[func] = ptr;
+    _SWIG_AS3Ptr2Func[ptr] = func;
+
+}
+
+// Returns a C function pointer corresponding to an Actionscript-callable 
+// wrapper Function. (The C function is callable from C, of course).
+function SWIG_AS3GetCCallPtr(func:Function):int {
+    if (_SWIG_AS3Func2Ptr[func]) {
+        return _SWIG_AS3Func2Ptr[func];
+    } else {
+        return 0;
+    }
+}
+} /* package */
+
+
+
+package {
+import SWIGExample.*;
+import flash.utils.ByteArray;
+
+
+public class example {
+	public static function do_op(a:int, b:int, op:Function):int {
+		return _wrap_do_op(a, b, op);
+	}
+
+	public static function get add():Function{
+		return _wrap_add();
+	}
+
+	public static function add(arg1:int, arg2:int):int {
+		return _wrap_add(arg1, arg2);
+	}
+
+	public static function get sub():Function{
+		return _wrap_sub();
+	}
+
+	public static function sub(arg1:int, arg2:int):int {
+		return _wrap_sub(arg1, arg2);
+	}
+
+	public static function get mul():Function{
+		return _wrap_mul();
+	}
+
+	public static function mul(arg1:int, arg2:int):int {
+		return _wrap_mul(arg1, arg2);
+	}
+
+	public static function set funcvar(funcvar:Function):void {
+		_wrap_funcvar_set(funcvar);
+	}
+
+	public static function get funcvar():Function {
+		return _wrap_funcvar_get();
+	}
+
+}
+} /* package */
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr4/example.cxx swig-3.0.0/Examples/as3/funcptr4/example.cxx
--- swig-3.0.0.orig/Examples/as3/funcptr4/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr4/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,43 @@
+/* File : example.cxx */
+#include <stdio.h>
+#include <stdlib.h>
+#include "example.h"
+
+char *str;
+
+static const char *default_str_func() {
+    return "this string is from c";
+}
+
+static char *c_str_func(char *str, int size) {
+    printf("%s (size: %d)\n", str, size);
+    char *buf = (char *) malloc(size * 2 + 1);
+    sprintf(buf, "%s%s", str, str);
+    return buf;
+}
+
+static str_func default_getter() {
+    return c_str_func;
+}
+
+static str_func a_str_func;
+
+
+const char *(*char_func)() = default_str_func;
+str_func (*str_func_getter)() = default_getter;
+void (*str_func_setter)(str_func) = NULL;
+
+void call_getter() {
+    char *s = str_func_getter()("foo", 4);
+    printf("valued returned to c: %s\n", s);
+}
+
+void call_str_func() {
+    char *s = a_str_func("test string", 12);
+    printf("the stored str_func returned: %s\n", s);
+}
+
+void a_str_func_setter(str_func a) {
+    a_str_func = a;
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr4/example.h swig-3.0.0/Examples/as3/funcptr4/example.h
--- swig-3.0.0.orig/Examples/as3/funcptr4/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr4/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,15 @@
+/* file: example.h */
+
+typedef char *(*str_func)(char *str, int size);
+
+extern char *str;
+extern const char *(*char_func)();
+
+extern str_func (*str_func_getter)();
+
+extern void (*str_func_setter)(str_func);
+
+extern void call_getter();
+extern void call_str_func();
+extern void a_str_func_setter(str_func);
+
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr4/example.i swig-3.0.0/Examples/as3/funcptr4/example.i
--- swig-3.0.0.orig/Examples/as3/funcptr4/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr4/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,25 @@
+/* File : example.i */
+%module ExampleModule
+%{
+#include <stdio.h>
+#include "example.h"
+%}
+
+%typemap(in) (int, char *) {
+    AS3_MallocString($2, $input);
+    AS3_StringLength($1, $input);
+};
+
+%typemap(out) (int, char *) {
+    AS3_DeclareVar($input, String);
+    AS3_CopyCStringToVar($input, $2, $1);
+};
+
+%typemap(astype) (int , char *) "String";
+
+%typemap(freearg) (int , char *) {
+    printf("cleaning up\n");
+    free($2);
+};
+%include "example.h"
+
diff -rupN swig-3.0.0.orig/Examples/as3/funcptr4/runme.as swig-3.0.0/Examples/as3/funcptr4/runme.as
--- swig-3.0.0.orig/Examples/as3/funcptr4/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/funcptr4/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,44 @@
+package SWIGExample {
+import com.adobe.flascc.swig.*;
+import avmplus.System;
+
+function ASStrFunc():String {
+    return "here's a String";
+}
+
+function ASOtherStrFunc(a:String, b:int):String {
+    Trace("string: " + a);
+    Trace("int: " + b);
+    return "string from AS";
+}
+
+public function ASMain() {
+    Trace("here's what the default function returns: " + 
+        ExampleModule.char_func());
+    ExampleModule.char_func = ASStrFunc;
+    Trace("here's what the function pointer returns: " + 
+        ExampleModule.char_func());
+    
+    var strfunc:Function = ExampleModule.str_func_getter();
+    Trace("AS got: " + strfunc("test", 5));
+    ExampleModule.str_func_getter = function() { return ASOtherStrFunc };
+    var strfunc1:Function = ExampleModule.str_func_getter();
+    Trace("AS got: " + strfunc1("test", 5));
+    ExampleModule.call_getter();
+
+    ExampleModule.str_func_setter = ExampleModule.a_str_func_setter;
+    ExampleModule.str_func_setter(ASOtherStrFunc);
+    ExampleModule.call_str_func();
+
+    var numptrs:uint = SWIG_AS3WrapperNum();
+    SWIG_AS3UnregCCallWrapper(ASStrFunc);
+    SWIG_AS3UnregCCallWrapper(ASOtherStrFunc);
+    SWIG_AS3UnregASCallWrapper(strfunc);
+    var newnumptrs:uint = SWIG_AS3WrapperNum();
+    if (newnumptrs + 3 != numptrs) {
+        Trace("unexpected number of function pointers: " + numptrs);
+    }
+
+    return 0;
+}
+}
diff -rupN swig-3.0.0.orig/Examples/as3/interop/example.cxx swig-3.0.0/Examples/as3/interop/example.cxx
--- swig-3.0.0.orig/Examples/as3/interop/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/interop/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,3 @@
+/* File : example.cxx */
+
+#include "example.h"
\ No newline at end of file
diff -rupN swig-3.0.0.orig/Examples/as3/interop/example.h swig-3.0.0/Examples/as3/interop/example.h
--- swig-3.0.0.orig/Examples/as3/interop/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/interop/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,12 @@
+/* File : example.h */
+
+#include <cstdio>
+#include <iostream>
+
+class BaseClass
+{
+public:
+	BaseClass()/*{}*/;
+
+	virtual ~BaseClass() {}
+};
diff -rupN swig-3.0.0.orig/Examples/as3/interop/example.i swig-3.0.0/Examples/as3/interop/example.i
--- swig-3.0.0.orig/Examples/as3/interop/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/interop/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,119 @@
+/* File : example.i */
+%module example
+
+%{
+    #include "example.h"
+    #include <AS3/AS3++.h>
+    #include <Flash++.h>
+%}
+
+%include "example.h"
+
+%{
+    BaseClass::BaseClass() {}
+%}
+
+// with inline we both declare class and wrapper at once
+%inline %{ 
+
+class SpecialClass : public BaseClass {
+public:
+	SpecialClass() {
+        AS3_Trace("SpecialClass::Created");
+        AS3::local::var s = AS3::local::internal::new_String("SpecialClass loaded.");
+        AS3::local::internal::trace(s);
+    }
+	~SpecialClass() {AS3_Trace("SpecialClass::Destroyed");}
+    
+};
+
+%}
+
+%{ 
+ 
+////
+//
+// Get a property of an ActionScript object in C++
+//
+////
+ 
+void getDelta() __attribute__((used,
+    annotate("as3import:flash.events.MouseEvent"),
+    annotate("as3sig:public function getDelta(m:MouseEvent):int"),
+    annotate("as3package:utils")));
+ 
+void getDelta()
+{
+    // marshall the AS3 parameter into a C++ variable
+    AS3::local::var mouseEvent;
+    AS3_GetVarxxFromVar(mouseEvent, m);
+ 
+    // now that we have it in C++ let's get a property on that object
+    AS3::local::var propertyName = AS3::local::internal::new_String("delta");
+    AS3::local::var outputValue = AS3::local::internal::getproperty(mouseEvent, propertyName);
+ 
+    // convert the var to a scalar
+    int output = AS3::local::internal::int_valueOf(outputValue);
+ 
+    // return that scalar value
+    AS3_Return(output);
+}
+ 
+ 
+////
+//
+// Set a property on an ActionScript object in C++
+//
+////
+ 
+void setDelta() __attribute__((used,
+    annotate("as3import:flash.events.MouseEvent"),
+    annotate("as3sig:public function setDelta(m:MouseEvent):void"),
+    annotate("as3package:utils")));
+ 
+void setDelta()
+{
+    // marshall the AS3 parameter into a C++ variable
+    AS3::local::var mouseEvent;
+    AS3_GetVarxxFromVar(mouseEvent, m);
+ 
+    // now that we have it in C++ let's set a property on that object
+    AS3::local::var propertyName = AS3::local::internal::new_String("delta");
+    AS3::local::var newValue = AS3::local::internal::new_int(5);
+    AS3::local::internal::setproperty(mouseEvent, propertyName, newValue);
+}
+ 
+ 
+////
+//
+// Call a method of an ActionScript object in C++
+//
+////
+ 
+void getString() __attribute__((used,
+    annotate("as3import:flash.events.MouseEvent"),
+    annotate("as3sig:public function getString(m:MouseEvent):String"),
+    annotate("as3package:utils")));
+ 
+void getString()
+{
+    // marshall the AS3 parameter into a C++ variable
+    AS3::local::var mouseEvent;
+    AS3_GetVarxxFromVar(mouseEvent, m);
+ 
+    // demonstrate how to call a function of that object from C++
+    AS3::local::var functionName = AS3::local::internal::new_String("toString");
+    // first get the property of the object called "toString" which is a Function var
+    AS3::local::var function = AS3::local::internal::getproperty(mouseEvent, functionName);
+ 
+    // then call that Function object (in this case it takes no parameters)
+    AS3::local::var output = AS3::local::internal::call(function, AS3::local::internal::_null, 0, NULL);
+ 
+    // Since AS3_Return (as shown in getDelta()) can only accept a scalar value we need
+    // to marshall this C++ object into an ActionScript String and return it using AS3_ReturnVar
+    AS3_DeclareVar(asOutputString, String);
+    AS3_CopyVarxxToVar(asOutputString, output);
+    AS3_ReturnAS3Var(asOutputString);
+}
+
+%}
\ No newline at end of file
diff -rupN swig-3.0.0.orig/Examples/as3/main.c swig-3.0.0/Examples/as3/main.c
--- swig-3.0.0.orig/Examples/as3/main.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/main.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,25 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <AS3/AS3.h>
+
+
+int main (int argc, char **argv) {
+    setlinebuf(stdout);
+    inline_as3(
+      "import SWIGExample.*;\n"
+      "ASMain();\n"
+    );
+    return 0;
+}
+
+__attribute__((annotate("as3sig:public function Trace(s:String):void"),
+    annotate("as3package:SWIGExample")))
+void Trace() {
+    inline_as3("import com.adobe.flascc.CModule;\n");
+    inline_as3("s = s + '\\n';\n");
+    inline_as3("var ptr = CModule.alloca(s.length);\n");
+    inline_as3("CModule.writeString(ptr, s);\n");
+    inline_as3("var fake_errno_ptr = CModule.alloca(4);\n");
+    inline_as3("CModule.kernel.write(1, ptr, s.length, fake_errno_ptr);"); 
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/multi/Makefile swig-3.0.0/Examples/as3/multi/Makefile
--- swig-3.0.0.orig/Examples/as3/multi/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/multi/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/multi/example.c swig-3.0.0/Examples/as3/multi/example.c
--- swig-3.0.0.orig/Examples/as3/multi/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/multi/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,9 @@
+/* File : example.c */
+#include <stdio.h>
+
+void print_str(int len, char *str) {
+  char buf[len + 1];
+  snprintf(buf, len + 1, "%s", str);
+  printf("%s\n", buf);
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/multi/example.i swig-3.0.0/Examples/as3/multi/example.i
--- swig-3.0.0.orig/Examples/as3/multi/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/multi/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,18 @@
+/* File : example.i */
+%module ExampleModule
+
+%typemap(in) (int len, char *str) {
+    AS3_MallocString($2, $input);
+    AS3_StringLength($1, $input);
+};
+
+%typemap(astype) (int len, char *str) "String";
+
+%typemap(freearg) (int len, char *str) {
+    printf("cleaning up\n");
+    free($2);
+};
+
+%inline %{
+extern void print_str(int len, char *str);
+%}
diff -rupN swig-3.0.0.orig/Examples/as3/multi/runme.as swig-3.0.0/Examples/as3/multi/runme.as
--- swig-3.0.0.orig/Examples/as3/multi/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/multi/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,9 @@
+package SWIGExample {
+    import avmplus.System;
+    public function ASMain() {
+        ExampleModule.print_str("hello from multi argument typemap");
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/nspace/Makefile swig-3.0.0/Examples/as3/nspace/Makefile
--- swig-3.0.0.orig/Examples/as3/nspace/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/nspace/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,20 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+CXXSRCS    = example.cxx
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+LIBS	   = -lm
+
+all::
+	$(MAKE) -f $(TOP)/Makefile CXXSRCS='$(CXXSRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3_cpp
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+
+check: all
+	./$(TARGET)
+
diff -rupN swig-3.0.0.orig/Examples/as3/nspace/example.cxx swig-3.0.0/Examples/as3/nspace/example.cxx
--- swig-3.0.0.orig/Examples/as3/nspace/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/nspace/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,30 @@
+/* File : example.c */
+
+#include "example.h"
+#define M_PI 3.14159265358979323846
+
+using namespace test;
+
+/* Move the shape to a new location */
+void Shape::move(double dx, double dy) {
+  x += dx;
+  y += dy;
+}
+
+int Shape::nshapes = 0;
+
+double Circle::area(void) {
+  return M_PI*radius*radius;
+}
+
+double Circle::perimeter(void) {
+  return 2*M_PI*radius;
+}
+
+double Square::area(void) {
+  return width*width;
+}
+
+double Square::perimeter(void) {
+  return 4*width;
+}
diff -rupN swig-3.0.0.orig/Examples/as3/nspace/example.h swig-3.0.0/Examples/as3/nspace/example.h
--- swig-3.0.0.orig/Examples/as3/nspace/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/nspace/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,39 @@
+/* File : example.h */
+
+namespace test {
+
+class Shape {
+public:
+  Shape() {
+    nshapes++;
+  }
+  virtual ~Shape() {
+    nshapes--;
+  };
+  double  x, y;   
+  void    move(double dx, double dy);
+  virtual double area(void) = 0;
+  virtual double perimeter(void) = 0;
+  static  int nshapes;
+};
+
+class Circle : public Shape {
+private:
+  double radius;
+public:
+  Circle(double r) : radius(r) { };
+  virtual double area(void);
+  virtual double perimeter(void);
+};
+
+class Square : public Shape {
+private:
+  double width;
+public:
+  Square(double w) : width(w) { };
+  virtual double area(void);
+  virtual double perimeter(void);
+};
+
+} // namespace
+
diff -rupN swig-3.0.0.orig/Examples/as3/nspace/example.i swig-3.0.0/Examples/as3/nspace/example.i
--- swig-3.0.0.orig/Examples/as3/nspace/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/nspace/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,18 @@
+/* File : example.i */
+#ifdef SWIG
+%module ExampleModule
+
+%{
+#include "example.h"
+%}
+
+/* Let's just grab the original header file here */
+%include "example.h"
+
+#else
+/* This is what clang sees */
+#include "example.h"
+
+#endif
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/nspace/runme.as swig-3.0.0/Examples/as3/nspace/runme.as
--- swig-3.0.0.orig/Examples/as3/nspace/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/nspace/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,46 @@
+package SWIGExample {
+    import avmplus.System;
+
+    public function ASMain() {
+        // Object creation
+        Trace("Creating some objects:");
+        var c= Circle.create(10);
+        Trace("Created circle " + c);
+        var s= Square.create(10);
+        Trace("Created square " + s);
+
+        // Access a static member
+        Trace("\nA total of " + + Shape.nshapes + " shapes were created");
+        
+        // Member data access
+
+        // Set the location of the object
+        c.x = 20;
+        c.y = 30;
+        s.y = -10;
+        s.y = 5;
+
+        Trace("\nHere is their current position:");
+        Trace("    Circle = (" + c.x + ", " + c.y + ")");
+        Trace("    Square = (" + s.x + ", " + s.y + ")");
+
+        // Call some methods
+        Trace("\nHere are some properties of the shapes:");
+        for each (var o in [c, s]) {
+            Trace("    " + o);
+            Trace("        area      = " + o.area());
+            Trace("        perimeter = " + o.perimeter());
+        }
+        
+        Trace("\nGuess I'll clean up now");
+        
+        // Note: this invokes the virtual destructor
+        c.destroy();
+        s.destroy();
+
+        Trace(Shape.nshapes + " shapes remain");
+        Trace("Goodbye");
+
+        return 0;
+    }
+}
diff -rupN swig-3.0.0.orig/Examples/as3/outptr/Makefile swig-3.0.0/Examples/as3/outptr/Makefile
--- swig-3.0.0.orig/Examples/as3/outptr/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/outptr/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/outptr/example.c swig-3.0.0/Examples/as3/outptr/example.c
--- swig-3.0.0.orig/Examples/as3/outptr/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/outptr/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,20 @@
+#include "example.h"
+
+void reverseArray(int* in, int* out, int length){
+	int i = 0;
+    
+	while (i < length){
+		out[i] = in[length - i - 1];
+		i++;
+	}
+}
+
+void incrementArray(int* in, int* out, int length)
+{
+	int i = 0;
+    
+	while (i < length){
+		out[i] = in[i] + 1;
+		i++;
+	}
+}
diff -rupN swig-3.0.0.orig/Examples/as3/outptr/example.h swig-3.0.0/Examples/as3/outptr/example.h
--- swig-3.0.0.orig/Examples/as3/outptr/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/outptr/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,6 @@
+/*
+ * A sample C library for working with integer arrays
+ */
+
+void reverseArray(int* in, int* out, int length);
+void incrementArray(int* in, int* out, int length);
diff -rupN swig-3.0.0.orig/Examples/as3/outptr/example.i swig-3.0.0/Examples/as3/outptr/example.i
--- swig-3.0.0.orig/Examples/as3/outptr/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/outptr/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,85 @@
+/*
+ * Sometimes C libraries have methods that don't return values, but instead 
+ * stuff the value into one of the parameters.
+ *
+ * This example demonstrates how you can use SWIG to make this interface much
+ * simpler to your ActionScript consumers by making void methods actually 
+ * return the output as an ActionScript object.
+ *
+ * See the Typemaps example in the SWIG tutorial for more in depth explanation
+ * of some of these typemaps.
+ *
+ */
+
+#ifdef SWIG
+%module ExampleModule
+
+%{
+#include "example.h"
+%}
+
+// change functions that follow the in/out pointer style to accept an ActionScript Vector
+%typemap(astype) (int* in, int* out, int length) "Vector.<int>";
+
+// change functions that return void to return an ActionScript Vector of ints
+%typemap(astype) (void) "Vector.<int>";
+
+%typemap(in) (int* in, int* out, int length)(int* generatedLocalOut, int generatedLocalLength) {
+	// setup some new C variables that we're going to modify from within our inline ActionScript
+	int* newBuffer;
+	int newBufferSize;
+	
+	inline_as3("var ptr:int = CModule.malloc($input.length);\n");
+	inline_as3("%0 = $input.length;\n": "=r"(newBufferSize));
+	inline_as3("%0 = ptr;\n": "=r"(newBuffer));
+    
+	// push the values of the input Vector into C memory
+	int i;
+	for (i = 0; i < newBufferSize; i++){
+		int number;
+		inline_as3("%0 = $input[%1];\n": "=r"(number) : "r"(i));
+		*(newBuffer + i) = number;
+	}
+	
+	// assign the parameters that the C function is expecting to our new values
+	$1 = newBuffer;
+	$2 = malloc(4 * newBufferSize);
+	$3 = newBufferSize;
+    
+	// save some local values for use in %typemap(argout)
+	generatedLocalLength = newBufferSize;
+	generatedLocalOut = $2;
+}
+
+%typemap(argout) (int* in, int* out, int length) {
+    
+    // get the output from the C world that we saved in %typemap(in)
+    int* resultPtr = generatedLocalOut$argnum;
+    int resultLength = generatedLocalLength$argnum;
+    
+    // create the ActionScript variable that will get returned
+    inline_as3("var $result:Vector.<int> = new Vector.<int>();\n");
+    
+    // write the C output into the ActionScript $result variable
+    int i;
+    for (i = 0; i < resultLength; i++){ 
+        int number = *(resultPtr + i);
+        inline_as3("$result.push(%0);\n" : : "r"(number));
+    }
+}
+
+%typemap(freearg) (int* in, int* out, int length) {
+	free($2);
+    inline_as3("CModule.free(ptr)");
+};
+
+%typemap(asreturn) void {
+	// make the void function actually return something
+	AS3_ReturnAS3Var(asresult);
+}
+
+%include "example.h"
+
+#else
+#include "example.h"
+#endif
diff -rupN swig-3.0.0.orig/Examples/as3/outptr/runme.as swig-3.0.0/Examples/as3/outptr/runme.as
--- swig-3.0.0.orig/Examples/as3/outptr/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/outptr/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,23 @@
+package SWIGExample {
+    import avmplus.System;
+    public function ASMain() {
+		
+		var v:Vector.<int> = new Vector.<int>();
+		v.push(1);
+		v.push(2);
+		v.push(3);
+		v.push(4);
+		v.push(5);
+		
+		// pass an ActionScript object in and get an ActionScript object returned
+		var reverse:Vector.<int> = ExampleModule.reverseArray(v); 
+		Trace("Reversed: " + reverse + " == 5,4,3,2,1");
+		
+		var increment:Vector.<int> = ExampleModule.incrementArray(v); 
+		Trace("Incremented: " + increment + " == 2,3,4,5,6");
+   
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/overloadop/Makefile swig-3.0.0/Examples/as3/overloadop/Makefile
--- swig-3.0.0.orig/Examples/as3/overloadop/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/overloadop/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,20 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+CXXSRCS    = example.cxx
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+LIBS	   = -lm
+
+all::
+	$(MAKE) -f $(TOP)/Makefile CXXSRCS='$(CXXSRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3_cpp
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+
+check: all
+	./$(TARGET)
+
diff -rupN swig-3.0.0.orig/Examples/as3/overloadop/example.cxx swig-3.0.0/Examples/as3/overloadop/example.cxx
--- swig-3.0.0.orig/Examples/as3/overloadop/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/overloadop/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,37 @@
+/* File : example.c */
+
+#include "example.h"
+#define M_PI 3.14159265358979323846
+
+/* Move the shape to a new location */
+void Shape::move(double dx, double dy) {
+  x += dx;
+  y += dy;
+}
+
+int Shape::nshapes = 0;
+
+double Circle::area(void) {
+  return M_PI*radius*radius;
+}
+
+double Circle::perimeter(void) {
+  return 2*M_PI*radius;
+}
+
+double Circle::operator/(double x) const {
+  return radius / x;
+}
+
+double Square::area(void) {
+  return width*width;
+}
+
+double Square::perimeter(void) {
+  return 4*width;
+}
+
+double Square::operator/(double x) const {
+  return width / x;
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/overloadop/example.h swig-3.0.0/Examples/as3/overloadop/example.h
--- swig-3.0.0.orig/Examples/as3/overloadop/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/overloadop/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,42 @@
+/* File : example.h */
+
+class Shape {
+public:
+  Shape() {
+    nshapes++;
+  }
+  virtual ~Shape() {
+    nshapes--;
+  };
+  double  x, y;   
+  void    move(double dx, double dy);
+  virtual double area(void) = 0;
+  virtual double perimeter(void) = 0;
+  virtual double operator/(double x) const = 0;
+  static  int nshapes;
+};
+
+class Circle : public Shape {
+private:
+  double radius;
+public:
+  Circle(double r) : radius(r) { };
+  virtual double area(void);
+  virtual double perimeter(void);
+  virtual double operator/(double x) const;
+};
+
+class Square : public Shape {
+private:
+  double width;
+public:
+  Square(double w) : width(w) { };
+  virtual double area(void);
+  virtual double perimeter(void);
+  virtual double operator/(double x) const;
+};
+
+
+
+
+  
diff -rupN swig-3.0.0.orig/Examples/as3/overloadop/example.i swig-3.0.0/Examples/as3/overloadop/example.i
--- swig-3.0.0.orig/Examples/as3/overloadop/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/overloadop/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+/* File : example.i */
+#ifdef SWIG
+%module ExampleModule
+
+%rename(divop) Shape::operator/;
+%{
+#include "example.h"
+%}
+
+/* Let's just grab the original header file here */
+%include "example.h"
+
+#else
+/* This is what clang sees */
+#include "example.h"
+
+#endif
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/overloadop/runme.as swig-3.0.0/Examples/as3/overloadop/runme.as
--- swig-3.0.0.orig/Examples/as3/overloadop/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/overloadop/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,23 @@
+package SWIGExample {
+
+    import avmplus.System;
+
+    public function ASMain() {
+        // Object creation
+        Trace("Creating some objects:");
+        var c= Circle.create(10);
+        Trace("Created circle " + c);
+        var s= Square.create(10);
+        Trace("Created square " + s);
+
+
+        Trace("circle radius / 2: " + c.divop(2));
+        Trace("square width / 3 : " + s.divop(3));
+        
+        // Note: this invokes the virtual destructor
+        c.destroy();
+        s.destroy();
+
+        return 0;
+    }
+}
diff -rupN swig-3.0.0.orig/Examples/as3/package/Makefile swig-3.0.0/Examples/as3/package/Makefile
--- swig-3.0.0.orig/Examples/as3/package/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/package/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,18 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' SWIGOPT='-package foo.bar' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/package/example.c swig-3.0.0/Examples/as3/package/example.c
--- swig-3.0.0.orig/Examples/as3/package/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/package/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,18 @@
+/* File : example.c */
+
+/* A global variable */
+double Foo = 3.0;
+
+/* Compute the greatest common divisor of positive integers */
+int gcd(int x, int y) {
+  int g;
+  g = y;
+  while (x > 0) {
+    g = x;
+    x = y % x;
+    y = g;
+  }
+  return g;
+}
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/package/example.i swig-3.0.0/Examples/as3/package/example.i
--- swig-3.0.0.orig/Examples/as3/package/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/package/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,7 @@
+/* File : example.i */
+%module ExampleModule
+
+%inline %{
+extern int    gcd(int x, int y);
+extern double Foo;
+%}
diff -rupN swig-3.0.0.orig/Examples/as3/package/runme.as swig-3.0.0/Examples/as3/package/runme.as
--- swig-3.0.0.orig/Examples/as3/package/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/package/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,17 @@
+package SWIGExample {
+    import avmplus.System;
+    import foo.bar.ExampleModule;
+    public function ASMain() {
+        var x = 42, y = 105;
+        var g = ExampleModule.gcd(x, y);
+        Trace('The gcd of ' + x + ' and ' + y + ' is ' + g);
+        
+        Trace('Foo = ' + ExampleModule.Foo);
+        ExampleModule.Foo = 3.1415926;
+        Trace('Foo = ' + ExampleModule.Foo);
+    
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/pointer/example.c swig-3.0.0/Examples/as3/pointer/example.c
--- swig-3.0.0.orig/Examples/as3/pointer/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/pointer/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,16 @@
+/* File : example.c */
+
+void add(int *x, int *y, int *result) {
+  *result = *x + *y;
+}
+
+void sub(int *x, int *y, int *result) {
+  *result = *x - *y;
+}
+
+int divide(int n, int d, int *r) {
+   int q;
+   q = n/d;
+   *r = n - q*d;
+   return q;
+}
diff -rupN swig-3.0.0.orig/Examples/as3/pointer/example.i swig-3.0.0/Examples/as3/pointer/example.i
--- swig-3.0.0.orig/Examples/as3/pointer/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/pointer/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,30 @@
+/* File : example.i */
+%module example
+
+%{
+extern void add(int *, int *, int *);
+extern void sub(int *, int *, int *);
+extern int divide(int, int, int *);
+%}
+
+/* This example illustrates a couple of different techniques
+   for manipulating C pointers */
+
+/* First we'll use the pointer library */
+extern void add(int *x, int *y, int *result);
+%include cpointer.i
+%pointer_functions(int, intp);
+
+/* Next we'll use some typemaps */
+
+%include typemaps.i
+extern void sub(int *INPUT, int *INPUT, int *OUTPUT);
+
+/* Next we'll use typemaps and the %apply directive */
+
+%apply int *OUTPUT { int *r };
+extern int divide(int n, int d, int *r);
+
+
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/reference/Makefile swig-3.0.0/Examples/as3/reference/Makefile
--- swig-3.0.0.orig/Examples/as3/reference/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/reference/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,20 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+CXXSRCS    = example.cxx
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+LIBS	   = -lm
+
+all::
+	$(MAKE) -f $(TOP)/Makefile CXXSRCS='$(CXXSRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3_cpp
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+
+check: all
+	./$(TARGET)
+
diff -rupN swig-3.0.0.orig/Examples/as3/reference/example.cxx swig-3.0.0/Examples/as3/reference/example.cxx
--- swig-3.0.0.orig/Examples/as3/reference/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/reference/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,46 @@
+/* File : example.cxx */
+
+/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
+#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
+# define _CRT_SECURE_NO_DEPRECATE
+#endif
+
+#include "example.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+CVector operator+(const CVector &a, const CVector &b) {
+  CVector r;
+  r.x = a.x + b.x;
+  r.y = a.y + b.y;
+  r.z = a.z + b.z;
+  return r;
+}
+
+char *CVector::print() {
+  static char temp[512];
+  sprintf(temp,"CVector %p (%g,%g,%g)", this, x,y,z);
+  return temp;
+}
+
+VectorArray::VectorArray(int size) {
+  items = new CVector[size];
+  maxsize = size;
+}
+
+VectorArray::~VectorArray() {
+  delete [] items;
+}
+
+CVector &VectorArray::operator[](int index) {
+  if ((index < 0) || (index >= maxsize)) {
+    printf("Panic! Array index out of bounds.\n");
+    exit(1);
+  }
+  return items[index];
+}
+
+int VectorArray::size() {
+  return maxsize;
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/reference/example.h swig-3.0.0/Examples/as3/reference/example.h
--- swig-3.0.0.orig/Examples/as3/reference/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/reference/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,26 @@
+/* File : example.h */
+
+class CVector {
+private:
+  double x,y,z;
+public:
+  CVector() : x(0), y(0), z(0) { };
+  CVector(double x, double y, double z) : x(x), y(y), z(z) { };
+  friend CVector operator+(const CVector &a, const CVector &b);
+  char *print();
+};
+
+class VectorArray {
+private:
+  CVector *items;
+  int     maxsize;
+public:
+  VectorArray(int maxsize);
+  ~VectorArray();
+  CVector &operator[](int);
+  int size();
+};
+
+
+
+  
diff -rupN swig-3.0.0.orig/Examples/as3/reference/example.i swig-3.0.0/Examples/as3/reference/example.i
--- swig-3.0.0.orig/Examples/as3/reference/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/reference/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,48 @@
+/* File : example.i */
+
+/* This file has a few "typical" uses of C++ references. */
+
+%module ExampleModule
+
+%{
+#include "example.h"
+%}
+
+%rename(cprint) print;
+
+class CVector {
+public:
+    CVector(double x, double y, double z);
+   ~CVector();
+    char *print();
+};
+
+/* This helper function calls an overloaded operator */
+%inline %{
+CVector addv(CVector &a, CVector &b) {
+  return a+b;
+}
+%}
+
+/* Wrapper around an array of vectors class */
+
+class VectorArray {
+public:
+  VectorArray(int maxsize);
+  ~VectorArray();
+  int size();
+  
+  /* This wrapper provides an alternative to the [] operator */
+  %extend {
+    CVector &get(int index) {
+      return (*$self)[index];
+    }
+    void set(int index, CVector &a) {
+      (*$self)[index] = a;
+    }
+  }
+};
+
+
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/reference/runme.as swig-3.0.0/Examples/as3/reference/runme.as
--- swig-3.0.0.orig/Examples/as3/reference/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/reference/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,21 @@
+package SWIGExample {
+    import avmplus.System;
+    public function ASMain() {
+        // Object creation
+        Trace("Creating some objects");
+        var a = CVector.create(3, 4, 5);
+        var b = CVector.create(10, 11, 12);
+
+        Trace("    Created " + a.cprint());
+        Trace("    Created " + b.cprint());
+        
+        // Call an overloaded operator
+
+        Trace("Adding a+b");
+        var c = ExampleModule.addv(a.swigCPtr, b.swigCPtr);
+        Trace("    a+b = " + c.cprint());
+
+        return 0;
+    }
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/reserved/Makefile swig-3.0.0/Examples/as3/reserved/Makefile
--- swig-3.0.0.orig/Examples/as3/reserved/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/reserved/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/reserved/example.c swig-3.0.0/Examples/as3/reserved/example.c
--- swig-3.0.0.orig/Examples/as3/reserved/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/reserved/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,204 @@
+#include <stdio.h>
+
+
+void endLine(){
+    printf("\n");
+}
+
+/////////
+
+
+int lexicalKeywords0(int as){
+    printf("%d ", as);
+    return as;
+}
+
+int lexicalKeywords1(int extends){
+    printf("%d ", extends);
+    return extends;
+}
+
+int lexicalKeywords2(int finally){
+    printf("%d ", finally);
+    return finally;
+}
+
+int lexicalKeywords3(int function){
+    printf("%d ", function);
+    return function;
+}
+
+int lexicalKeywords4(int implements){
+    printf("%d ", implements);
+    return implements;
+}
+
+int lexicalKeywords5(int import){
+    printf("%d ", import);
+    return import;
+}
+
+int lexicalKeywords6(int in){
+    printf("%d ", in);
+    return in;
+}
+
+int lexicalKeywords7(int instanceof){
+    printf("%d ", instanceof);
+    return instanceof;
+}
+
+int lexicalKeywords8(int interface){
+    printf("%d ", interface);
+    return interface;
+}
+
+int lexicalKeywords9(int internal){
+    printf("%d ", internal);
+    return internal;
+}
+
+int lexicalKeywords10(int is){
+    printf("%d ", is);
+    return is;
+}
+
+int lexicalKeywords11(int native){
+    printf("%d ", native);
+    return native;
+}
+
+int lexicalKeywords12(int null){
+    printf("%d ", null);
+    return null;
+}
+
+int lexicalKeywords13(int package){
+    printf("%d ", package);
+    return package;
+}
+
+int lexicalKeywords14(int super){
+    printf("%d ", super);
+    return super;
+}
+
+int lexicalKeywords15(int to){
+    printf("%d ", to);
+    return to;
+}
+
+int lexicalKeywords16(int use){
+    printf("%d ", use);
+    return use;
+}
+
+int lexicalKeywords17(int var){
+    printf("%d ", var);
+    return var;
+}
+
+int lexicalKeywords18(int with){
+    printf("%d ", with);
+    return with;
+}
+
+int syntacticKeywords0(int each){
+    printf("%d ", each);
+    return each;
+}
+
+int syntacticKeywords1(int get){
+    printf("%d ", get);
+    return get;
+}
+
+int syntacticKeywords2(int set){
+    printf("%d ", set);
+    return set;
+}
+
+int syntacticKeywords3(int include){
+    printf("%d ", include);
+    return include;
+}
+
+int syntacticKeywords4(int dynamic){
+    printf("%d ", dynamic);
+    return dynamic;
+}
+
+int syntacticKeywords5(int final){
+    printf("%d ", final);
+    return final;
+}
+
+int syntacticKeywords6(int native){
+    printf("%d ", native);
+    return native;
+}
+
+int syntacticKeywords7(int override){
+    printf("%d ", override);
+    return override;
+}
+
+int futureReservedWords0(int abstract){
+    printf("%d ", abstract);
+    return abstract;
+}
+
+int futureReservedWords1(int boolean){
+    printf("%d ", boolean);
+    return boolean;
+}
+
+int futureReservedWords2(int byte){
+    printf("%d ", byte);
+    return byte;
+}
+
+int futureReservedWords3(int cast){
+    printf("%d ", cast);
+    return cast;
+}
+
+int futureReservedWords4(int debugger){
+    printf("%d ", debugger);
+    return debugger;
+}
+
+int futureReservedWords5(int intrinsic){
+    printf("%d ", intrinsic);
+    return intrinsic;
+}
+
+int futureReservedWords6(int prototype){
+    printf("%d ", prototype);
+    return prototype;
+}
+
+int futureReservedWords7(int synchronized){
+    printf("%d ", synchronized);
+    return synchronized;
+}
+
+int futureReservedWords8(int throws){
+    printf("%d ", throws);
+    return throws;
+}
+
+int futureReservedWords9(int to){
+    printf("%d ", to);
+    return to;
+}
+
+int futureReservedWords10(int transient){
+    printf("%d ", transient);
+    return transient;
+}
+
+int futureReservedWords11(int type){
+    printf("%d ", type);
+    return type;
+}
diff -rupN swig-3.0.0.orig/Examples/as3/reserved/example.h swig-3.0.0/Examples/as3/reserved/example.h
--- swig-3.0.0.orig/Examples/as3/reserved/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/reserved/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,43 @@
+void endLine();
+
+////
+
+int lexicalKeywords0(int as);
+int lexicalKeywords1(int extends);
+int lexicalKeywords2(int finally);
+int lexicalKeywords3(int function);
+int lexicalKeywords4(int implements);
+int lexicalKeywords5(int import);
+int lexicalKeywords6(int in);
+int lexicalKeywords7(int instanceof);
+int lexicalKeywords8(int interface);
+int lexicalKeywords9(int internal);
+int lexicalKeywords10(int is);
+int lexicalKeywords11(int native);
+int lexicalKeywords12(int null);
+int lexicalKeywords13(int package);
+int lexicalKeywords14(int super);
+int lexicalKeywords15(int to);
+int lexicalKeywords16(int use);
+int lexicalKeywords17(int var);
+int lexicalKeywords18(int with);
+int syntacticKeywords0(int each);
+int syntacticKeywords1(int get);
+int syntacticKeywords2(int set);
+int syntacticKeywords3(int include);
+int syntacticKeywords4(int dynamic);
+int syntacticKeywords5(int final);
+int syntacticKeywords6(int native);
+int syntacticKeywords7(int override);
+int futureReservedWords0(int abstract);
+int futureReservedWords1(int boolean);
+int futureReservedWords2(int byte);
+int futureReservedWords3(int cast);
+int futureReservedWords4(int debugger);
+int futureReservedWords5(int intrinsic);
+int futureReservedWords6(int prototype);
+int futureReservedWords7(int synchronized);
+int futureReservedWords8(int throws);
+int futureReservedWords9(int to);
+int futureReservedWords10(int transient);
+int futureReservedWords11(int type);
\ No newline at end of file
diff -rupN swig-3.0.0.orig/Examples/as3/reserved/example.i swig-3.0.0/Examples/as3/reserved/example.i
--- swig-3.0.0.orig/Examples/as3/reserved/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/reserved/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,9 @@
+/* File : example.i */
+%module ExampleModule
+
+#ifdef SWIG
+%include "example.h"
+#else
+#include "example.h"
+#endif
+
diff -rupN swig-3.0.0.orig/Examples/as3/reserved/runme.as swig-3.0.0/Examples/as3/reserved/runme.as
--- swig-3.0.0.orig/Examples/as3/reserved/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/reserved/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,50 @@
+package SWIGExample {
+    import avmplus.System;
+
+    public function ASMain() {
+        ExampleModule.lexicalKeywords0(0);
+        ExampleModule.lexicalKeywords1(1);
+        ExampleModule.lexicalKeywords2(2);
+        ExampleModule.lexicalKeywords3(3);
+        ExampleModule.lexicalKeywords4(4);
+        ExampleModule.lexicalKeywords5(5);
+        ExampleModule.lexicalKeywords6(6);
+        ExampleModule.lexicalKeywords7(7);
+        ExampleModule.lexicalKeywords8(8);
+        ExampleModule.lexicalKeywords9(9);
+        ExampleModule.lexicalKeywords10(10);
+        ExampleModule.lexicalKeywords11(11);
+        ExampleModule.lexicalKeywords12(12);
+        ExampleModule.lexicalKeywords13(13);
+        ExampleModule.lexicalKeywords14(14);
+        ExampleModule.lexicalKeywords15(15);
+        ExampleModule.lexicalKeywords16(16);
+        ExampleModule.lexicalKeywords17(17);
+        ExampleModule.lexicalKeywords18(18);
+        ExampleModule.syntacticKeywords0(0);
+        ExampleModule.syntacticKeywords1(1);
+        ExampleModule.syntacticKeywords2(2);
+        ExampleModule.syntacticKeywords3(3);
+        ExampleModule.syntacticKeywords4(4);
+        ExampleModule.syntacticKeywords5(5);
+        ExampleModule.syntacticKeywords6(6);
+        ExampleModule.syntacticKeywords7(7);
+        ExampleModule.futureReservedWords0(0);
+        ExampleModule.futureReservedWords1(1);
+        ExampleModule.futureReservedWords2(2);
+        ExampleModule.futureReservedWords3(3);
+        ExampleModule.futureReservedWords4(4);
+        ExampleModule.futureReservedWords5(5);
+        ExampleModule.futureReservedWords6(6);
+        ExampleModule.futureReservedWords7(7);
+        ExampleModule.futureReservedWords8(8);
+        ExampleModule.futureReservedWords9(9);
+        ExampleModule.futureReservedWords10(10);
+        ExampleModule.futureReservedWords11(11);
+        ExampleModule.endLine();
+        
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/simple/Makefile swig-3.0.0/Examples/as3/simple/Makefile
--- swig-3.0.0.orig/Examples/as3/simple/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/simple/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/simple/example.c swig-3.0.0/Examples/as3/simple/example.c
--- swig-3.0.0.orig/Examples/as3/simple/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/simple/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,18 @@
+/* File : example.c */
+
+/* A global variable */
+double Foo = 3.0;
+
+/* Compute the greatest common divisor of positive integers */
+int gcd(int x, int y) {
+  int g;
+  g = y;
+  while (x > 0) {
+    g = x;
+    x = y % x;
+    y = g;
+  }
+  return g;
+}
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/simple/example.i swig-3.0.0/Examples/as3/simple/example.i
--- swig-3.0.0.orig/Examples/as3/simple/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/simple/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,7 @@
+/* File : example.i */
+%module ExampleModule
+
+%inline %{
+extern int    gcd(int x, int y);
+extern double Foo;
+%}
diff -rupN swig-3.0.0.orig/Examples/as3/simple/runme.as swig-3.0.0/Examples/as3/simple/runme.as
--- swig-3.0.0.orig/Examples/as3/simple/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/simple/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,16 @@
+package SWIGExample {
+    import avmplus.System;
+    public function ASMain() {
+        var x = 42, y = 105;
+        var g = ExampleModule.gcd(x, y);
+        Trace('The gcd of ' + x + ' and ' + y + ' is ' + g);
+        
+        Trace('Foo = ' + ExampleModule.Foo);
+        ExampleModule.Foo = 3.1415926;
+        Trace('Foo = ' + ExampleModule.Foo);
+    
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/static/Makefile swig-3.0.0/Examples/as3/static/Makefile
--- swig-3.0.0.orig/Examples/as3/static/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/static/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,20 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+CXXSRCS    = example.cxx
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+LIBS	   = -lm
+
+all::
+	$(MAKE) -f $(TOP)/Makefile CXXSRCS='$(CXXSRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3_cpp
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+
+check: all
+	./$(TARGET)
+
diff -rupN swig-3.0.0.orig/Examples/as3/static/example.cxx swig-3.0.0/Examples/as3/static/example.cxx
--- swig-3.0.0.orig/Examples/as3/static/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/static/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,17 @@
+/* File : example.c */
+
+#include "example.h"
+#define M_PI 3.14159265358979323846
+
+double Circle::area(void) {
+  return M_PI*radius*radius;
+}
+
+double Circle::perimeter(void) {
+  return 2*M_PI*radius;
+}
+
+double Circle::getPi(void) {
+  return M_PI;
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/static/example.h swig-3.0.0/Examples/as3/static/example.h
--- swig-3.0.0.orig/Examples/as3/static/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/static/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,18 @@
+/* File : example.h */
+
+
+class Circle {
+private:
+  double radius;
+public:
+  Circle(double r) : radius(r) { };
+  virtual double area(void);
+  virtual double perimeter(void);
+  static double getPi();
+};
+
+
+
+
+
+  
diff -rupN swig-3.0.0.orig/Examples/as3/static/example.i swig-3.0.0/Examples/as3/static/example.i
--- swig-3.0.0.orig/Examples/as3/static/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/static/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,18 @@
+/* File : example.i */
+#ifdef SWIG
+%module ExampleModule
+
+%{
+#include "example.h"
+%}
+
+/* Let's just grab the original header file here */
+%include "example.h"
+
+#else
+/* This is what clang sees */
+#include "example.h"
+
+#endif
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/static/runme.as swig-3.0.0/Examples/as3/static/runme.as
--- swig-3.0.0.orig/Examples/as3/static/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/static/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,12 @@
+package SWIGExample {
+
+    import avmplus.System;
+
+    public function ASMain() {
+
+        // Access a static member function
+        Trace("pi is " + Circle.getPi());
+
+        return 0;
+    }
+}
diff -rupN swig-3.0.0.orig/Examples/as3/stdint/Makefile swig-3.0.0/Examples/as3/stdint/Makefile
--- swig-3.0.0.orig/Examples/as3/stdint/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/stdint/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,20 @@
+TOP        = ../..
+SWIG       = $(TOP)/../../sdk/usr/bin/swig
+SWIGOPT    = -v
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' SWIGOPT='$(SWIGOPT)' TARGET='$(TARGET)' \
+	INTERFACE='$(INTERFACE)' LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/stdint/example.c swig-3.0.0/Examples/as3/stdint/example.c
--- swig-3.0.0.orig/Examples/as3/stdint/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/stdint/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,11 @@
+/* File : example.c */
+#include <stdint.h>
+
+/* Some global variables */
+int32_t a;
+int_least16_t b;
+int_fast8_t c;
+uint8_t d;
+intptr_t e;
+
+
diff -rupN swig-3.0.0.orig/Examples/as3/stdint/example.i swig-3.0.0/Examples/as3/stdint/example.i
--- swig-3.0.0.orig/Examples/as3/stdint/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/stdint/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,16 @@
+/* File : example.i */
+%module ExampleModule
+
+%include <stdint.i>
+
+%{
+#include <stdint.h>
+%}
+
+%inline %{
+extern int32_t a;
+extern int_least16_t b;
+extern int_fast8_t c;
+extern uint8_t d;
+extern intptr_t e;
+%}
diff -rupN swig-3.0.0.orig/Examples/as3/stdint/runme.as swig-3.0.0/Examples/as3/stdint/runme.as
--- swig-3.0.0.orig/Examples/as3/stdint/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/stdint/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,29 @@
+package SWIGExample {
+    import avmplus.System;
+    public function ASMain() {
+        
+        Trace('a = ' + ExampleModule.a);
+        ExampleModule.a = 31415926;
+        Trace('a = ' + ExampleModule.a);
+    
+        Trace('b = ' + ExampleModule.b);
+        ExampleModule.b = 123;
+        Trace('b = ' + ExampleModule.b);
+        
+        Trace('c = ' + ExampleModule.c);
+        ExampleModule.c = 'a';
+        Trace('c = ' + ExampleModule.c);
+        
+        Trace('d = ' + ExampleModule.d);
+        ExampleModule.d = 'b';
+        Trace('d = ' + ExampleModule.d);
+        
+        Trace('e = ' + ExampleModule.e);
+        ExampleModule.e = 321;
+        Trace('e = ' + ExampleModule.e);
+        
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/string/Makefile swig-3.0.0/Examples/as3/string/Makefile
--- swig-3.0.0.orig/Examples/as3/string/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/string/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/string/example.c swig-3.0.0/Examples/as3/string/example.c
--- swig-3.0.0.orig/Examples/as3/string/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/string/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,7 @@
+/* File : example.c */
+#include <stdio.h>
+
+void print_str(char *str) {
+    printf("%s\n", str);
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/string/example.i swig-3.0.0/Examples/as3/string/example.i
--- swig-3.0.0.orig/Examples/as3/string/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/string/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,6 @@
+/* File : example.i */
+%module ExampleModule
+
+%inline %{
+extern void    print_str(char *str);
+%}
diff -rupN swig-3.0.0.orig/Examples/as3/string/runme.as swig-3.0.0/Examples/as3/string/runme.as
--- swig-3.0.0.orig/Examples/as3/string/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/string/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,9 @@
+package SWIGExample {
+    import avmplus.System;
+    public function ASMain() {
+        ExampleModule.print_str('a string passed from AS');
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/struct/Makefile swig-3.0.0/Examples/as3/struct/Makefile
--- swig-3.0.0.orig/Examples/as3/struct/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/struct/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.c 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/struct/example.c swig-3.0.0/Examples/as3/struct/example.c
--- swig-3.0.0.orig/Examples/as3/struct/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/struct/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,35 @@
+/* File : example.c */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stddef.h>
+
+struct Bar {
+    int a;
+    unsigned b;
+    char c;
+    double d;
+    int nums[4];
+};
+
+void set_struct_members(struct Bar *bar) {
+    bar->a = -1;
+    bar->b = UINT_MAX - 1;
+    bar->c = 'A';
+    bar->d = 2.654321;
+}
+
+void print_struct_members(struct Bar *bar) {
+    fprintf(stdout, "%d, ", bar->a);
+    fprintf(stdout, "%u, ", bar->b);
+    fprintf(stdout, "%c, ", bar->c);
+    fprintf(stdout, "%f\n", bar->d);
+}
+
+void print_struct_offsets() {
+    fprintf(stdout, "a: %u\n", offsetof(struct Bar, a));
+    fprintf(stdout, "b: %u\n", offsetof(struct Bar, b));
+    fprintf(stdout, "c: %u\n", offsetof(struct Bar, c));
+    fprintf(stdout, "d: %u\n", offsetof(struct Bar, d));
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/struct/example.i swig-3.0.0/Examples/as3/struct/example.i
--- swig-3.0.0.orig/Examples/as3/struct/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/struct/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,17 @@
+/* File : example.i */
+#ifdef SWIG
+%module ExampleModule
+#endif
+
+struct Bar {
+    int a;
+    unsigned b;
+    char c;
+    double d;
+    int nums[4];
+};
+
+extern void set_struct_members(struct Bar *bar);
+extern void print_struct_members(struct Bar *bar);
+extern void print_struct_offsets();
+
diff -rupN swig-3.0.0.orig/Examples/as3/struct/runme.as swig-3.0.0/Examples/as3/struct/runme.as
--- swig-3.0.0.orig/Examples/as3/struct/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/struct/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,52 @@
+package SWIGExample {
+
+    import avmplus.System;
+    import com.adobe.flascc.CModule;
+    import flash.utils.ByteArray;
+
+    public function ASMain() {
+        var addr:int = CModule.malloc(BarValue.size);
+        var bar = new BarValue(CModule.ram, addr);
+
+        ExampleModule.set_struct_members(addr);
+        Trace('(AS) a = ' + bar.a);
+        Trace('(AS) b = ' + bar.b);
+        Trace('(AS) c = ' + bar.c);
+        Trace('(AS) d = ' + bar.d);
+        
+        var nums:ByteArray = new ByteArray();
+        nums.endian = "littleEndian";
+        nums.writeInt(111);
+        nums.writeInt(222);
+        nums.writeInt(333);
+        nums.writeInt(444);
+        nums.position = 0;
+        
+        bar.nums = nums;
+        
+        var outputNums:ByteArray = bar.nums;
+        Trace('(AS) nums[0] = ' + outputNums.readInt());
+        Trace('(AS) nums[1] = ' + outputNums.readInt());
+        Trace('(AS) nums[2] = ' + outputNums.readInt());
+        Trace('(AS) nums[3] = ' + outputNums.readInt());
+
+        ExampleModule.print_struct_members(addr);
+        bar.a = -2;
+        bar.b = 345;
+        bar.c = 'b'.charCodeAt(0);
+        bar.d = 6.54321;
+        ExampleModule.print_struct_members(addr);
+
+        ExampleModule.print_struct_offsets();
+        if (bar.addressOf() != addr) {
+            Trace('error: addressOf() returned wrong value: ' 
+                    + bar.addressOf() + ' (should be ' + addr + ')');
+        }
+
+        CModule.free(addr);
+
+        return 0;
+    }
+
+}
+
diff -rupN swig-3.0.0.orig/Examples/as3/suppressoverride/Makefile swig-3.0.0/Examples/as3/suppressoverride/Makefile
--- swig-3.0.0.orig/Examples/as3/suppressoverride/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/suppressoverride/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,19 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+SRCS       = example.cpp
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+
+all::
+	$(MAKE) -f $(TOP)/Makefile SRCS='$(SRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+	rm -f $(TARGET).py
+
+check: all
+	./$(TARGET)
diff -rupN swig-3.0.0.orig/Examples/as3/suppressoverride/example.cpp swig-3.0.0/Examples/as3/suppressoverride/example.cpp
--- swig-3.0.0.orig/Examples/as3/suppressoverride/example.cpp	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/suppressoverride/example.cpp	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,11 @@
+/* File : example.c */
+
+class base { 
+protected: 
+virtual ~base(){} 
+}; 
+
+class derived : public base { 
+public: 
+virtual ~derived() {} 
+};
diff -rupN swig-3.0.0.orig/Examples/as3/suppressoverride/example.i swig-3.0.0/Examples/as3/suppressoverride/example.i
--- swig-3.0.0.orig/Examples/as3/suppressoverride/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/suppressoverride/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,7 @@
+/* File : example.i */
+%module ExampleModule
+
+// Because no destructor is exposed in the base class
+// we must suppress the use of the AS3 override keyword
+// when wrapping the derived class's destructor
+%as3suppressoverride derived::~derived;
diff -rupN swig-3.0.0.orig/Examples/as3/suppressoverride/runme.as swig-3.0.0/Examples/as3/suppressoverride/runme.as
--- swig-3.0.0.orig/Examples/as3/suppressoverride/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/suppressoverride/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,6 @@
+package SWIGExample {
+    import avmplus.System;
+    public function ASMain() {
+        return 0;
+    }
+}
diff -rupN swig-3.0.0.orig/Examples/as3/template/Makefile swig-3.0.0/Examples/as3/template/Makefile
--- swig-3.0.0.orig/Examples/as3/template/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/template/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,20 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+CXXSRCS    = 
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example_wrap
+LIBS	   = -lm
+
+all::
+	$(MAKE) -f $(TOP)/Makefile CXXSRCS='$(CXXSRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3_cpp
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+
+check: all
+	./$(TARGET)
+
diff -rupN swig-3.0.0.orig/Examples/as3/template/example.h swig-3.0.0/Examples/as3/template/example.h
--- swig-3.0.0.orig/Examples/as3/template/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/template/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,32 @@
+/* File : example.h */
+
+// Some template definitions
+
+template<class T> T max(T a, T b) { return  a>b ? a : b; }
+
+template<class T> class vector {
+  T *v;
+  int sz;
+ public:
+  vector(int _sz) {
+    v = new T[_sz];
+    sz = _sz;
+  }
+  T &get(int index) {
+    return v[index];
+  }
+  void set(int index, T &val) {
+    v[index] = val;
+  }
+#ifdef SWIG
+  %extend {
+    T getitem(int index) {
+      return $self->get(index);
+    }
+    void setitem(int index, T val) {
+      $self->set(index,val);
+    }
+  }
+#endif
+};
+
diff -rupN swig-3.0.0.orig/Examples/as3/template/example.i swig-3.0.0/Examples/as3/template/example.i
--- swig-3.0.0.orig/Examples/as3/template/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/template/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,17 @@
+/* File : example.i */
+%module ExampleModule
+
+%{
+#include "example.h"
+%}
+
+/* Let's just grab the original header file here */
+%include "example.h"
+
+/* Now instantiate some specific template declarations */
+
+%template(maxint) max<int>;
+%template(maxdouble) max<double>;
+%template(Vecint) vector<int>;
+%template(Vecdouble) vector<double>;
+
diff -rupN swig-3.0.0.orig/Examples/as3/template/runme.as swig-3.0.0/Examples/as3/template/runme.as
--- swig-3.0.0.orig/Examples/as3/template/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/template/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,35 @@
+package SWIGExample {
+    import avmplus.System;
+    public function ASMain() {
+        // Call some templated functions
+        Trace(ExampleModule.maxint(3, 7));
+        Trace(ExampleModule.maxdouble(3.14, 2.18));
+
+        // Create some class
+        var iv = Vecint.create(100);
+        var dv = Vecdouble.create(1000);
+
+        for (var i:int = 0; i < 100; i++) {
+            iv.setitem(i, 2 * i);
+        }
+
+        for (i = 0; i < 1000; i++) {
+            dv.setitem(i, 1.0/(i + 1));
+        }
+
+        var sum = 0;
+        for (i = 0; i < 100; i++) {
+            sum = sum + iv.getitem(i);
+        }
+
+        Trace(sum);
+
+        sum = 0;
+        for (i = 0; i < 1000; i++) {
+            sum = sum + dv.getitem(i);
+        }
+        Trace(sum);
+
+        return 0;
+    }
+}
diff -rupN swig-3.0.0.orig/Examples/as3/template2/Makefile swig-3.0.0/Examples/as3/template2/Makefile
--- swig-3.0.0.orig/Examples/as3/template2/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/template2/Makefile	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,20 @@
+TOP        = ../..
+SWIG       = $(TOP)/../preinst-swig
+CXXSRCS    = example.cxx
+AS_SRCS    = runme.as ExampleModule.as
+TARGET     = example
+INTERFACE  = example.i
+LLVM_BCS   = example example_wrap
+LIBS	   = -lm
+
+all::
+	$(MAKE) -f $(TOP)/Makefile CXXSRCS='$(CXXSRCS)' AS_SRCS='$(AS_SRCS)' \
+	SWIG='$(SWIG)' TARGET='$(TARGET)' INTERFACE='$(INTERFACE)' \
+	LLVM_BCS='$(LLVM_BCS)' as3_cpp
+
+clean::
+	$(MAKE) -f $(TOP)/Makefile as3_clean
+
+check: all
+	./$(TARGET)
+
diff -rupN swig-3.0.0.orig/Examples/as3/template2/example.cxx swig-3.0.0/Examples/as3/template2/example.cxx
--- swig-3.0.0.orig/Examples/as3/template2/example.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/template2/example.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,10 @@
+#include "example.h"
+
+using namespace std;
+
+int square(int a)
+{
+    List<int> L;
+	L.sublist(1,2);
+    return a * a;
+}
\ No newline at end of file
diff -rupN swig-3.0.0.orig/Examples/as3/template2/example.h swig-3.0.0/Examples/as3/template2/example.h
--- swig-3.0.0.orig/Examples/as3/template2/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/template2/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,7 @@
+
+int square(int a);
+
+template<class T> class List {
+public:
+    List<T> sublist(int start, int end){ List l; return l;};
+};
diff -rupN swig-3.0.0.orig/Examples/as3/template2/example.i swig-3.0.0/Examples/as3/template2/example.i
--- swig-3.0.0.orig/Examples/as3/template2/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/template2/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,15 @@
+/* File : example.i */
+#ifdef SWIG
+%module ExampleModule
+
+%{
+    #include "example.h"
+%}
+
+%include "example.h"
+
+%template(intList) List<int>; 
+
+#else
+#include "example.h"
+#endif
diff -rupN swig-3.0.0.orig/Examples/as3/template2/runme.as swig-3.0.0/Examples/as3/template2/runme.as
--- swig-3.0.0.orig/Examples/as3/template2/runme.as	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/template2/runme.as	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,13 @@
+package SWIGExample {
+
+    import avmplus.System;
+    import ExampleLib;
+    import intList;
+
+    public function ASMain() {
+        // Succeed if compile was successful
+	Trace(ExampleModule.square(2));
+        Trace("Pass");
+        return 0;
+    }
+}
diff -rupN swig-3.0.0.orig/Examples/as3/variables/example.c swig-3.0.0/Examples/as3/variables/example.c
--- swig-3.0.0.orig/Examples/as3/variables/example.c	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/variables/example.c	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,91 @@
+/* File : example.c */
+
+/* I'm a file containing some C global variables */
+
+/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
+#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
+# define _CRT_SECURE_NO_DEPRECATE
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "example.h"
+
+int              ivar = 0;                    
+short            svar = 0;
+long             lvar = 0;
+unsigned int     uivar = 0;
+unsigned short   usvar = 0;
+unsigned long    ulvar = 0;
+signed char      scvar = 0;
+unsigned char    ucvar = 0;
+char             cvar = 0;
+float            fvar = 0;
+double           dvar = 0;
+char            *strvar = 0;
+const char       cstrvar[] = "Goodbye";
+int             *iptrvar = 0;
+char             name[256] = "Dave";
+char             path[256] = "/home/beazley";
+
+
+/* Global variables involving a structure */
+Point           *ptptr = 0;
+Point            pt = { 10, 20 };
+
+/* A variable that we will make read-only in the interface */
+int              status = 1;
+
+/* A debugging function to print out their values */
+
+void print_vars() {
+  printf("ivar      = %d\n", ivar);
+  printf("svar      = %d\n", svar);
+  printf("lvar      = %ld\n", lvar);
+  printf("uivar     = %u\n", uivar);
+  printf("usvar     = %u\n", usvar);
+  printf("ulvar     = %lu\n", ulvar);
+  printf("scvar     = %d\n", scvar);
+  printf("ucvar     = %u\n", ucvar);
+  printf("fvar      = %g\n", fvar);
+  printf("dvar      = %g\n", dvar);
+  printf("cvar      = %c\n", cvar);
+  printf("strvar    = %s\n", strvar ? strvar : "(null)");
+  printf("cstrvar   = %s\n", cstrvar);
+  printf("iptrvar   = %p\n", iptrvar);
+  printf("name      = %s\n", name);
+  printf("ptptr     = %p (%d, %d)\n", ptptr, ptptr ? ptptr->x : 0, ptptr ? ptptr->y : 0);
+  printf("pt        = (%d, %d)\n", pt.x, pt.y);
+  printf("status    = %d\n", status);
+}
+
+/* A function to create an integer (to test iptrvar) */
+
+int *new_int(int value) {
+  int *ip = (int *) malloc(sizeof(int));
+  *ip = value;
+  return ip;
+}
+
+/* A function to create a point */
+
+Point *new_Point(int x, int y) {
+  Point *p = (Point *) malloc(sizeof(Point));
+  p->x = x;
+  p->y = y;
+  return p;
+}
+
+char * Point_print(Point *p) {
+  static char buffer[256];
+  if (p) {
+    sprintf(buffer,"(%d,%d)", p->x,p->y);
+  } else {
+    sprintf(buffer,"null");
+  }
+  return buffer;
+}
+
+void pt_print() {
+  printf("(%d, %d)\n", pt.x, pt.y);
+}
diff -rupN swig-3.0.0.orig/Examples/as3/variables/example.h swig-3.0.0/Examples/as3/variables/example.h
--- swig-3.0.0.orig/Examples/as3/variables/example.h	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/variables/example.h	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,6 @@
+/* File: example.h */
+
+typedef struct {
+  int x,y;
+} Point;
+
diff -rupN swig-3.0.0.orig/Examples/as3/variables/example.i swig-3.0.0/Examples/as3/variables/example.i
--- swig-3.0.0.orig/Examples/as3/variables/example.i	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/as3/variables/example.i	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,49 @@
+/* File : example.i */
+%module example
+%{
+#include "example.h"
+%}
+
+/* Some global variable declarations */
+%inline %{
+extern int              ivar;
+extern short            svar;
+extern long             lvar;
+extern unsigned int     uivar;
+extern unsigned short   usvar;
+extern unsigned long    ulvar;
+extern signed char      scvar;
+extern unsigned char    ucvar;
+extern char             cvar;
+extern float            fvar;
+extern double           dvar;
+extern char            *strvar;
+extern const char       cstrvar[];
+extern int             *iptrvar;
+extern char             name[256];
+
+extern Point           *ptptr;
+extern Point            pt;
+%}
+
+
+/* Some read-only variables */
+
+%immutable;
+
+%inline %{
+extern int  status;
+extern char path[256];
+%}
+
+%mutable;
+
+/* Some helper functions to make it easier to test */
+%inline %{
+extern void  print_vars();
+extern int  *new_int(int value);
+extern Point *new_Point(int x, int y);
+extern char  *Point_print(Point *p);
+extern void  pt_print();
+%}
+
diff -rupN swig-3.0.0.orig/Examples/test-suite/as3/Makefile.in swig-3.0.0/Examples/test-suite/as3/Makefile.in
--- swig-3.0.0.orig/Examples/test-suite/as3/Makefile.in	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Examples/test-suite/as3/Makefile.in	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,51 @@
+#######################################################################
+# Makefile for as3 test-suite
+#######################################################################
+
+LANGUAGE     = as3
+AS3         = @LEGACY_ASC@
+SCRIPTSUFFIX = _runme.as3
+srcdir       = @srcdir@
+top_srcdir   = @top_srcdir@
+top_builddir = @top_builddir@
+
+include $(srcdir)/../common.mk
+
+# Overridden variables here
+# no C++ tests for now
+CPP_TEST_CASES =
+#C_TEST_CASES += 
+
+# Custom tests - tests with additional commandline options
+# none!
+
+# Rules for the different types of tests
+%.cpptest: 
+	$(setup)
+	+$(swig_and_compile_cpp)
+	$(run_testcase)
+
+%.ctest:
+	$(setup)
+	+$(swig_and_compile_c)
+	$(run_testcase)
+
+%.multicpptest: 
+	$(setup)
+	+$(swig_and_compile_multi_cpp)
+	$(run_testcase)
+
+# Runs the testcase. A testcase is only run if
+# a file is found which has _runme.as3 appended after the testcase name.
+run_testcase = \
+	if [ -f $(srcdir)/$(SCRIPTPREFIX)$*$(SCRIPTSUFFIX) ]; then \
+	  env LD_LIBRARY_PATH=.:$$LD_LIBRARY_PATH $(RUNTOOL) $(AS3) -batch -s $(srcdir)/$(SCRIPTPREFIX)$*$(SCRIPTSUFFIX); \
+	fi
+
+# Clean: (does nothing, we dont generate extra as3 code)
+%.clean:
+	
+
+clean:
+	$(MAKE) -f $(top_builddir)/$(EXAMPLES)/Makefile as3_clean
+
diff -rupN swig-3.0.0.orig/Lib/allkw.swg swig-3.0.0/Lib/allkw.swg
--- swig-3.0.0.orig/Lib/allkw.swg	2014-03-17 01:49:54.000000000 +0400
+++ swig-3.0.0/Lib/allkw.swg	2014-10-11 22:09:36.000000000 +0400
@@ -30,6 +30,7 @@
 %include <r/rkw.swg>
 %include <ruby/rubykw.swg>
 %include <tcl/tclkw.swg>
+%include <as3/as3kw.swg>
 
 
 #endif //__Lib_allkw_swg__
diff -rupN swig-3.0.0.orig/Lib/as3/as3.swg swig-3.0.0/Lib/as3/as3.swg
--- swig-3.0.0.orig/Lib/as3/as3.swg	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Lib/as3/as3.swg	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,272 @@
+/*
+** Copyright 2012 Adobe Systems Incorporated. All Rights Reserved.
+** 
+** You may copy, modify, distribute, and make derivative works based on
+** this software, in source code or object code form, without
+** restriction. If you distribute the software to others, you may do
+** so according to the terms of your choice. This software is offered as
+** is, without warranty of any kind.
+**/
+
+%include <as3kw.swg>
+
+%{
+#include <stdlib.h>
+#include <string.h>
+#include "AS3/AS3.h"
+#define swig_as3(X) inline_as3("import com.adobe.flascc.swig.*; " X)
+%}
+
+%typemap(astype) char                   "String";
+%typemap(astype) int                    "int";
+%typemap(astype) float                  "Number";
+%typemap(astype) double                 "Number";
+%typemap(astype) char *                 "String";
+%typemap(astype) unsigned char          "String";
+%typemap(astype) bool                   "Boolean";
+%typemap(astype) void                   "void";
+%typemap(astype) SWIGTYPE ((*)(ANY))    "Function";
+%typemap(astype) SWIGTYPE *             "int";
+%typemap(astype) SWIGTYPE               "*";
+
+%typemap(in) int {
+    AS3_GetScalarFromVar($1, $input);
+}
+
+%typemap(in) SWIGTYPE * {
+    AS3_GetScalarFromVar($1, $input);
+}
+
+// Note that this typemap yields a pointer
+/*
+%typemap(in) SWIGTYPE {
+    AS3_GetScalarFromVar($1, $input.swigCPtr);
+}
+*/
+
+%typemap(in) double {
+    AS3_GetScalarFromVar($1, $input);
+}
+
+%typemap(in) float {
+    AS3_GetScalarFromVar($1, $input);
+}
+
+%typemap(in) char * {
+    AS3_MallocString($1, $input);
+}
+
+// TODO: assumes string has one character that fits in a char
+// assert if violated
+%typemap(in) char {
+    inline_nonreentrant_as3(
+        "%0 = $input.charCodeAt(0)" : "=r"($1)
+    );
+}
+
+%typemap(in) bool {
+    AS3_GetScalarFromVar($1, $input);
+}
+
+%typemap(in) SWIGTYPE ((*)(ANY)) {
+    swig_as3(
+        "var f:Function = $input;"
+        "var ptr:int = SWIG_AS3GetCCallPtr(f);"
+        "if (!ptr) {"
+        "  var wrap = function() { $wrapper_name($input);};"
+        "  SWIG_AS3RegCCallWrapper(f, wrap);"
+        "  ptr = SWIG_AS3GetCCallPtr(f);"
+        "}"
+        "%0 = ptr;"
+        : "=r"($1)
+    );
+}
+
+%typemap(freearg) char * {
+    free($1);
+}
+
+%typemap(out) void {}
+
+%typemap(out) int {
+    AS3_DeclareVar($result, int);
+    AS3_CopyScalarToVar($result, $1);
+}
+
+%typemap(out) float {
+    AS3_DeclareVar($result, Number);
+    AS3_CopyScalarToVar($result, $1);
+}
+
+%typemap(out) double {
+    AS3_DeclareVar($result, Number);
+    AS3_CopyScalarToVar($result, $1);
+}
+
+%typemap(out) char * {
+    int len = strlen($1);
+    AS3_DeclareVar($result, String);
+    AS3_CopyCStringToVar($result, $1, len);
+}
+
+%typemap(out) char {
+    AS3_DeclareVar($result, String);
+    AS3_CopyCStringToVar($result, &$1, 1);
+}
+
+%typemap(out) bool {
+    AS3_DeclareVar($result, Boolean);
+    AS3_CopyScalarToVar($result, $1);
+}
+
+%typemap(out) SWIGTYPE ((*)(ANY)) {
+    swig_as3(
+        "var ptr:int = %0;"
+        "var $result:Function = SWIG_AS3GetASCallWrapper(ptr);"
+        "if (!$result) {"
+        "  var wrap:Function = function() {"
+        "    var args:Array = arguments.concat(ptr);"
+        "    return $wrapper_name.apply(null, args);"
+        "  };"
+        "  SWIG_AS3RegASCallWrapper(ptr, wrap);"
+        "  $result = SWIG_AS3GetASCallWrapper(ptr);"
+        "}" : : "r"($1)
+    );
+}
+
+%typemap(out) SWIGTYPE * {
+    AS3_DeclareVar($result, int);
+    AS3_CopyScalarToVar($result, $1);
+}
+
+// Note that this typemap yields a pointer that must be freed later
+%typemap(out) SWIGTYPE {
+    #ifdef __cplusplus
+    $type *retval = new $type($1);
+    #else
+    $type *retval = ($type *) malloc(sizeof($type));
+    memcpy(retval, &$1, sizeof($type));
+    #endif
+    swig_as3(
+        "var ptr:int = %0;" 
+        "var out = new $astype();"
+        "out.swigCPtr = ptr;"
+        "var $result = out;"
+        : : "r"(retval)
+    );
+}
+
+// How values are returned to Actionscript
+%typemap(asreturn) SWIGTYPE {
+    AS3_ReturnAS3Var($input);
+}
+
+%typemap(asreturn) void {
+    AS3_ReturnAS3Var(undefined);
+}
+
+%apply int {signed int, unsigned int, long, unsigned long, signed long, 
+                enum SWIGTYPE, short, unsigned short, signed short};
+%apply char {unsigned char, signed char};
+%apply SWIGTYPE * {SWIGTYPE &};
+
+%insert(runtime) %{
+/* Contract support */
+
+#define SWIG_contract_assert(expr, msg) if (!(expr)) {int msglen = strlen(msg);__asm__ volatile ("throw new Exception(CModule.readString(%0, %1))": : "r"(msg), "r"(msglen));}
+
+%}
+
+%insert(asruntime) %{
+/* Function pointers support */
+package com.adobe.flascc.swig {
+import flash.utils.Dictionary;
+import com.adobe.flascc.CModule;
+
+[Weak]
+var _SWIG_AS3Func2Ptr:Dictionary = new Dictionary();
+[Weak]
+var _SWIG_AS3Ptr2Func:Dictionary = new Dictionary();
+[Weak]
+var _SWIG_AS3FreeFuncPtrs:Array = new Array();
+
+[Weak]
+public function SWIG_AS3RegASCallWrapper(ptr:int, wrapper:Function):void {
+    if (_SWIG_AS3Ptr2Func[ptr]) {
+        throw("tried to register AS-callable wrapper for existing AS wrapper");
+    }
+    _SWIG_AS3Func2Ptr[wrapper] = ptr;
+    _SWIG_AS3Ptr2Func[ptr] = wrapper;
+}
+
+[Weak]
+public function SWIG_AS3UnregASCallWrapper(wrapper:Function):void {
+    var ptr:int = _SWIG_AS3Func2Ptr[wrapper];
+    delete _SWIG_AS3Func2Ptr[wrapper];
+    delete _SWIG_AS3Ptr2Func[ptr];
+}
+
+// Returns Function objects callable from AS
+[Weak]
+public function SWIG_AS3GetASCallWrapper(ptr:int):Function {
+    if (_SWIG_AS3Ptr2Func[ptr]) {
+        return _SWIG_AS3Ptr2Func[ptr];
+    } else {
+        return null;
+    }
+}
+
+// Returns the number of wrapped C and AS functions
+[Weak]
+public function SWIG_AS3WrapperNum():uint {
+    var num:uint = 0;
+    for (var key:int in _SWIG_AS3Ptr2Func) {
+        num++;
+    }
+    return num;
+}
+
+[Weak]
+public function SWIG_AS3RegCCallWrapper(func:Function, wrapper:Function):void {
+    var ptr:int;
+    
+    if (_SWIG_AS3Func2Ptr[func]) {
+        throw("tried to register C-callable wrapper for native C function");
+    }
+
+    if (_SWIG_AS3FreeFuncPtrs.length) {
+        ptr = _SWIG_AS3FreeFuncPtrs.pop();
+    } else {
+        ptr = CModule.allocFunPtrs(null, 1, 4);
+    }
+    CModule.regFun(ptr, wrapper);
+    _SWIG_AS3Func2Ptr[func] = ptr;
+    _SWIG_AS3Ptr2Func[ptr] = func;
+
+}
+
+[Weak]
+public function SWIG_AS3UnregCCallWrapper(func:Function):void {
+    var ptr:int = _SWIG_AS3Func2Ptr[func];
+    delete _SWIG_AS3Func2Ptr[func];
+    delete _SWIG_AS3Ptr2Func[ptr];
+    _SWIG_AS3FreeFuncPtrs.push(ptr);
+}
+
+// Returns a C function pointer corresponding to an Actionscript-callable 
+// wrapper Function. (The C function is callable from C, of course).
+[Weak]
+public function SWIG_AS3GetCCallPtr(func:Function):int {
+    if (_SWIG_AS3Func2Ptr[func]) {
+        return _SWIG_AS3Func2Ptr[func];
+    } else {
+        return 0;
+    }
+}
+} /* package */
+
+%}
+
+#define %as3suppressoverride %feature("as3:suppressoverride", "1")
+
+#define %as3import(IMPORTS) %feature("as3:import", IMPORTS)
diff -rupN swig-3.0.0.orig/Lib/as3/as3kw.swg swig-3.0.0/Lib/as3/as3kw.swg
--- swig-3.0.0.orig/Lib/as3/as3kw.swg	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Lib/as3/as3kw.swg	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,84 @@
+/*
+** Copyright 2012 Adobe Systems Incorporated. All Rights Reserved.
+**
+** You may copy, modify, distribute, and make derivative works based on
+** this software, in source code or object code form, without
+** restriction. If you distribute the software to others, you may do
+** so according to the terms of your choice. This software is offered as
+** is, without warranty of any kind.
+**/
+
+#ifndef AS3_AS3KW_SWG_
+#define AS3_AS3KW_SWG_
+
+/* Warnings for AS3 keywords */
+#define AS3KW(x) %keywordwarn("'" `x` "' is an AS3 keyword, renaming to '_"`x`"'",rename="_%s")  `x`
+
+/*
+   from
+   http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/statements.html
+   http://www.adobe.com/go/learn_as3_reservedwords_en
+*/
+
+AS3KW(as);
+AS3KW(break);
+AS3KW(case);
+AS3KW(continue);
+AS3KW(default);
+AS3KW(do);
+AS3KW(while);
+AS3KW(else);
+AS3KW(for);
+AS3KW(in);
+AS3KW(instanceof);
+AS3KW(is);
+AS3KW(each);	
+AS3KW(if);	
+AS3KW(label);
+AS3KW(return);	
+AS3KW(super);	
+AS3KW(switch);	
+AS3KW(throw);
+AS3KW(try);	
+AS3KW(finally);	
+AS3KW(catch);	
+AS3KW(with);
+AS3KW(dynamic);	
+AS3KW(final);	
+AS3KW(internal);	
+AS3KW(native);
+AS3KW(override);	
+AS3KW(private);	
+AS3KW(protected);	
+AS3KW(public);
+AS3KW(static);	
+AS3KW(class); 	
+AS3KW(const);	
+AS3KW(extends);
+AS3KW(function); 	
+AS3KW(implements);	
+AS3KW(interface);
+AS3KW(namespace);	
+AS3KW(package);	
+AS3KW(var);
+AS3KW(import);	
+AS3KW(include);	
+AS3KW(use);	
+AS3KW(AS3);
+AS3KW(flash_proxy);	
+AS3KW(object_proxy);	
+AS3KW(false);	
+AS3KW(null);
+AS3KW(this);
+AS3KW(true);
+
+/* While these have special meaning, they are valid identifier names, so we
+ * don't restrict their usage. (get and set are also very commonly used
+ * by swig-generated code).
+AS3KW(get);	
+AS3KW(set);	
+*/
+
+#undef AS3KW
+
+#endif //AS3_AS3KW_SWG_
diff -rupN swig-3.0.0.orig/Makefile.in swig-3.0.0/Makefile.in
--- swig-3.0.0.orig/Makefile.in	2014-03-17 01:49:54.000000000 +0400
+++ swig-3.0.0/Makefile.in	2014-10-11 22:09:36.000000000 +0400
@@ -85,6 +85,10 @@ skip-r		= test -n "@SKIP_R@"
 skip-go		= test -n "@SKIP_GO@"
 skip-d		= test -n "@SKIP_D@"
 
+# AVM2 AS3 PATCH START
+skip-as3		= test -n "@SKIP_AS3@"
+# AVM2 AS3 PATCH END
+
 # Additional dependencies for some tests
 skip-gcj        = test -n "@SKIP_GCJ@"
 skip-android    = test -n "@SKIP_ANDROID@"
@@ -129,6 +133,7 @@ check-aliveness:
 	@$(skip-r) 	  || ./$(TARGET) -r          -help
 	@$(skip-go)	  || ./$(TARGET) -go         -help
 	@$(skip-d) 	  || ./$(TARGET) -d          -help
+	@$(skip-as3) 	  || ./$(TARGET) -as3          -help
 
 check-ccache:
 	test -z "$(ENABLE_CCACHE)" || (cd $(CCACHE) && $(MAKE) check)
@@ -157,7 +162,8 @@ check-versions:					\
 	check-cffi-version			\
 	check-r-version				\
 	check-go-version			\
-	check-d-version
+	check-d-version			\
+	check-as3-version
 
 # all examples
 check-%-version :
@@ -196,7 +202,8 @@ check-examples:					\
 	check-cffi-examples			\
 	check-r-examples			\
 	check-go-examples			\
-	check-d-examples
+	check-d-examples			\
+	check-as3-examples
 
 tcl_examples       :=$(shell sed '/^\#/d' $(srcdir)/Examples/tcl/check.list)
 perl5_examples     :=$(shell sed '/^\#/d' $(srcdir)/Examples/perl5/check.list)
@@ -221,6 +228,7 @@ cffi_examples      :=
 r_examples         :=$(shell sed '/^\#/d' $(srcdir)/Examples/r/check.list)
 go_examples        :=$(shell sed '/^\#/d' $(srcdir)/Examples/go/check.list)
 d_examples         :=$(shell sed '/^\#/d' $(srcdir)/Examples/d/check.list)
+as3_examples       :=$(shell sed '/^\#/d' $(srcdir)/Examples/as3/check.list)
 
 # all examples
 check-%-examples :
@@ -274,7 +282,8 @@ check-test-suite:				\
 	check-chicken-test-suite		\
 	check-r-test-suite			\
 	check-go-test-suite			\
-	check-d-test-suite
+	check-d-test-suite			\
+	check-as3-test-suite
 
 check-%-test-suite:
 	@if test -z "$(skip-$*)"; then					\
@@ -326,7 +335,8 @@ all-test-suite:					\
 	all-chicken-test-suite			\
 	all-r-test-suite			\
 	all-go-test-suite			\
-	all-d-test-suite
+	all-d-test-suite			\
+	all-as3-test-suite
 
 all-%-test-suite:
 	@$(MAKE) $(FLAGS) check-$*-test-suite ACTION=all
@@ -354,7 +364,8 @@ broken-test-suite:				\
 	broken-chicken-test-suite		\
 	broken-r-test-suite			\
 	broken-go-test-suite			\
-	broken-d-test-suite
+	broken-d-test-suite			\
+	broken-as3-test-suite
 
 broken-%-test-suite:
 	@$(MAKE) $(FLAGS) check-$*-test-suite ACTION=broken
@@ -467,7 +478,7 @@ install-main:
 	@$(INSTALL_PROGRAM) $(TARGET) $(DESTDIR)$(BIN_DIR)/`echo $(TARGET_NOEXE) | sed '$(transform)'`@EXEEXT@
 
 lib-languages = gcj typemaps tcl perl5 python guile java mzscheme ruby php ocaml octave \
-	pike chicken csharp modula3 allegrocl clisp lua cffi uffi r go d
+	pike chicken csharp modula3 allegrocl clisp lua cffi uffi r go d as3
 
 lib-modules = std
 
diff -rupN swig-3.0.0.orig/Source/Makefile.am swig-3.0.0/Source/Makefile.am
--- swig-3.0.0.orig/Source/Makefile.am	2014-03-17 01:49:54.000000000 +0400
+++ swig-3.0.0/Source/Makefile.am	2014-10-11 22:09:36.000000000 +0400
@@ -36,6 +36,7 @@ eswig_SOURCES =	CParse/cscanner.c		\
 		DOH/void.c			\
 		Modules/allegrocl.cxx		\
 		Modules/allocate.cxx		\
+		Modules/as3.cxx		\
 		Modules/browser.cxx		\
 		Modules/cffi.cxx		\
 		Modules/chicken.cxx		\
diff -rupN swig-3.0.0.orig/Source/Makefile.in swig-3.0.0/Source/Makefile.in
--- swig-3.0.0.orig/Source/Makefile.in	2014-03-17 02:06:27.000000000 +0400
+++ swig-3.0.0/Source/Makefile.in	2014-10-11 22:09:36.000000000 +0400
@@ -63,6 +63,7 @@ am_eswig_OBJECTS = CParse/cscanner.$(OBJ
 	DOH/hash.$(OBJEXT) DOH/list.$(OBJEXT) DOH/memory.$(OBJEXT) \
 	DOH/string.$(OBJEXT) DOH/void.$(OBJEXT) \
 	Modules/allegrocl.$(OBJEXT) Modules/allocate.$(OBJEXT) \
+	Modules/as3.$(OBJEXT) \
 	Modules/browser.$(OBJEXT) Modules/cffi.$(OBJEXT) \
 	Modules/chicken.$(OBJEXT) Modules/clisp.$(OBJEXT) \
 	Modules/contract.$(OBJEXT) Modules/csharp.$(OBJEXT) \
@@ -412,6 +413,7 @@ eswig_SOURCES = CParse/cscanner.c		\
 		DOH/void.c			\
 		Modules/allegrocl.cxx		\
 		Modules/allocate.cxx		\
+		Modules/as3.cxx		\
 		Modules/browser.cxx		\
 		Modules/cffi.cxx		\
 		Modules/chicken.cxx		\
@@ -594,6 +596,8 @@ Modules/allegrocl.$(OBJEXT): Modules/$(a
 	Modules/$(DEPDIR)/$(am__dirstamp)
 Modules/allocate.$(OBJEXT): Modules/$(am__dirstamp) \
 	Modules/$(DEPDIR)/$(am__dirstamp)
+Modules/as3.$(OBJEXT): Modules/$(am__dirstamp) \
+	Modules/$(DEPDIR)/$(am__dirstamp)
 Modules/browser.$(OBJEXT): Modules/$(am__dirstamp) \
 	Modules/$(DEPDIR)/$(am__dirstamp)
 Modules/cffi.$(OBJEXT): Modules/$(am__dirstamp) \
@@ -734,6 +738,7 @@ mostlyclean-compile:
 	-rm -f DOH/void.$(OBJEXT)
 	-rm -f Modules/allegrocl.$(OBJEXT)
 	-rm -f Modules/allocate.$(OBJEXT)
+	-rm -f Modules/as3.$(OBJEXT)
 	-rm -f Modules/browser.$(OBJEXT)
 	-rm -f Modules/cffi.$(OBJEXT)
 	-rm -f Modules/chicken.$(OBJEXT)
@@ -806,6 +811,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@DOH/$(DEPDIR)/void.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@Modules/$(DEPDIR)/allegrocl.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@Modules/$(DEPDIR)/allocate.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@Modules/$(DEPDIR)/as3.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@Modules/$(DEPDIR)/browser.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@Modules/$(DEPDIR)/cffi.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@Modules/$(DEPDIR)/chicken.Po@am__quote@
diff -rupN swig-3.0.0.orig/Source/Modules/as3.cxx swig-3.0.0/Source/Modules/as3.cxx
--- swig-3.0.0.orig/Source/Modules/as3.cxx	1970-01-01 03:00:00.000000000 +0300
+++ swig-3.0.0/Source/Modules/as3.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -0,0 +1,1665 @@
+/*
+** Copyright 2012 Adobe Systems Incorporated. All Rights Reserved.
+** 
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 3, or (at your option)
+** any later version.
+** 
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+** GNU General Public License for more details.
+** 
+** You should have received a copy of the GNU General Public License
+** along with this program. If not, see <http://www.gnu.org/licenses/>.
+**/
+
+/* ----------------------------------------------------------------------------- 
+ * This file is part of SWIG, which is licensed as a whole under version 3 
+ * (or any later version) of the GNU General Public License. Some additional
+ * terms also apply to certain portions of SWIG. The full details of the SWIG
+ * license and copyrights can be found in the LICENSE and COPYRIGHT files
+ * included with the SWIG source code as distributed by the SWIG developers
+ * and at http://www.swig.org/legal.html.
+ *
+ * as3.cxx
+ *
+ * ActionScript3 language module for SWIG.
+ * ----------------------------------------------------------------------------- */
+
+#include <stdlib.h>
+#include <ctype.h>
+
+#include "llvm/Module.h"
+#include "llvm/LLVMContext.h"
+
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/Host.h"
+
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/StringMap.h"
+#include "llvm/ADT/SmallVector.h"
+
+#include "llvm/Target/TargetData.h"
+#include "llvm/Target/TargetMachine.h"
+#include "llvm/Target/TargetRegistry.h"
+
+#include "clang/Frontend/CodeGenOptions.h"
+#include "clang/Frontend/DiagnosticOptions.h"
+#include "clang/Frontend/TextDiagnosticPrinter.h"
+#include "clang/Frontend/CompilerInvocation.h"
+
+#include "clang/Basic/LangOptions.h"
+#include "clang/Basic/FileSystemOptions.h"
+
+#include "clang/Basic/SourceManager.h"
+#include "clang/Lex/HeaderSearch.h"
+#include "clang/Basic/FileManager.h"
+
+#include "clang/Frontend/HeaderSearchOptions.h"
+#include "clang/Frontend/Utils.h"
+
+#include "clang/Basic/TargetOptions.h"
+#include "clang/Basic/TargetInfo.h"
+
+#include "clang/Lex/Preprocessor.h"
+#include "clang/Frontend/PreprocessorOptions.h"
+#include "clang/Frontend/FrontendOptions.h"
+
+#include "clang/Basic/IdentifierTable.h"
+#include "clang/Basic/Builtins.h"
+
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/ASTConsumer.h"
+#include "clang/Sema/Sema.h"
+#include "clang/AST/DeclBase.h"
+#include "clang/AST/Type.h"
+#include "clang/AST/Decl.h"
+#include "clang/Sema/Lookup.h"
+#include "clang/Sema/Ownership.h"
+#include "clang/AST/DeclGroup.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+
+#include "clang/Parse/Parser.h"
+#include "clang/Parse/ParseAST.h"
+
+#include "CodeGen/CGRecordLayout.h"
+#include "CodeGen/CodeGenModule.h"
+
+#include "swigmod.h"
+
+extern "C" char *flasccSDKLocation;
+
+extern "C" void LLVMInitializeAVM2ShimTargetInfo();
+extern "C" void LLVMInitializeAVM2ShimTarget();
+
+namespace {
+
+typedef enum {INT, UINT, FLOAT, COMPOSITE, ARRAY} TypeCategory;
+
+class TypeRegistry {
+public:
+    virtual bool hasType(String *type_id) const = 0;
+};
+
+class TypeMemoryLayout;
+typedef llvm::StringMap<TypeMemoryLayout *> TypeMap;
+
+const String *AS_INT = "int";
+const String *AS_UINT = "uint";
+const String *AS_NUMBER = "Number";
+const String *AS_BYTE_ARRAY = "ByteArray";
+const String *BA_RBYTE = "readByte";
+const String *BA_RBYTES = "readBytes";
+const String *BA_RUBYTE = "readUnsignedByte";
+const String *BA_RSHORT = "readShort";
+const String *BA_RUSHORT = "readUnsignedShort";
+const String *BA_RINT = "readInt";
+const String *BA_RUINT = "readUnsignedInt";
+const String *BA_RFLOAT = "readFloat";
+const String *BA_RDOUBLE = "readDouble";
+const String *BA_WBYTE = "writeByte";
+const String *BA_WSHORT = "writeShort";
+const String *BA_WINT = "writeInt";
+const String *BA_WFLOAT = "writeFloat";
+const String *BA_WDOUBLE = "writeDouble";
+
+const String *getASTypeName(const String *type_id) {
+    // FIXME: the returned value leaks
+    String *ret = NewStringf("%sValue", type_id);
+    *Char(ret) = toupper(*Char(ret));
+    return ret;
+}
+
+struct MemberDescription {
+    unsigned size;
+    unsigned offset;
+    TypeCategory category;
+    String *name;
+    String *c_type_name;
+    
+    bool canCodeGen(const TypeRegistry &known_types) const {
+        switch (category) {
+        case UINT:
+        case INT:
+            return size == 1 || size == 2 || size == 4;
+        case FLOAT:
+            return size == 4 || size == 8;
+        case COMPOSITE:
+            return known_types.hasType(c_type_name);
+        case ARRAY:
+            return true;
+        default:
+            return false;
+        }
+    }
+
+    const String *getASType() const {
+        switch (category) {
+        case UINT:
+            return AS_UINT;
+        case INT:
+            return AS_INT;
+        case FLOAT:
+            return AS_NUMBER;
+        case COMPOSITE:
+            return getASTypeName(c_type_name); 
+        case ARRAY:
+            return AS_BYTE_ARRAY;
+        default:
+            return NULL;
+        }
+    }
+
+    bool isUnsigned() const {
+        return category == UINT;
+    }
+
+    const String *getByteArrayReadMethod() const {
+        switch (category) {
+        case INT:
+            switch(size) {
+            case 1:
+                return BA_RBYTE;
+            case 2:
+                return BA_RSHORT;
+            case 4:
+                return BA_RINT;
+            default:
+                return NULL;
+            }
+        case UINT:
+            switch (size) {
+            case 1:
+                return BA_RUBYTE;
+            case 2:
+                return BA_RUSHORT;
+            case 4:
+                return BA_RUINT;
+            default:
+                return NULL;
+            }
+        case FLOAT:
+            switch (size) {
+            case 4:
+                return BA_RFLOAT;
+            case 8:
+                return BA_RDOUBLE;
+            default:
+                return NULL;
+            }
+        default:
+            return NULL;
+        }
+    }
+
+    const String *getByteArrayWriteMethod() const {
+        switch (category) {
+        case INT:
+        case UINT:
+            switch (size) {
+            case 1:
+                return BA_WBYTE;
+            case 2:
+                return BA_WSHORT;
+            case 4:
+                return BA_WINT;
+            default:
+                return NULL;
+            }
+        case FLOAT:
+            switch (size) {
+            case 4:
+                return BA_WFLOAT;
+            case 8:
+                return BA_WDOUBLE;
+            default:
+                return NULL;
+            }
+        default:
+            return NULL;
+        }
+    }
+};
+
+class TypeMemoryLayout {
+private:
+    unsigned size;
+    String *name;
+    llvm::SmallVector<MemberDescription, 8> members;
+
+    llvm::SmallVector<unsigned, 8> llvm_fields; // XXX: get rid of this?
+    llvm::SmallVector<String *, 8> names;
+    llvm::SmallVector<unsigned, 8> offsets;
+    llvm::SmallVector<unsigned, 8> sizes;
+    llvm::SmallVector<bool, 8> signs;
+
+public:
+    TypeMemoryLayout(const clang::RecordDecl &rd, 
+                     const clang::CodeGen::CGRecordLayout &rl,
+                     const llvm::StructLayout &sl,
+                     clang::CodeGen::CodeGenTypes &types) {
+        size = sl.getSizeInBytes();
+        name = NewString(rd.getDeclName().getAsString().c_str());
+        //rl.dump();
+
+        for (clang::RecordDecl::field_iterator i = rd.field_begin();
+                i != rd.field_end(); i++) {
+            MemberDescription mem;
+            unsigned field = rl.getLLVMFieldNo(*i);
+            //llvm_fields.push_back(field);
+            //names.push_back(NewString(i->getNameAsString().c_str()));
+            mem.name = NewString(i->getNameAsString().c_str());
+            mem.offset = sl.getElementOffset(field);
+            //offsets.push_back(sl.getElementOffset(field));
+            members.push_back(mem);
+        }
+
+        // This can't be in the previous loop because calling 
+        // ConvertTypeForMem clobbers the StructLayout.
+        int cnt = 0;
+        for (clang::RecordDecl::field_iterator i = rd.field_begin();
+                i != rd.field_end(); i++, cnt++) {
+            // XXX: not sure if this is the best way!
+            const llvm::Type *memtype = types.ConvertTypeForMem(i->getType());
+            unsigned size = types.getTargetData().getTypeStoreSize(memtype);
+            const clang::Type *type = i->getType().getTypePtr();
+
+            if (type->isFloatingType()) {
+                members[cnt].category = FLOAT;
+            } else if (type->isPointerType()) {
+                members[cnt].category = INT;
+            } else if (type->isUnsignedIntegerType()) {
+                members[cnt].category = UINT;
+            } else if (type->isSignedIntegerType()) {
+                members[cnt].category = INT;
+            } else if (type->isStructureOrClassType() || type->isUnionType()) {
+                members[cnt].category = COMPOSITE;
+                // FIXME: clean up
+                const clang::RecordType *rt = type->getAsStructureType();
+                if (!rt) {
+                    rt = type->getAsUnionType();
+                }
+                if (rt) {
+                    members[cnt].c_type_name = NewString(
+                        rt->getDecl()->getName().str().c_str());
+                } else {
+                    abort();
+                }
+            } else if (type->isArrayType()) {
+                members[cnt].category = ARRAY;
+            }
+
+            members[cnt].size = size;
+        }
+    }
+
+    ~TypeMemoryLayout() {
+        for (int i = 0; i < names.size(); i++) {
+            Delete(names[i]);
+        }
+        Delete(name);
+    }
+   
+    const String *getTypeName() const {
+        return name;
+    }
+
+    unsigned getTypeSize() const {
+        return size;
+    }
+
+    unsigned getNumMembers() const {
+        return members.size();
+    }
+    
+    const MemberDescription &getMember(unsigned i) const {
+        return members[i];
+    }
+    
+    void dump() const {
+        Printf(stderr, "struct %s, %u bytes\n", name, size);
+        for (int i = 0; i < getNumMembers(); i++) {
+            const MemberDescription &mem = getMember(i);
+            Printf(stderr, "\t%s, size %u, offset %u",
+                mem.name, mem.size, mem.offset);
+            if (mem.isUnsigned()) {
+                Printf(stderr, " (unsigned) ");
+            }
+            Printf(stderr, "\n");
+        }
+    }
+
+    bool canCodeGen(const TypeRegistry &known_types) const {
+        for (int i = 0; i < getNumMembers(); i++) {
+            if (!getMember(i).canCodeGen(known_types)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+};
+
+
+class RecordLocator : public clang::ASTConsumer,
+                      public clang::RecursiveASTVisitor<RecordLocator>,
+                      public TypeRegistry
+{
+private:
+    typedef clang::RecursiveASTVisitor<RecordLocator> super;
+
+    void storeTypeLayout(clang::RecordDecl *rd) {
+        clang::CodeGen::CodeGenTypes &cgtypes = cgModule->getTypes();
+        clang::SourceLocation loc = rd->getLocStart();
+        unsigned line = srcManager->getPresumedLineNumber(loc);
+        const char *file = srcManager->getFileEntryForID(
+            srcManager->getFileID(loc))->getName();
+        llvm::StringRef name = rd->getName();
+        rd = rd->getDefinition();
+        if (!rd) {
+            Printf(stderr, "%s:%u: Can't find definition for %s\n",
+                file, line, name.str().c_str());
+            return;
+        }
+
+        const clang::CodeGen::CGRecordLayout *rl = 
+            &(cgtypes.getCGRecordLayout(rd));
+        if (!rl) {
+            // Replace any opaque types previously stored with the 
+            // full definition. The opaque types come from calling 
+            // ConvertTypeForMem on a type that has a forward 
+            // declared member of this type.
+            cgtypes.UpdateCompletedType(rd);
+            rl = &(cgtypes.getCGRecordLayout(rd));
+            if (!rl) {
+                Printf(stderr, "%s:%u: Insufficient type information for %s\n", 
+                    file, line, name.str().c_str());
+                Printf(stderr, "def on line %u\n", 
+                    srcManager->getPresumedLineNumber(rd->getLocStart()));
+                return;
+            }
+        }
+        const llvm::StructType *st = rl->getLLVMType();
+        const llvm::StructLayout *sl = td->getStructLayout(st);
+        
+        TypeMemoryLayout *type_layout = 
+            new TypeMemoryLayout(*rd, *rl, *sl, cgtypes);
+        composite_types[llvm::StringRef(Char(type_layout->getTypeName()))] = 
+            type_layout;
+        //type_layout->dump();
+    }
+
+    void handleTypedef(clang::TypedefDecl *tpd) {
+        const clang::Type *type = tpd->getUnderlyingType().getTypePtr();
+        llvm::StringRef typedefname = tpd->getName();
+        const clang::RecordType *rt = dyn_cast<clang::RecordType>(type);
+        if (rt) {
+            clang::RecordDecl *rd = rt->getDecl();
+            llvm::StringRef name = rd->getName();
+            TypeMap &map = composite_types;
+            if (map.find(name) != map.end()) {
+                /*
+                   std::cerr << "aliased " << typedefname.str() << " to " 
+                   << name.str() << std::endl;
+                 */
+                map[typedefname] = map[name];
+            }
+        }
+    }
+
+public:
+    RecordLocator() : clang::ASTConsumer() { }
+    virtual ~RecordLocator() { }
+
+    virtual void HandleTopLevelDecl(clang::DeclGroupRef d) {
+        clang::DeclGroupRef::iterator it;
+        for(it = d.begin(); it != d.end(); it++) {
+            clang::RecordDecl *rd = dyn_cast<clang::RecordDecl>(*it);
+            clang::TypedefDecl *tpd = dyn_cast<clang::TypedefDecl>(*it);
+            if (rd) {
+                TraverseDecl(rd);
+            }
+            if (tpd) {
+                handleTypedef(tpd);
+            }
+            
+            /*
+            clang::NamedDecl *nd = dyn_cast<clang::NamedDecl>(*it);
+            if (nd) {
+                Printf(stderr, "top decl: %s\n",
+                        nd->getNameAsString().c_str());
+                Printf(stderr, "kind: %s\n",
+                        nd->getDeclKindName());
+                if (!rd) {
+                    Printf(stderr, "not record\n");
+                }
+            }
+            */
+        }
+    }
+
+    virtual bool TraverseRecordDecl(clang::RecordDecl *d) {
+        storeTypeLayout(d);
+        return super::TraverseRecordDecl(d);
+    }
+
+    virtual bool TraverseCXXRecordDecl(clang::CXXRecordDecl *d) {
+        TraverseRecordDecl(d);
+        return super::TraverseCXXRecordDecl(d);
+    }
+    
+    virtual bool hasType(String *type_id) const {
+        llvm::StringRef type_str(Char(type_id));
+        return composite_types.find(type_str) != composite_types.end();
+    }
+
+    clang::CodeGen::CodeGenModule *cgModule;
+    const llvm::TargetData *td;
+    const clang::SourceManager *srcManager;
+    // Hash of typenames to TypeMemoryLayout instances.
+    // One entry per struct/union/class in parsed C.
+    TypeMap composite_types;
+};
+
+class CMemoryLayout {
+private:
+    String *header_file;
+    RecordLocator astConsumer;
+
+public:
+    typedef enum {C, CXX} Language;
+    
+    CMemoryLayout(String *in_file) {
+        header_file = in_file;
+    }
+
+    ~CMemoryLayout() {}
+
+    int init(Language lang=C) {
+        clang::DiagnosticOptions diagnosticOptions;
+        clang::TextDiagnosticPrinter *pTextDiagnosticPrinter =
+		new clang::TextDiagnosticPrinter(
+			Verbose ? llvm::outs() : llvm::nulls(),
+                        diagnosticOptions);
+        pTextDiagnosticPrinter->setPrefix("(clang)");
+        clang::DiagnosticIDs *ids = new clang::DiagnosticIDs;
+	clang::Diagnostic diagnostic(
+            llvm::IntrusiveRefCntPtr<clang::DiagnosticIDs>(ids),
+            pTextDiagnosticPrinter);
+
+	clang::LangOptions langopt;
+        if (lang == CXX) {
+            clang::CompilerInvocation::setLangDefaults(langopt, clang::IK_CXX);
+        }
+
+        clang::FileSystemOptions fileSystemOptions;
+	clang::FileManager fileManager(fileSystemOptions);
+
+	clang::SourceManager sourceManager(diagnostic,fileManager);
+	clang::HeaderSearch headerSearch(fileManager);
+
+        if (!flasccSDKLocation) {
+            return EXIT_FAILURE;
+        }
+
+	llvm::StringRef sysroot(flasccSDKLocation);
+
+        if (Verbose) {
+            Printf(stdout, "Clang include directories:\n");
+            Printf(stdout, "%s (sysroot)\n", flasccSDKLocation);
+        }
+        
+        clang::HeaderSearchOptions headers(sysroot);
+        List *swig_include_dirs = Swig_add_directory(NULL);
+        Iterator i;
+        for (i = First(swig_include_dirs); i.item; i = Next(i)) {
+            String *path = i.item;
+            if (Verbose) {
+                Printf(stdout, "%s\n", path);
+            }
+            headers.AddPath(llvm::StringRef(Char(path)),
+                clang::frontend::Angled,
+                true, // user supplied
+                false, // not framework
+                false); // don't ignore sysroot
+        }
+
+	clang::TargetOptions targetOptions;
+	targetOptions.Triple = "avm2-";
+        //targetOptions.Triple = llvm::sys::getHostTriple();
+
+        LLVMInitializeAVM2ShimTargetInfo();
+        LLVMInitializeAVM2ShimTarget();
+
+        std::string errorStr;
+        
+        const llvm::Target *target = llvm::TargetRegistry::lookupTarget(
+            /*targetOptions.Triple*/"avm2-", errorStr);
+        if (!target) {
+            Printf(stderr, "Couldn't find LLVM target \"%s\", wrapper types "
+                " unavailable.", targetOptions.Triple.c_str());
+            return EXIT_FAILURE;
+        }
+	clang::TargetInfo *pTargetInfo = 
+		clang::TargetInfo::CreateTargetInfo(
+			diagnostic,
+			targetOptions);
+        
+        if (!pTargetInfo) {
+            Printf(stderr, "Couldn't find LLVM target info \"%s\", wrapper " 
+                "types  unavailable.", targetOptions.Triple.c_str());
+            return EXIT_FAILURE;
+        }
+
+        llvm::TargetMachine *tm = target->createTargetMachine(
+            "avm2-", "");
+
+        if (!tm) {
+            Printf(stderr, "Couldn't find LLVM target machine \"%s\", wrapper " 
+                "types  unavailable.", targetOptions.Triple.c_str());
+            return EXIT_FAILURE;
+        }
+
+        const llvm::TargetData *td = tm->getTargetData();
+        if (!td) {
+            Printf(stderr, "Couldn't find LLVM target data \"%s\", wrapper " 
+                "types  unavailable.", targetOptions.Triple.c_str());
+            return EXIT_FAILURE;
+        }
+
+        llvm::Module llvmModule("my module", llvm::getGlobalContext());
+
+        clang::TargetCXXABI cxxabi = pTargetInfo->getCXXABI();
+
+	clang::ApplyHeaderSearchOptions(
+		headerSearch,
+		headers,
+		langopt,
+		pTargetInfo->getTriple());
+
+	clang::Preprocessor preprocessor(
+		diagnostic,
+		langopt,
+		*pTargetInfo,
+		sourceManager,
+		headerSearch);
+
+	clang::PreprocessorOptions preprocessorOptions;
+	clang::FrontendOptions frontendOptions;
+	clang::InitializePreprocessor(
+		preprocessor,
+		preprocessorOptions,
+		headers,
+		frontendOptions);
+		
+	const clang::FileEntry *pFile = fileManager.getFile(Char(header_file));
+	if (!pFile) {
+            Printf(stderr, "Couldn't find source file \"%s\", wrapper " 
+                "types  unavailable.", header_file);
+            return EXIT_FAILURE;
+        }
+        
+        sourceManager.createMainFileID(pFile);
+        
+        const clang::TargetInfo &targetInfo = *pTargetInfo;
+        clang::IdentifierTable identifierTable(langopt);
+        clang::SelectorTable selectorTable;
+        clang::Builtin::Context builtinContext(targetInfo);
+        clang::ASTContext astContext(
+            langopt,
+            sourceManager,
+            targetInfo,
+            identifierTable,
+            selectorTable,
+            builtinContext,
+            0);
+
+        clang::CodeGenOptions codeGenOptions;
+        clang::CodeGen::CodeGenModule cgModule(astContext, codeGenOptions,
+            llvmModule, *td, diagnostic);
+
+        astConsumer.cgModule = &cgModule;
+        astConsumer.td = td;
+        astConsumer.srcManager = &sourceManager;
+
+        clang::Sema sema(
+            preprocessor,
+            astContext,
+            astConsumer);
+        sema.Initialize();
+
+        pTextDiagnosticPrinter->BeginSourceFile(langopt, &preprocessor);
+        clang::ParseAST(preprocessor, &astConsumer, astContext); 
+        pTextDiagnosticPrinter->EndSourceFile();
+        
+        return EXIT_SUCCESS;
+    }
+    
+    const TypeMemoryLayout *getMemoryLayout(String *type_name) {
+        llvm::StringRef type_name_str(Char(type_name));
+        llvm::StringMap<TypeMemoryLayout *> &map = 
+            astConsumer.composite_types;
+        if (map.find(type_name_str) == map.end()) {
+            return NULL;
+        } else {
+            return map[type_name_str];
+        }
+    }
+};
+
+}
+
+// typedef-safe versions of swig's isfunctionpointer and 
+// functionpointer_decompose utility functions
+static bool is_functionpointer(SwigType *t) {
+    if (SwigType_istypedef(t)) {
+        return is_functionpointer(SwigType_typedef_resolve_all(t));
+    } else {
+        return SwigType_isfunctionpointer(t);
+    }
+}
+
+struct functionpointer {
+    SwigType *ret_type;
+    List *parms;
+    // Note: ParmList is actually a hash, not a list. Therefore, this
+    // member is not interchangeable with 'parms', above.
+    ParmList *parmlist; 
+};
+
+static struct functionpointer functionpointer_decompose(SwigType *t) {
+    struct functionpointer ret;
+    if (SwigType_istypedef(t)) {
+        t = SwigType_typedef_resolve_all(t);
+    }
+    SwigType *args = SwigType_functionpointer_decompose(t);
+    ret.parms = SwigType_parmlist(args);
+    ret.parmlist = SwigType_function_parms(args, NIL);
+
+    // normalize argument list: '(void') -> '()'
+    if (Len(ret.parms) == 1 && SwigType_type(Getitem(ret.parms, 0)) == T_VOID) {
+        assert(ParmList_len(ret.parmlist) == 1);
+        Delete(ret.parmlist);
+        ret.parmlist = NIL;
+        Clear(ret.parms);
+    }
+    ret.ret_type = t;
+    return ret;
+}
+
+static String *function_decl(SwigType *ret_type, String *id, String *args) {
+    String *ret;
+    if (SwigType_isfunctionpointer(ret_type)) {
+        String *id_and_args = NewStringf("%s(%s)", id, args);
+        ret = SwigType_lstr(ret_type, id_and_args);
+        Delete(id_and_args);
+    } else {
+        String *decl = SwigType_lstr(ret_type, id);
+        ret = NewStringf("%s (%s)", decl, args);
+        Delete(decl);
+    }
+    return ret;
+}
+
+class AS3 : public Language {
+private:
+    String *package;
+
+    bool validASName(String *p) {
+        return p && Len(p) && !Strchr(p, ':');
+    }
+
+    String *getASOutput() {
+        if (getClassName()) {
+            return f_proxy_classes;
+        } else {
+            return f_func_class;
+        }
+    }
+
+    void emitASClassForCType(const TypeMemoryLayout &type, File *outfile) {
+        const String *class_name = getASTypeName(type.getTypeName());
+
+        // Class, static, and instance variables
+        Printf(outfile, "public class %s {\n", class_name);
+        Printf(outfile, "\tpublic static const size:int = %u;\n\n",
+            type.getTypeSize());
+        Printf(outfile, "\tprivate const _ba:ByteArray;\n");
+        Printf(outfile, "\tprivate const _offs:int;\n\n");
+        
+        // Constructor
+        Printf(outfile, 
+            "\tpublic function %s(ba:ByteArray = null, offs:int = 0) {\n",
+            class_name);
+        Printf(outfile, "\t\tif (!ba) {\n");
+        Printf(outfile, "\t\t\tba = new ByteArray();\n");
+        Printf(outfile, "\t\t\tba.endian = \"littleEndian\";\n");
+        Printf(outfile, "\t\t\tba.length = %u;\n", type.getTypeSize());
+        Printf(outfile, "\t\t}\n");
+        Printf(outfile, "\t\t_ba = ba;\n");
+        Printf(outfile, "\t\t_offs = offs;\n");
+        Printf(outfile, "\t}\n\n");
+       
+        // addressOf
+        Printf(outfile, "\tpublic function addressOf():int {\n");
+        Printf(outfile, "\t\timport C_Run.ram;\n");
+        Printf(outfile, "\t\tif (_ba != ram) {\n");
+        Printf(outfile, "\t\t\tthrow new Error(\"Cannot take address of object "
+            "not in domainMemory\");\n");
+        Printf(outfile, "\t\t}\n");
+        Printf(outfile, "\t\treturn _offs;\n");
+        Printf(outfile, "\t}\n\n");
+
+        // Getters and setters
+        int i;
+        for (i = 0; i < type.getNumMembers(); i++) {
+            const MemberDescription &mem = type.getMember(i);
+            const String *memname = mem.name;
+            unsigned offset = mem.offset;
+
+            Printf(outfile, "\tpublic function get %s():%s {\n", 
+                memname, mem.getASType());
+            if (mem.category == COMPOSITE) {
+                Printf(outfile, "\t\treturn new %s(_ba, _offs + %u);\n",
+                    mem.getASType(), mem.offset);
+            } else if (mem.category == ARRAY) {
+                Printf(outfile, "\t\tvar ret = new ByteArray();\n");
+                Printf(outfile, "\t\tret.endian = \"littleEndian\";\n");
+                Printf(outfile, "\t\t_ba.position = _offs + %u;\n", mem.offset);
+                Printf(outfile, "\t\t_ba.readBytes(ret, 0, %u);\n", mem.size);
+                Printf(outfile, "\t\treturn ret;\n");
+            } else {
+                Printf(outfile, "\t\t_ba.position = _offs + %u;\n", offset);
+                Printf(outfile, "\t\treturn _ba.%s();\n", 
+                        mem.getByteArrayReadMethod());
+            }
+            Printf(outfile, "\t}\n\n");
+
+            Printf(outfile, "\tpublic function set %s(v:%s):void {\n",
+                memname, mem.getASType());
+            if (mem.category == COMPOSITE) {
+                Printf(outfile, "\t\tv.write(_offs + %u, _ba);\n", mem.offset);
+            } else if (mem.category == ARRAY) {
+                Printf(outfile, "\t\tv.readBytes(_ba, _offs + %u, %u);\n", 
+                    mem.offset, mem.size);
+            } else {
+                Printf(outfile, "\t\t_ba.position = _offs + %u;\n", offset);
+                Printf(outfile, "\t\t_ba.%s(v);\n", 
+                    mem.getByteArrayWriteMethod());
+            }
+            
+            Printf(outfile, "\t}\n\n");
+        }
+
+        // read and write member functions
+        Printf(outfile, "\tpublic function read(ptr:int):void {\n");
+        Printf(outfile, "\t\timport C_Run.ram;\n");
+        Printf(outfile, "\t\t_ba.position = _offs;\n");
+        Printf(outfile, "\t\t_ba.readBytes(ram, ptr, size);\n");
+        Printf(outfile, "\t}\n\n");
+
+        Printf(outfile, 
+            "\tpublic function write(ptr:int, ba:ByteArray = null):void {\n");
+        Printf(outfile, "\t\timport C_Run.ram;\n");
+        Printf(outfile, "\t\tif (!ba) {\n");
+        Printf(outfile, "\t\t\tba = C_Run.ram;\n");
+        Printf(outfile, "\t\t}\n");
+        Printf(outfile, "\t\tba.position = ptr;\n");
+        Printf(outfile, "\t\tba.writeBytes(_ba, _offs, size);\n");
+        Printf(outfile, "\t}\n");
+        
+        Printf(outfile, "}\n\n");
+    }
+
+    String* MungeNSSeparator(String *s) {
+        String *str = NewString(s);
+        Replaceall(str, "::", "_");
+        return str;
+    }
+
+    /*
+     * Emit a C function that wraps an Actionscript Function and handles
+     * passing of its arguments and return value on the stack. We use this for
+     * creating C function pointers for Actionscript Functions.
+     *
+     * Adds the name of the wrapper function to the node as "wrap:funcptrwrap".
+     */
+    void emitFuncPtrWrapper(Node *n, Node *parent, File *outfile) {
+        String *name = MungeNSSeparator(Getattr(n, "name"));
+        List *parms;
+        SwigType *type = Getattr(n, "type");
+        SwigType *ret_type;
+
+        ret_type = Copy(type);
+        struct functionpointer fp = functionpointer_decompose(ret_type);
+        ret_type = fp.ret_type;
+        parms = fp.parms;
+
+        if (!parms) {
+            return;
+        }
+        
+        String *wrap_func = NewStringf("_wrap_%s_%s_func_ptr", 
+            MungeNSSeparator(Getattr(parent, "name")), name);
+
+        Setattr(n, "wrap:funcptrwrap", wrap_func);
+
+        // Emit C wrapper
+        Wrapper *f = NewWrapper();
+        String *ctypestr = SwigType_str(type, 0);
+        
+        String *c_args = NewString("");
+        String *as_args = NewString("");
+        Iterator i;
+       
+        Parm *p;
+        // Make sure that each C parameter has a name and the right type.
+        int c = 0;
+        for (p = fp.parmlist; p; p = nextSibling(p)) {
+            String *arg_name = Swig_cparm_name(p, c++);
+            SwigType *type = Getattr(p, "type");
+            Append(c_args, SwigType_str(type, arg_name));
+            Delete(arg_name);
+
+            // Turn references into pointers, as the rest of swig expects
+            if (SwigType_isreference(type)) {
+                Push(arg_name, "&");
+            }
+
+            if (nextSibling(p)) {
+                Append(c_args, ", ");
+            }
+        }
+
+        Swig_typemap_attach_parms("out", fp.parmlist, f);
+        // Emit conversion code for each Actionscript parameter
+        for (p = fp.parmlist, c = 0; p; p = Getattr(p, "tmap:out:next"), c++) {
+            bool next = Getattr(p, "tmap:out:next");
+            if (checkAttribute(p, "tmap:out:numinputs", "0")) {
+              continue;
+            }
+            SwigType *type = Getattr(p, "type");
+            assert(type);
+
+            String *arg_name = Getattr(p, "lname");
+            String *as_arg_name = Swig_cparm_name(NIL, c);
+            String *tp = Getattr(p, "tmap:out");
+
+            if (is_functionpointer(Getattr(p, "type"))) {
+                emitASFunctionWrapper(p, n, f_begin);
+                Replaceall(tp, "$wrapper_name", 
+                    Getattr(p, "wrap:Functionwrap"));
+            }
+
+            Replaceall(tp, "$result", as_arg_name);
+            Printf(f->code, "%s\n", tp);
+            Append(as_args, as_arg_name);
+            
+            Delete(as_arg_name);
+            Delete(arg_name);
+
+            if (next) {
+                Append(as_args, ", ");
+            }
+        }
+        
+        Printf(f->code, "inline_as3(\n\"");
+        if (Cmp(ret_type, "void")) {
+            Wrapper_add_localv(f, "result", SwigType_lstr(ret_type, "result"), 
+                NIL);
+            Printf(f->code, "var asresult = ");
+        }
+        Printf(f->code, "f(%s);\"\n", as_args);
+        Printf(f->code, ");\n");
+        Delete(as_args);
+
+        if (Cmp(ret_type, "void")) {
+            Swig_save("emitFuncPtrWrapper", n, "type", "tmap:in", NIL);
+            Setattr(n, "type", ret_type);
+            String *intm = Swig_typemap_lookup("in", n, "result", 0);
+            if (is_functionpointer(ret_type)) {
+                Node *retnode = NewHash();
+                Setattr(retnode, "type", ret_type);
+                emitFuncPtrWrapper(retnode, n, outfile);
+                Replaceall(intm, "$wrapper_name", 
+                    Getattr(retnode, "wrap:funcptrwrap"));
+                Delete(retnode);
+            }
+            Swig_restore(n);
+            Replaceall(intm, "$input", "asresult");
+            Printf(f->code, "%s\n", intm);
+            Printf(f->code, "    return result;\n");
+        }
+        
+        // Emit C wrapper
+        String *assig = NewStringf("public function %s(f:Function):void",
+            wrap_func);
+
+        String *sigattrib = NewStringf(
+            "__attribute__((annotate(\"as3sig:%s\")))", assig);
+        String *func_decl = function_decl(ret_type, wrap_func, c_args);
+        Printf(f->def, "%s\n%s {\n", sigattrib, func_decl);
+        Delete(func_decl);
+        Delete(c_args);
+        Delete(sigattrib);
+        Delete(assig);
+
+        Printf(f->code, "}\n");
+        Wrapper_print(f, outfile);
+        DelWrapper(f);
+    }
+
+    /*
+     * Emit C code for an Actionscript function that wraps a C function
+     * pointer so that it is callable from Actionscript.
+     *
+     * Adds the name of the wrapper function to the node as "wrap:Functionwrap".
+     */
+    void emitASFunctionWrapper(Node *n, Node *parent, File *outfile) {
+        String *name = MungeNSSeparator(Getattr(n, "name"));
+        ParmList *parms;
+        SwigType *type = Getattr(n, "type");
+        SwigType *ret_type;
+
+        ret_type = Copy(type);
+        struct functionpointer fp = functionpointer_decompose(ret_type);
+        ret_type = fp.ret_type;
+        parms = fp.parms;
+        
+        if (!parms) {
+            return;
+        }
+        
+        String *wrap_func = NewStringf("_wrap_%s_%s_Function", 
+            MungeNSSeparator(Getattr(parent, "name")), name);
+
+        Setattr(n, "wrap:Functionwrap", wrap_func);
+
+        // Emit C wrapper
+        Wrapper *f = NewWrapper();
+        
+        // Emit conversion code (from Actionscript to C)
+        Swig_save("as3", n, "parmstr", "parmnames", 
+                    "cleanup_code", "omitted_self", NIL);
+        emitWrapperParameters(n, f, fp.parmlist);
+        String *as_args = Getattr(n, "parmstr");
+        Swig_restore(n);
+
+        if (Len(as_args) > 0) {
+            Append(as_args, ", ");
+        }
+        Append(as_args, "funcPtrArg:int");
+       
+        Wrapper_add_localv(f, "funcPtr", SwigType_lstr(Getattr(n, "type"), 
+            "funcPtr"), NIL);
+
+        String *cresultline;
+        String *ccall = Swig_cfunction_call("funcPtr", fp.parmlist);
+        Swig_save("emitASFunctionWrapper", n, "type", "tmap:out", NIL);
+        Setattr(n, "type", ret_type);
+
+        if (Cmp(ret_type, "void")) {
+            Wrapper_add_localv(f, "result", SwigType_lstr(ret_type, "result"), 
+                NIL);
+            Printf(f->code, "inline_nonreentrant_as3(\"%%0 = funcPtrArg;\""
+                            " : \"=r\"(funcPtr));\n");
+            cresultline = Swig_cresult(ret_type, "result", ccall);
+            String *outtm = Swig_typemap_lookup("out", n, "result", 0);
+            Replaceall(outtm, "$result", "asresult");
+            if (is_functionpointer(ret_type)) {
+                Node *retnode = NewHash();
+                Setattr(retnode, "type", ret_type);
+                emitASFunctionWrapper(retnode, n, outfile);
+                Replaceall(outtm, "$wrapper_name", 
+                    Getattr(retnode, "wrap:Functionwrap"));
+                Delete(retnode);
+            }
+            Append(cresultline, "\n");
+            Append(cresultline, outtm);
+            Append(cresultline, "\nAS3_ReturnAS3Var(asresult);");
+        } else {
+            Printf(f->code, "__asm__ volatile(\"ESP = ebp; "
+                            "%%0 = funcPtrArg;\" : \"=r\"(funcPtr));\n");
+            cresultline = Copy(ccall);
+            Append(cresultline, ";");
+        }
+        Printf(f->code, "%s\n", cresultline);
+        Delete(ccall);
+        Delete(cresultline);
+        
+        String *as_ret_type;
+        as_ret_type = Swig_typemap_lookup("astype", n, "", 0);
+
+        // Emit AS wrapper
+        String *assig = NewStringf("public function %s(%s):%s",
+            wrap_func, as_args, as_ret_type);
+        
+        Swig_restore(n);
+        Delete(as_args);
+        
+        String *sigattrib = NewStringf(
+            "__attribute__((annotate(\"as3sig:%s\")))", assig);
+        Printf(f->def, "%s\nvoid %s() {\n", sigattrib, wrap_func);
+        Delete(sigattrib);
+        Delete(assig);
+
+        Printf(f->code, "}\n");
+        Wrapper_print(f, outfile);
+        DelWrapper(f);
+    
+    }
+
+    void emitWrapperParameters(Node *n, Wrapper *f, ParmList *parms) {
+        bool in_class = getClassName();
+        emit_parameter_variables(parms, f);
+        emit_attach_parmmaps(parms, f);
+        Swig_typemap_attach_parms("astype", parms, f);
+        
+        // Convert Actionscript parameters to C
+        String *parmstr = NewString("");
+        String *parmnames = NewString("");
+        String *cleanup_code = NewString("");
+        Parm *p;
+        bool omitted_self = false;
+        for (p = parms; p; p = Getattr(p, "tmap:in:next")) {
+            bool next = Getattr(p, "tmap:in:next");
+            if (checkAttribute(p, "tmap:in:numinputs", "0")) {
+              continue;
+            }
+
+            String *parmname = Getattr(p, "name");
+            parmname  = Swig_name_make(p, 0, Getattr(p, "name"), 0, 0);
+            if (!validASName(parmname)) {
+                parmname = Getattr(p, "lname");
+            }
+            
+            // The 'this' pointer is special -- replace it with the
+            // proxy class memeber that points to the C instance (swigCPtr).
+            if (in_class && !is_static && !Cmp("self", parmname)) {
+                Append(parmnames, "swigCPtr");
+                omitted_self = true;
+            } else {
+                Append(parmstr, parmname);
+                String *astype = Getattr(p, "tmap:astype");
+                if (astype) {
+                    Append(parmstr, ":");
+                    Append(parmstr, astype);
+                }
+                if (next) {
+                    Append(parmstr, ", ");
+                }
+                Append(parmnames, parmname);
+            }
+
+            if (next) {
+                Append(parmnames, ", ");
+            }
+           
+            String *tp = Getattr(p, "tmap:in");
+            Replaceall(tp, "$input", parmname);
+            if (is_functionpointer(Getattr(p, "type"))) {
+                emitFuncPtrWrapper(p, n, f_begin);
+                Replaceall(tp, "$wrapper_name", Getattr(p, "wrap:funcptrwrap"));
+            }
+            Printf(f->code, "%s\n", tp); 
+            
+            String *parm_cleanup = Getattr(p, "tmap:freearg");
+            if (parm_cleanup) {
+                Printf(cleanup_code, "%s\n", parm_cleanup);
+            }
+        }
+
+        if (omitted_self) {
+            Setattr(n, "omitted_self", "1");
+        }
+        Setattr(n, "parmstr", parmstr);
+        Setattr(n, "parmnames", parmnames);
+        Setattr(n, "cleanup_code", cleanup_code);
+    }
+
+    void emitASType(String *outtp, Node *n) {
+        SwigType *type = Getattr(n, "type");
+        String *resolved_typename = SwigType_typedef_resolve_all(type);
+        Symtab *symtab = Getattr(n, "sym:symtab");
+        Node *typenode = Swig_symbol_clookup(resolved_typename, symtab);
+        if (typenode) {
+            Replaceall(outtp, "$astype", Getattr(typenode, "sym:name"));
+        }
+    }
+
+public:
+
+    AS3():package(NIL) {}
+
+    virtual void main(int argc, char **argv) {
+        SWIG_library_directory("as3");
+        for (int i = 1; i < argc; i++) {
+            if (argv[i]) {
+                if (strcmp(argv[i], "-package") == 0) {
+                    if (argv[i + 1]) {
+                        package = NewString("");
+                        Printf(package, argv[i + 1]);
+                        if (Len(package) == 0) {
+                            Delete(package);
+                            package = NIL;
+                        }
+                        Swig_mark_arg(i);
+                        Swig_mark_arg(i + 1);
+                        i++;
+                    } else {
+                        Swig_arg_error();
+                    }
+                }
+            }
+        }
+        Preprocessor_define("SWIGAS3 1", 0);
+        SWIG_config_file("as3.swg");
+        SWIG_typemap_lang("as3");
+    }
+
+    virtual int top(Node *n) {
+        if (!CPlusPlus) {
+            mem_layout = new CMemoryLayout(input_file);
+            // Always C for the time being
+            CMemoryLayout::Language lang = 
+                CPlusPlus ? CMemoryLayout::CXX : CMemoryLayout::C;
+            mem_layout->init(lang);
+        }
+       
+        is_variable = false;
+        is_static = false;
+        is_constructor = false;
+        is_destructor = false;
+        class_extends = false;
+
+        String *module_name = NewStringf("%s", Getattr(n, "name"));
+        String *as_class = NewStringf("%s%s.as", SWIG_output_directory(),
+             module_name);
+        
+        String *outfile = Getattr(n, "outfile");
+        if (!outfile) {
+            Printf(stderr, "Unable to determine outfile\n");
+            SWIG_exit(EXIT_FAILURE);
+        }
+
+
+        open_output_file(&f_module, as_class);
+        open_output_file(&f_begin, outfile);
+        Swig_register_filebyname("header", f_begin);
+        Swig_register_filebyname("runtime", f_begin);
+        Swig_register_filebyname("asruntime", f_module);
+
+        Swig_banner_target_lang(f_module, "//");
+        Swig_banner(f_begin);
+
+        f_func_class = NewString("");
+        Printf(f_func_class, "public class %s {\n", module_name);
+        f_proxy_classes = NewString("");
+        f_ctype_class = NewString("");
+
+        Language::top(n);
+
+        Printf(f_func_class, "}\n");
+        if (package) {
+            Printf(f_module, "package %s{\n", package);
+        } else{
+            Printf(f_module, "package {\n");
+        }
+        Printf(f_module, "import C_Run.*;\n");
+        Printf(f_module, "import com.adobe.flascc.swig.*;\n");
+        Printf(f_module, "import flash.utils.ByteArray;\n\n");
+        Printf(f_module, "%s", f_ctype_class);
+        Printf(f_module, "%s", f_func_class);
+        Printf(f_module, "%s", f_proxy_classes);
+        Printf(f_module, "} /* package */\n");
+
+        // Changed 02.05.14. CsA: SWIG 3.0.0 Compatibility
+        Delete(f_module);
+        Delete(f_begin);        
+        //Close(f_module);
+        //Close(f_begin);
+        Delete(f_func_class);
+        Delete(module_name);
+        Delete(as_class);
+
+        return SWIG_OK;
+    }
+
+    virtual int functionWrapper(Node *n) {
+        String *name = Getattr(n, "sym:name");
+        ParmList *parms = Getattr(n, "parms");
+        String *glue_func = Swig_name_wrapper(name);
+        bool in_class = getClassName();
+
+        Setattr(n, "wrap:name", glue_func);
+
+        if (is_variable) {
+            String *variable_name;
+            if (getClassName()) {
+                variable_name = Swig_name_member(
+                    0, getClassPrefix(), sym_name);
+            } else { // variables that aren't class memebers
+                variable_name = sym_name;
+            }
+            
+            bool is_getter = Cmp(name,
+                Swig_name_set(0, variable_name)) != 0;
+            // TODO: name leaks after this copy
+            if (is_getter) {
+                name = NewStringf("get %s", sym_name);
+            } else {
+                name = NewStringf("set %s", sym_name);
+            }
+        } else if (is_destructor) {
+            name = NewString("destroy"); // TODO: leaks?
+        } else if (is_constructor) {
+            name = NewString("create"); // TODO: leaks?
+        } else if (in_class) {
+            // Don't prepend the class name to this method, just use the
+            // the same name as in C.
+            name = sym_name;
+        }
+        
+        // Emit C wrapper
+        Wrapper *f = NewWrapper();
+        Swig_save("as3", n, "parmstr", "parmnames", 
+                    "cleanup_code", "omitted_self", NIL);
+        emitWrapperParameters(n, f, parms);
+        String *parmstr = Getattr(n, "parmstr");
+        String *parmnames = Getattr(n, "parmnames");
+        String *cleanup_code = Getattr(n, "cleanup_code");
+        String *omitted_self = Getattr(n, "omitted_self");
+        Swig_restore(n);
+       
+        // TODO: remove this hack
+        // Need the list of parameters both with and without the implied
+        // 'this' pointer for different parts of code gen.
+        String *parm_with_self_str;
+        if (omitted_self) {
+            parm_with_self_str = NewStringf("self%s%s", 
+            (Len(parmstr) > 0) ? ", " : "", parmstr);
+        } else {
+            parm_with_self_str = Copy(parmstr);
+        }
+        
+        // Determine Actionscript return value from C return value
+        SwigType *type = Getattr(n, "type");
+        String *ctypestr = SwigType_str(type, 0);
+        String *asretstr, *asretstat;
+        if (Cmp(ctypestr, "void")) {
+            Wrapper_add_localv(f, "result", SwigType_lstr(type, "result"), 
+                NIL);
+        }
+        
+        asretstr = Swig_typemap_lookup("astype", n, "", 0);
+        if (is_constructor) {
+            asretstr = NewStringf(":%s", class_sym_name);
+        } else if (asretstr) {
+            asretstr = NewStringf(":%s", asretstr);
+        } else {
+            asretstr = NewString(":*");
+        }
+
+        if (Cmp(":void", asretstr)) {
+            asretstat = NewStringf("return ");
+        } else {
+            asretstat = NewString("");
+        }
+
+        // Emit Actionscript wrapper, which calls the C wrapper
+        
+        // The signature of the Actionscript function available to the user.
+        String *static_str = NewString(
+            (is_static || is_constructor || !in_class) ? "static " : "");
+        String *override_str = NewString(
+            !Getattr(n, "feature:as3:suppressoverride") && (Getattr(n, "override") || (is_destructor && class_extends)) ? 
+                "override " : "");
+        String *assig = NewStringf("%spublic %sfunction %s(%s)%s",
+            override_str, static_str, name, parmstr, asretstr);
+        Delete(static_str);
+        Delete(override_str);
+
+        // The Actionscript signature of the C wrapper function
+        // (goes in as3sig attribute).
+        String *wassig = NewStringf("public function %s(%s)%s",
+            glue_func, parm_with_self_str, 
+            (is_constructor) ? ":int" : asretstr);
+        Delete(asretstr);
+        Delete(parm_with_self_str);
+
+        String *as_out = getASOutput();
+
+        Printf(as_out, "\t%s {\n", assig);
+        if (is_constructor) {
+            // TODO: should this go into a typemap?
+            Printf(as_out, "\t\tvar obj = new %s();\n", class_sym_name);
+            Printf(as_out, "\t\tobj.swigCPtr = %s(%s);\n", glue_func,
+                parmnames);
+            Printf(as_out, "\t\treturn obj;\n");
+        } else {
+            Printf(as_out, "\t\t%s%s(%s);\n", asretstat, glue_func, parmnames);
+        }
+        Printf(as_out, "\t}\n\n");
+        
+        Delete(asretstat);
+        Delete(parmnames);
+        Delete(parmstr);
+
+        String *as3imports = Getattr(n, "feature:as3:import");
+        std::string importstr;
+        if(as3imports) {
+            char *c = Char(as3imports);
+            char *e = NULL;
+            while((e = strchr(c, ',')) != NULL) {
+                *e = 0;
+                importstr += ", annotate(\"as3import:" + std::string(c) + "\")";
+                c = e+1;
+            }
+            importstr += ", annotate(\"as3import:" + std::string(c) + "\")";
+        }
+
+        String *sigattrib = NewStringf(
+            "__attribute__((annotate(\"as3sig:%s\")%s))", wassig, importstr.c_str());
+        Printf(f->def, "%s\nvoid %s() {\n", sigattrib, glue_func);
+        Delete(sigattrib);
+        Delete(assig);
+        Delete(wassig);
+
+        Printf(f->code, "%s", emit_action(n));
+        
+        Parm *p;
+        /* Insert argument output code */
+        for (p = parms; p;) {
+            String *tm;
+            if ((tm = Getattr(p, "tmap:argout"))) {
+                Replaceall(tm, "$result", "asresult");
+                Replaceall(tm, "$input", Getattr(p, "emit:input"));
+                Printv(f->code, tm, "\n", NIL);
+                p = Getattr(p, "tmap:argout:next");
+            } else {
+                p = nextSibling(p);
+            }
+        }
+        
+        Printf(f->code, "%s", cleanup_code);
+        Delete(cleanup_code);
+        
+        String *rettp = Swig_typemap_lookup("asreturn", n, "", f);
+        String *ret_val;
+        String *outtp = Swig_typemap_lookup("out", n, "result", f);
+        if (is_functionpointer(type)) {
+            emitASFunctionWrapper(n, n, f_begin);
+            Replaceall(outtp, "$wrapper_name", 
+                    Getattr(n, "wrap:Functionwrap"));
+        }
+        emitASType(outtp, n);
+
+        Replaceall(outtp, "$result", "asresult");
+        Printf(f->code, "%s\n", outtp);
+        ret_val = NewString("asresult");
+        Replaceall(rettp, "$input", ret_val);
+        Delete(ret_val);
+        
+        Printf(f->code, "%s\n", rettp);
+        Printf(f->code, "}\n");
+        Wrapper_print(f, f_begin);
+
+        DelWrapper(f);
+        Delete(ctypestr);
+        Delete(glue_func);
+        return SWIG_OK;
+    }
+
+    /*
+     * Constants turn into Actionscript getters that return the constant
+     * value from C.
+     */
+    virtual int constantWrapper(Node *n) {
+        SwigType *type = Getattr(n, "type");
+        String *astype = Swig_typemap_lookup("astype", n, "", 0);
+        ParmList *parms = Getattr(n, "parms");
+        
+
+        Wrapper *f = NewWrapper();
+        emit_parameter_variables(parms, f);
+        emit_attach_parmmaps(parms, f);
+        Swig_typemap_attach_parms("astype", parms, f);
+        
+        String *name;
+        if (getClassName()) {
+            name = sym_name;
+        } else {
+            name = Getattr(n, "sym:name");
+        }
+
+        String *glue_func = Swig_name_wrapper(name);
+        Setattr(n, "wrap:name", glue_func);
+        String *ctypestr = SwigType_str(type, 0);
+        
+        // Emit Actionscript getter
+        String *as_out = getASOutput();
+        
+        Printf(as_out, "\tpublic static function get %s():%s{\n",
+            name, astype);
+        Printf(as_out, "\t\treturn %s();\n", glue_func);
+        Printf(as_out, "\t}\n\n");
+
+        // Emit C function (just returns the value of the constant)
+        String *wassig = NewStringf("public function %s(%s):%s",
+            glue_func, "", astype);
+        String *sigattrib = NewStringf(
+            "__attribute__((annotate(\"as3sig:%s\")))", wassig);
+        Printf(f->def, "%s\nvoid %s() {\n", sigattrib, glue_func);
+        Wrapper_add_localv(f, "result", SwigType_lstr(type, "result"), NIL);
+
+        // Add the stripped quotes back in
+        String *new_value = NewString("");
+        if (SwigType_type(type) == T_STRING) {
+          Printf(new_value, "\"%s\"", Copy(Getattr(n, "value")));
+          Setattr(n, "value", new_value);
+        } else if (SwigType_type(type) == T_CHAR) {
+          Printf(new_value, "\'%s\'", Copy(Getattr(n, "value")));
+          Setattr(n, "value", new_value);
+        }
+
+        Printf(f->code, "  result = %s;\n", Getattr(n, "value"));
+        
+        String *outtp = Swig_typemap_lookup("out", n, "result", f);
+        if (is_functionpointer(type)) {
+            emitASFunctionWrapper(n, n, f_begin);
+            Replaceall(outtp, "$wrapper_name", 
+                Getattr(n, "wrap:Functionwrap"));
+        }
+        Replaceall(outtp, "$result", "asresult");
+        emitASType(outtp, n);
+        Printf(f->code, "%s\n", outtp);
+
+        String *rettp = Swig_typemap_lookup("asreturn", n, "", f);
+        Replaceall(rettp, "$input", "asresult");
+        Printf(f->code, "%s\n", rettp);
+
+        Printf(f->code, "}\n");
+        Wrapper_print(f, f_begin);
+
+        Delete(wassig);
+        Delete(sigattrib);
+        Delete(ctypestr);
+        DelWrapper(f);
+        Delete(glue_func);
+
+        return SWIG_OK;
+    }
+
+    void swigClassHandler(Node *n) {
+        class_sym_name = Copy(Getattr(n, "sym:name"));
+        
+        // Check for inheritance
+        String *extend = NewString("");
+        List *baselist = Getattr(n, "bases");
+        if (baselist) {
+            Iterator base = First(baselist);
+            if (base.item) {
+                Append(extend, " extends ");
+                Append(extend, Getattr(base.item, "sym:name"));
+                class_extends = true;
+            }
+            for (base = Next(base); base.item; base = Next(base)) {
+                Printf(stderr, "Ignoring multiple inheritance of %s\n",
+                    Getattr(base.item, "name"));
+            }
+        }
+        
+        Printf(f_proxy_classes, "\npublic class %s%s {\n", class_sym_name, 
+            extend);
+        Delete(extend);
+
+        if (!class_extends) {
+            Printf(f_proxy_classes, "\tpublic var swigCPtr:int;\n");
+        }
+        Language::classHandler(n);
+        Printf(f_proxy_classes, "}\n\n");
+        class_extends = false;
+        Delete(class_sym_name);
+        class_sym_name = NIL;
+    }
+    
+    virtual int classHandler(Node *n) {
+        String *name = Getattr(n, "name");
+        
+        if (CPlusPlus) {
+            swigClassHandler(n);
+        } else {
+            const TypeMemoryLayout *type_layout = 
+                mem_layout->getMemoryLayout(name);
+            if (type_layout) {
+                emitASClassForCType(*type_layout, f_ctype_class);
+            } else {
+                Printf(stderr, "didn't find type info for %s\n", name);
+                swigClassHandler(n);
+            }
+        }
+
+        return SWIG_OK;
+    }
+
+    virtual int membervariableHandler(Node *n) {
+        is_variable = true;
+        sym_name = Getattr(n, "sym:name");
+        Language::membervariableHandler(n);
+        sym_name = NIL;
+        is_variable = false;
+        return SWIG_OK;
+    }
+
+    virtual int staticmembervariableHandler(Node *n) {
+        is_variable = true;
+        is_static = true;
+        sym_name = Getattr(n, "sym:name");
+        Language::staticmembervariableHandler(n);
+        sym_name = NIL;
+        is_static = false;
+        is_variable = false;
+        return SWIG_OK;
+    }
+    
+    virtual int globalvariableHandler(Node *n) {
+        is_variable = true;
+        sym_name = Getattr(n, "sym:name");
+        Language::globalvariableHandler(n);
+        sym_name = NIL;
+        is_variable = false;
+        return SWIG_OK;
+    }
+
+    virtual int constructorHandler(Node *n) {
+        is_constructor = true;
+        Language::constructorHandler(n);
+        is_constructor = false;
+        return SWIG_OK;
+    }
+    
+    virtual int destructorHandler(Node *n) {
+        is_destructor = true;
+        sym_name = Getattr(n, "sym:name");
+        Language::destructorHandler(n);
+        sym_name = NIL;
+        is_destructor = false;
+        return SWIG_OK;
+    }
+
+    virtual int enumvalueDeclaration(Node *n) {
+        sym_name = Getattr(n, "sym:name");
+        Language::enumvalueDeclaration(n);
+        sym_name = NIL;
+        return SWIG_OK;
+    }
+    
+    virtual int staticmemberfunctionHandler(Node *n) {
+        is_static = true;
+        sym_name = Getattr(n, "sym:name");
+        Language::staticmemberfunctionHandler(n);
+        sym_name = NIL;
+        is_static = false;
+        return SWIG_OK;
+    }
+    
+    virtual int memberfunctionHandler(Node *n) {
+        sym_name = Getattr(n, "sym:name");
+        Language::memberfunctionHandler(n);
+        sym_name = NIL;
+        return SWIG_OK;
+    }
+   
+    // TODO: fix the variable naming scheme here
+private:
+    File *f_module;
+    File *f_begin;
+    String *f_func_class;
+    String *f_proxy_classes;
+    String *f_ctype_class;
+    CMemoryLayout *mem_layout;
+    String *sym_name;
+    String *class_sym_name;
+    bool is_variable;
+    bool is_static;
+    bool is_constructor;
+    bool is_destructor;
+    bool class_extends;
+
+    void open_output_file(File **file, String *name) {
+        *file = NewFile(name, "w", SWIG_output_files());
+        if (!*file) {
+            Printf(stderr, "couldn't open output file %s: ", name);
+            perror("");
+            SWIG_exit(EXIT_FAILURE);
+        }
+    }
+};
+
+extern "C" Language *
+swig_as3(void) {
+    return new AS3();
+}
+
diff -rupN swig-3.0.0.orig/Source/Modules/main.cxx swig-3.0.0/Source/Modules/main.cxx
--- swig-3.0.0.orig/Source/Modules/main.cxx	2014-03-17 01:49:54.000000000 +0400
+++ swig-3.0.0/Source/Modules/main.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -11,6 +11,11 @@
  * Main entry point to the SWIG core.
  * ----------------------------------------------------------------------------- */
 
+// AVM2 AS3 PATCH START
+// for setting swiglib directory
+#include "SetAlchemySDKLocation.c"
+// AVM2 AS3 PATCH END
+
 #include "swigconfig.h"
 
 #if defined(_WIN32)
@@ -37,6 +42,10 @@ int AddExtern = 0;
 int NoExcept = 0;
 int SwigRuntime = 0;		// 0 = no option, 1 = -runtime, 2 = -noruntime
 
+// AVM2 AS3 PATCH START
+char *flasccSDKLocation = 0;
+// AVM2 AS3 PATCH END
+
 /* Suppress warning messages for private inheritance, preprocessor evaluation etc...
    WARN_PP_EVALUATION            202
    WARN_PARSE_PRIVATE_INHERIT    309
@@ -905,10 +914,15 @@ int SWIG_main(int argc, char *argv[], La
   ignore_nested_classes = l->nestedClassesSupport() == Language::NCS_Unknown ? 1 : 0;
 
   // Create Library search directories
+ 
+  // AVM2 AS3 PATCH START
+  // Set flascc SDK directory  
+  flasccSDKLocation = SetFlasccSDKLocation("/../..");
+  // AVM2 AS3 PATCH END
 
   // Check for SWIG_LIB environment variable
   if ((c = getenv("SWIG_LIB")) == (char *) 0) {
-#if defined(_WIN32)
+#if 0 //defined(_WIN32)
     char buf[MAX_PATH];
     char *p;
     if (!(GetModuleFileName(0, buf, MAX_PATH) == 0 || (p = strrchr(buf, '\\')) == 0)) {
@@ -920,7 +934,13 @@ int SWIG_main(int argc, char *argv[], La
     if (Len(SWIG_LIB_WIN_UNIX) > 0)
       SwigLibWinUnix = NewString(SWIG_LIB_WIN_UNIX); // Unix installation path using a drive letter (for msys/mingw)
 #else
-    SwigLib = NewString(SWIG_LIB);
+    // AVM2 AS3 PATCH START
+    //SwigLib = NewString(SWIG_LIB);
+    String *alcSDK = NewString(flasccSDKLocation);
+    Append(alcSDK, "/usr/share/swig/3.0.0/");
+    SwigLib = Swig_copy_string(Char(alcSDK));
+    Delete(alcSDK);
+    // AVM2 AS3 PATCH END
 #endif
   } else {
     SwigLib = NewString(c);
diff -rupN swig-3.0.0.orig/Source/Modules/swigmain.cxx swig-3.0.0/Source/Modules/swigmain.cxx
--- swig-3.0.0.orig/Source/Modules/swigmain.cxx	2014-03-17 01:49:54.000000000 +0400
+++ swig-3.0.0/Source/Modules/swigmain.cxx	2014-10-11 22:09:36.000000000 +0400
@@ -51,6 +51,7 @@ extern "C" {
   Language *swig_r(void);
   Language *swig_go(void);
   Language *swig_d(void);
+  Language *swig_as3(void);
 }
 
 struct swig_module {
@@ -65,6 +66,7 @@ struct swig_module {
 
 static swig_module modules[] = {
   {"-allegrocl", swig_allegrocl, "ALLEGROCL"},
+  {"-as3", swig_as3, "AS3"},
   {"-chicken", swig_chicken, "CHICKEN"},
   {"-clisp", swig_clisp, "CLISP"},
   {"-cffi", swig_cffi, "CFFI"},
diff -rupN swig-3.0.0.orig/configure swig-3.0.0/configure
--- swig-3.0.0.orig/configure	2014-03-17 02:06:28.000000000 +0400
+++ swig-3.0.0/configure	2014-10-11 22:09:36.000000000 +0400
@@ -612,6 +612,7 @@ swig_lib
 ac_aux_dir
 EXTRA_CLEAN
 ROOT_DIR
+SKIP_AS3
 SKIP_ANDROID
 SKIP_GCJ
 SKIP_D
@@ -11514,8 +11515,9 @@ if test -z "$ANDROID" || test -z "$ADB" 
     SKIP_ANDROID="1"
 fi
 
-
-
+# AVM2 AS3 PATCH START
+SKIP_AS3= # TODO: never skipped
+# AVM2 AS3 PATCH END
 
 #----------------------------------------------------------------
 # Miscellaneous
