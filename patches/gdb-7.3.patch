diff -rupN gdb-7.3.orig/bfd/Makefile.in gdb-7.3/bfd/Makefile.in
--- gdb-7.3.orig/bfd/Makefile.in	2010-12-04 16:00:35.000000000 +0300
+++ gdb-7.3/bfd/Makefile.in	2014-10-11 21:51:26.000000000 +0400
@@ -323,7 +323,7 @@ ACLOCAL_AMFLAGS = -I . -I .. -I ../confi
 # RELEASE=y
 INCDIR = $(srcdir)/../include
 CSEARCH = -I. -I$(srcdir) -I$(INCDIR)
-SUBDIRS = doc po
+SUBDIRS = 
 bfddocdir = doc
 libbfd_la_LDFLAGS = $(am__append_1) -release `cat libtool-soversion` \
 	@SHARED_LDFLAGS@ $(am__empty)
diff -rupN gdb-7.3.orig/bfd/archures.c gdb-7.3/bfd/archures.c
--- gdb-7.3.orig/bfd/archures.c	2011-03-22 21:10:41.000000000 +0300
+++ gdb-7.3/bfd/archures.c	2014-10-11 21:51:26.000000000 +0400
@@ -437,6 +437,7 @@ DESCRIPTION
 .  bfd_arch_lm32,      {* Lattice Mico32 *}
 .#define bfd_mach_lm32      1
 .  bfd_arch_microblaze,{* Xilinx MicroBlaze. *}
+.  bfd_arch_avm2,{* Adobe AVM2. *}
 .  bfd_arch_last
 .  };
 */
@@ -478,6 +479,7 @@ DESCRIPTION
 extern const bfd_arch_info_type bfd_alpha_arch;
 extern const bfd_arch_info_type bfd_arc_arch;
 extern const bfd_arch_info_type bfd_arm_arch;
+extern const bfd_arch_info_type bfd_avm2_arch;
 extern const bfd_arch_info_type bfd_avr_arch;
 extern const bfd_arch_info_type bfd_bfin_arch;
 extern const bfd_arch_info_type bfd_cr16_arch;
@@ -555,6 +557,7 @@ static const bfd_arch_info_type * const 
     &bfd_alpha_arch,
     &bfd_arc_arch,
     &bfd_arm_arch,
+    &bfd_avm2_arch,
     &bfd_avr_arch,
     &bfd_bfin_arch,
     &bfd_cr16_arch,
diff -rupN gdb-7.3.orig/bfd/bfd-in2.h gdb-7.3/bfd/bfd-in2.h
--- gdb-7.3.orig/bfd/bfd-in2.h	2011-03-31 12:58:19.000000000 +0400
+++ gdb-7.3/bfd/bfd-in2.h	2014-10-11 21:51:26.000000000 +0400
@@ -2124,6 +2124,7 @@ enum bfd_architecture
   bfd_arch_lm32,      /* Lattice Mico32 */
 #define bfd_mach_lm32      1
   bfd_arch_microblaze,/* Xilinx MicroBlaze. */
+  bfd_arch_avm2,/* Adobe AVM2. */
   bfd_arch_last
   };
 
diff -rupN gdb-7.3.orig/bfd/bfdio.c gdb-7.3/bfd/bfdio.c
--- gdb-7.3.orig/bfd/bfdio.c	2010-06-09 17:28:31.000000000 +0400
+++ gdb-7.3/bfd/bfdio.c	2014-10-11 21:51:26.000000000 +0400
@@ -577,7 +577,7 @@ memory_bstat (bfd *abfd, struct stat *st
 {
   struct bfd_in_memory *bim = (struct bfd_in_memory *) abfd->iostream;
 
-  memset (statbuf, 0, sizeof (statbuf));
+  memset (statbuf, 0, sizeof (*statbuf));
   statbuf->st_size = bim->size;
 
   return 0;
diff -rupN gdb-7.3.orig/bfd/config.bfd gdb-7.3/bfd/config.bfd
--- gdb-7.3.orig/bfd/config.bfd	2011-03-31 12:58:20.000000000 +0400
+++ gdb-7.3/bfd/config.bfd	2014-10-11 21:51:26.000000000 +0400
@@ -73,6 +73,7 @@ case "${targ_cpu}" in
 alpha*)		 targ_archs=bfd_alpha_arch ;;
 am34*|am33_2.0*) targ_archs=bfd_mn10300_arch ;;
 arm*)		 targ_archs=bfd_arm_arch ;;
+avm2*)		 targ_archs=bfd_avm2_arch ;;
 bfin*)		 targ_archs=bfd_bfin_arch ;;
 c30*)		 targ_archs=bfd_tic30_arch ;;
 c4x*)		 targ_archs=bfd_tic4x_arch ;;
@@ -216,6 +217,11 @@ case "${targ}" in
     targ_selvecs=bfd_elf32_bigarc_vec
     ;;
 
+  avm2-*)
+    targ_defvec=bfd_avm2_vec
+    targ_selvecs="bfd_avm2_vec"
+    ;;
+
   armeb-*-netbsdelf*)
     targ_defvec=bfd_elf32_bigarm_vec
     targ_selvecs="bfd_elf32_littlearm_vec armnetbsd_vec"
diff -rupN gdb-7.3.orig/bfd/configure gdb-7.3/bfd/configure
--- gdb-7.3.orig/bfd/configure	2011-03-28 15:18:25.000000000 +0400
+++ gdb-7.3/bfd/configure	2014-10-11 21:51:26.000000000 +0400
@@ -15032,6 +15032,7 @@ do
     bfd_pei_ia64_vec)		tb="$tb pei-ia64.lo pepigen.lo cofflink.lo"; target_size=64 ;;
     bfd_elf32_am33lin_vec)	tb="$tb elf32-am33lin.lo elf32.lo $elf" ;;
     bfd_elf32_avr_vec)		tb="$tb elf32-avr.lo elf32.lo $elf" ;;
+    bfd_avm2_vec)               tb="$tb elf32.lo $elf" ;;
     bfd_elf32_bfin_vec)		tb="$tb elf32-bfin.lo elf32.lo $elf" ;;
     bfd_elf32_bfinfdpic_vec)	tb="$tb elf32-bfin.lo elf32.lo $elf" ;;
     bfd_elf32_big_generic_vec) 	tb="$tb elf32-gen.lo elf32.lo $elf" ;;
diff -rupN gdb-7.3.orig/bfd/configure.host gdb-7.3/bfd/configure.host
--- gdb-7.3.orig/bfd/configure.host	2010-12-31 14:00:52.000000000 +0300
+++ gdb-7.3/bfd/configure.host	2014-10-11 21:51:26.000000000 +0400
@@ -35,6 +35,8 @@ ia64-*-hpux*)		HDEFINES=-D_LARGEFILE64_S
 			host64=true;;
 ia64-*-*)		host64=true;;
 
+avm2-*)		;;
+
 # Workaround for limitations on win9x where file contents are
 # not zero'd out if you seek past the end and then write.
 i[3-7]86-*-mingw32*)	HDEFINES=-D__USE_MINGW_FSEEK;;
diff -rupN gdb-7.3.orig/bfd/cpu-avm2.c gdb-7.3/bfd/cpu-avm2.c
--- gdb-7.3.orig/bfd/cpu-avm2.c	1970-01-01 03:00:00.000000000 +0300
+++ gdb-7.3/bfd/cpu-avm2.c	2014-10-11 21:51:26.000000000 +0400
@@ -0,0 +1,430 @@
+/* BFD support for the AVM2 architecture.
+   Copyright 1992, 1994, 1995, 1996, 1998, 2000, 2001, 2002, 2004, 2005,
+   2007, 2009, 2010, 2011
+   Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+
+const bfd_arch_info_type bfd_avm2_arch =
+{
+  32,	/* 32 bits in a word */
+  32,	/* 32 bits in an address */
+  8,	/* 8 bits in a byte */
+  bfd_arch_avm2,
+  0,
+  "avm2",
+  "avm2",
+  3,
+  TRUE,
+  bfd_default_compatible,
+  bfd_default_scan,
+  0
+};
+
+
+//extern const bfd_target bfd_avm2_vec;
+
+#define TARGET_LITTLE_SYM		bfd_avm2_vec
+#define TARGET_LITTLE_NAME		"avm2"
+#define ELF_ARCH			bfd_arch_avm2
+#define ELF_TARGET_ID			GENERIC_ELF_DATA
+#define ELF_MACHINE_CODE		EM_386 // TODO: change this?
+#define ELF_MAXPAGESIZE			0x1000
+
+#define elf_backend_can_gc_sections	1
+#define elf_backend_can_refcount	1
+#define elf_backend_want_got_plt	1
+#define elf_backend_plt_readonly	1
+#define elf_backend_want_plt_sym	0
+#define elf_backend_got_header_size	12
+
+
+#include "elf/i386.h"
+#define bfd_elf32_bfd_reloc_type_lookup	      elf_i386_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup	      elf_i386_reloc_name_lookup
+
+static reloc_howto_type elf_howto_table[]=
+{
+  HOWTO(R_386_NONE, 0, 0, 0, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_NONE",
+	TRUE, 0x00000000, 0x00000000, FALSE),
+  HOWTO(R_386_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_PC32, 0, 2, 32, TRUE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_PC32",
+	TRUE, 0xffffffff, 0xffffffff, TRUE),
+  HOWTO(R_386_GOT32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_GOT32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_PLT32, 0, 2, 32, TRUE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_PLT32",
+	TRUE, 0xffffffff, 0xffffffff, TRUE),
+  HOWTO(R_386_COPY, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_COPY",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_GLOB_DAT, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_GLOB_DAT",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_JUMP_SLOT, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_JUMP_SLOT",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_RELATIVE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_RELATIVE",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_GOTOFF, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_GOTOFF",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_GOTPC, 0, 2, 32, TRUE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_GOTPC",
+	TRUE, 0xffffffff, 0xffffffff, TRUE),
+
+  /* We have a gap in the reloc numbers here.
+     R_386_standard counts the number up to this point, and
+     R_386_ext_offset is the value to subtract from a reloc type of
+     R_386_16 thru R_386_PC8 to form an index into this table.  */
+#define R_386_standard (R_386_GOTPC + 1)
+#define R_386_ext_offset (R_386_TLS_TPOFF - R_386_standard)
+
+  /* These relocs are a GNU extension.  */
+  HOWTO(R_386_TLS_TPOFF, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_TPOFF",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_IE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_IE",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_GOTIE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_GOTIE",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_LE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_LE",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_GD, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_GD",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_LDM, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_LDM",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_16, 0, 1, 16, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_16",
+	TRUE, 0xffff, 0xffff, FALSE),
+  HOWTO(R_386_PC16, 0, 1, 16, TRUE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_PC16",
+	TRUE, 0xffff, 0xffff, TRUE),
+  HOWTO(R_386_8, 0, 0, 8, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_8",
+	TRUE, 0xff, 0xff, FALSE),
+  HOWTO(R_386_PC8, 0, 0, 8, TRUE, 0, complain_overflow_signed,
+	bfd_elf_generic_reloc, "R_386_PC8",
+	TRUE, 0xff, 0xff, TRUE),
+
+#define R_386_ext (R_386_PC8 + 1 - R_386_ext_offset)
+#define R_386_tls_offset (R_386_TLS_LDO_32 - R_386_ext)
+  /* These are common with Solaris TLS implementation.  */
+  HOWTO(R_386_TLS_LDO_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_LDO_32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_IE_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_IE_32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_LE_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_LE_32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_DTPMOD32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_DTPMOD32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_DTPOFF32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_DTPOFF32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_TPOFF32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_TPOFF32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  EMPTY_HOWTO (38),
+  HOWTO(R_386_TLS_GOTDESC, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_GOTDESC",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_DESC_CALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
+	bfd_elf_generic_reloc, "R_386_TLS_DESC_CALL",
+	FALSE, 0, 0, FALSE),
+  HOWTO(R_386_TLS_DESC, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_DESC",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_IRELATIVE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_IRELATIVE",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+
+  /* Another gap.  */
+#define R_386_irelative (R_386_IRELATIVE + 1 - R_386_tls_offset)
+#define R_386_vt_offset (R_386_GNU_VTINHERIT - R_386_irelative)
+
+/* GNU extension to record C++ vtable hierarchy.  */
+  HOWTO (R_386_GNU_VTINHERIT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 NULL,			/* special_function */
+	 "R_386_GNU_VTINHERIT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+/* GNU extension to record C++ vtable member usage.  */
+  HOWTO (R_386_GNU_VTENTRY,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
+	 "R_386_GNU_VTENTRY",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE)			/* pcrel_offset */
+
+#define R_386_vt (R_386_GNU_VTENTRY + 1 - R_386_vt_offset)
+
+};
+
+static reloc_howto_type *
+elf_i386_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			    const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0; i < sizeof (elf_howto_table) / sizeof (elf_howto_table[0]); i++)
+    if (elf_howto_table[i].name != NULL
+	&& strcasecmp (elf_howto_table[i].name, r_name) == 0)
+      return &elf_howto_table[i];
+
+  return NULL;
+}
+
+#ifdef DEBUG_GEN_RELOC
+#define TRACE(str) \
+  fprintf (stderr, "i386 bfd reloc lookup %d (%s)\n", code, str)
+#else
+#define TRACE(str)
+#endif
+
+static reloc_howto_type *
+elf_i386_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			    bfd_reloc_code_real_type code)
+{
+  switch (code)
+    {
+    case BFD_RELOC_NONE:
+      TRACE ("BFD_RELOC_NONE");
+      return &elf_howto_table[R_386_NONE];
+
+    case BFD_RELOC_32:
+      TRACE ("BFD_RELOC_32");
+      return &elf_howto_table[R_386_32];
+
+    case BFD_RELOC_CTOR:
+      TRACE ("BFD_RELOC_CTOR");
+      return &elf_howto_table[R_386_32];
+
+    case BFD_RELOC_32_PCREL:
+      TRACE ("BFD_RELOC_PC32");
+      return &elf_howto_table[R_386_PC32];
+
+    case BFD_RELOC_386_GOT32:
+      TRACE ("BFD_RELOC_386_GOT32");
+      return &elf_howto_table[R_386_GOT32];
+
+    case BFD_RELOC_386_PLT32:
+      TRACE ("BFD_RELOC_386_PLT32");
+      return &elf_howto_table[R_386_PLT32];
+
+    case BFD_RELOC_386_COPY:
+      TRACE ("BFD_RELOC_386_COPY");
+      return &elf_howto_table[R_386_COPY];
+
+    case BFD_RELOC_386_GLOB_DAT:
+      TRACE ("BFD_RELOC_386_GLOB_DAT");
+      return &elf_howto_table[R_386_GLOB_DAT];
+
+    case BFD_RELOC_386_JUMP_SLOT:
+      TRACE ("BFD_RELOC_386_JUMP_SLOT");
+      return &elf_howto_table[R_386_JUMP_SLOT];
+
+    case BFD_RELOC_386_RELATIVE:
+      TRACE ("BFD_RELOC_386_RELATIVE");
+      return &elf_howto_table[R_386_RELATIVE];
+
+    case BFD_RELOC_386_GOTOFF:
+      TRACE ("BFD_RELOC_386_GOTOFF");
+      return &elf_howto_table[R_386_GOTOFF];
+
+    case BFD_RELOC_386_GOTPC:
+      TRACE ("BFD_RELOC_386_GOTPC");
+      return &elf_howto_table[R_386_GOTPC];
+
+      /* These relocs are a GNU extension.  */
+    case BFD_RELOC_386_TLS_TPOFF:
+      TRACE ("BFD_RELOC_386_TLS_TPOFF");
+      return &elf_howto_table[R_386_TLS_TPOFF - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_IE:
+      TRACE ("BFD_RELOC_386_TLS_IE");
+      return &elf_howto_table[R_386_TLS_IE - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_GOTIE:
+      TRACE ("BFD_RELOC_386_TLS_GOTIE");
+      return &elf_howto_table[R_386_TLS_GOTIE - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_LE:
+      TRACE ("BFD_RELOC_386_TLS_LE");
+      return &elf_howto_table[R_386_TLS_LE - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_GD:
+      TRACE ("BFD_RELOC_386_TLS_GD");
+      return &elf_howto_table[R_386_TLS_GD - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_LDM:
+      TRACE ("BFD_RELOC_386_TLS_LDM");
+      return &elf_howto_table[R_386_TLS_LDM - R_386_ext_offset];
+
+    case BFD_RELOC_16:
+      TRACE ("BFD_RELOC_16");
+      return &elf_howto_table[R_386_16 - R_386_ext_offset];
+
+    case BFD_RELOC_16_PCREL:
+      TRACE ("BFD_RELOC_16_PCREL");
+      return &elf_howto_table[R_386_PC16 - R_386_ext_offset];
+
+    case BFD_RELOC_8:
+      TRACE ("BFD_RELOC_8");
+      return &elf_howto_table[R_386_8 - R_386_ext_offset];
+
+    case BFD_RELOC_8_PCREL:
+      TRACE ("BFD_RELOC_8_PCREL");
+      return &elf_howto_table[R_386_PC8 - R_386_ext_offset];
+
+    /* Common with Sun TLS implementation.  */
+    case BFD_RELOC_386_TLS_LDO_32:
+      TRACE ("BFD_RELOC_386_TLS_LDO_32");
+      return &elf_howto_table[R_386_TLS_LDO_32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_IE_32:
+      TRACE ("BFD_RELOC_386_TLS_IE_32");
+      return &elf_howto_table[R_386_TLS_IE_32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_LE_32:
+      TRACE ("BFD_RELOC_386_TLS_LE_32");
+      return &elf_howto_table[R_386_TLS_LE_32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_DTPMOD32:
+      TRACE ("BFD_RELOC_386_TLS_DTPMOD32");
+      return &elf_howto_table[R_386_TLS_DTPMOD32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_DTPOFF32:
+      TRACE ("BFD_RELOC_386_TLS_DTPOFF32");
+      return &elf_howto_table[R_386_TLS_DTPOFF32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_TPOFF32:
+      TRACE ("BFD_RELOC_386_TLS_TPOFF32");
+      return &elf_howto_table[R_386_TLS_TPOFF32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_GOTDESC:
+      TRACE ("BFD_RELOC_386_TLS_GOTDESC");
+      return &elf_howto_table[R_386_TLS_GOTDESC - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_DESC_CALL:
+      TRACE ("BFD_RELOC_386_TLS_DESC_CALL");
+      return &elf_howto_table[R_386_TLS_DESC_CALL - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_DESC:
+      TRACE ("BFD_RELOC_386_TLS_DESC");
+      return &elf_howto_table[R_386_TLS_DESC - R_386_tls_offset];
+
+    case BFD_RELOC_386_IRELATIVE:
+      TRACE ("BFD_RELOC_386_IRELATIVE");
+      return &elf_howto_table[R_386_IRELATIVE - R_386_tls_offset];
+
+    case BFD_RELOC_VTABLE_INHERIT:
+      TRACE ("BFD_RELOC_VTABLE_INHERIT");
+      return &elf_howto_table[R_386_GNU_VTINHERIT - R_386_vt_offset];
+
+    case BFD_RELOC_VTABLE_ENTRY:
+      TRACE ("BFD_RELOC_VTABLE_ENTRY");
+      return &elf_howto_table[R_386_GNU_VTENTRY - R_386_vt_offset];
+
+    default:
+      break;
+    }
+
+  TRACE ("Unknown");
+  return 0;
+}
+
+#if 0
+
+/* Support RELA for objdump of prelink objects.  */
+#define elf_info_to_howto		      elf_i386_info_to_howto_rel
+#define elf_info_to_howto_rel		      elf_i386_info_to_howto_rel
+
+#define bfd_elf32_mkobject		      elf_i386_mkobject
+
+#define bfd_elf32_bfd_is_local_label_name     elf_i386_is_local_label_name
+#define bfd_elf32_bfd_link_hash_table_create  elf_i386_link_hash_table_create
+#define bfd_elf32_bfd_link_hash_table_free    elf_i386_link_hash_table_free
+#define bfd_elf32_bfd_reloc_type_lookup	      elf_i386_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup	      elf_i386_reloc_name_lookup
+
+#define elf_backend_adjust_dynamic_symbol     elf_i386_adjust_dynamic_symbol
+#define elf_backend_relocs_compatible	      _bfd_elf_relocs_compatible
+#define elf_backend_check_relocs	      elf_i386_check_relocs
+#define elf_backend_copy_indirect_symbol      elf_i386_copy_indirect_symbol
+#define elf_backend_create_dynamic_sections   elf_i386_create_dynamic_sections
+#define elf_backend_fake_sections	      elf_i386_fake_sections
+#define elf_backend_finish_dynamic_sections   elf_i386_finish_dynamic_sections
+#define elf_backend_finish_dynamic_symbol     elf_i386_finish_dynamic_symbol
+#define elf_backend_gc_mark_hook	      elf_i386_gc_mark_hook
+#define elf_backend_gc_sweep_hook	      elf_i386_gc_sweep_hook
+#define elf_backend_grok_prstatus	      elf_i386_grok_prstatus
+#define elf_backend_grok_psinfo		      elf_i386_grok_psinfo
+#define elf_backend_reloc_type_class	      elf_i386_reloc_type_class
+#define elf_backend_relocate_section	      elf_i386_relocate_section
+#define elf_backend_size_dynamic_sections     elf_i386_size_dynamic_sections
+#define elf_backend_always_size_sections      elf_i386_always_size_sections
+#define elf_backend_omit_section_dynsym \
+  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
+#define elf_backend_plt_sym_val		      elf_i386_plt_sym_val
+#define elf_backend_hash_symbol		      elf_i386_hash_symbol
+#define elf_backend_add_symbol_hook           elf_i386_add_symbol_hook
+#undef	elf_backend_post_process_headers
+#define	elf_backend_post_process_headers	_bfd_elf_set_osabi
+
+#endif
+
+//#undef elf32_bed
+//#define elf32_bed elf32_avm_bed
+
+#include "elf32-target.h"
diff -rupN gdb-7.3.orig/bfd/elf-avm2.c gdb-7.3/bfd/elf-avm2.c
--- gdb-7.3.orig/bfd/elf-avm2.c	1970-01-01 03:00:00.000000000 +0300
+++ gdb-7.3/bfd/elf-avm2.c	2014-10-11 21:51:26.000000000 +0400
@@ -0,0 +1,73 @@
+/*
+** Copyright 2012 Adobe Systems Incorporated. All Rights Reserved.
+** 
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2, or (at your option)
+** any later version.
+** 
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+** GNU General Public License for more details.
+** 
+** You should have received a copy of the GNU General Public License
+** along with this program. If not, see <http://www.gnu.org/licenses/>.
+**/
+
+#define TARGET_LITTLE_SYM		bfd_avm2_vec
+#define TARGET_LITTLE_NAME		"avm2"
+#define ELF_ARCH			bfd_arch_avm2
+#define ELF_TARGET_ID			GENERIC_ELF_DATA
+#define ELF_MACHINE_CODE		EM_386 // TODO: change this?
+#define ELF_MAXPAGESIZE			0x1000
+
+#define elf_backend_can_gc_sections	1
+#define elf_backend_can_refcount	1
+#define elf_backend_want_got_plt	1
+#define elf_backend_plt_readonly	1
+#define elf_backend_want_plt_sym	0
+#define elf_backend_got_header_size	12
+
+#if 0
+
+/* Support RELA for objdump of prelink objects.  */
+#define elf_info_to_howto		      elf_i386_info_to_howto_rel
+#define elf_info_to_howto_rel		      elf_i386_info_to_howto_rel
+
+#define bfd_elf32_mkobject		      elf_i386_mkobject
+
+#define bfd_elf32_bfd_is_local_label_name     elf_i386_is_local_label_name
+#define bfd_elf32_bfd_link_hash_table_create  elf_i386_link_hash_table_create
+#define bfd_elf32_bfd_link_hash_table_free    elf_i386_link_hash_table_free
+#define bfd_elf32_bfd_reloc_type_lookup	      elf_i386_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup	      elf_i386_reloc_name_lookup
+
+#define elf_backend_adjust_dynamic_symbol     elf_i386_adjust_dynamic_symbol
+#define elf_backend_relocs_compatible	      _bfd_elf_relocs_compatible
+#define elf_backend_check_relocs	      elf_i386_check_relocs
+#define elf_backend_copy_indirect_symbol      elf_i386_copy_indirect_symbol
+#define elf_backend_create_dynamic_sections   elf_i386_create_dynamic_sections
+#define elf_backend_fake_sections	      elf_i386_fake_sections
+#define elf_backend_finish_dynamic_sections   elf_i386_finish_dynamic_sections
+#define elf_backend_finish_dynamic_symbol     elf_i386_finish_dynamic_symbol
+#define elf_backend_gc_mark_hook	      elf_i386_gc_mark_hook
+#define elf_backend_gc_sweep_hook	      elf_i386_gc_sweep_hook
+#define elf_backend_grok_prstatus	      elf_i386_grok_prstatus
+#define elf_backend_grok_psinfo		      elf_i386_grok_psinfo
+#define elf_backend_reloc_type_class	      elf_i386_reloc_type_class
+#define elf_backend_relocate_section	      elf_i386_relocate_section
+#define elf_backend_size_dynamic_sections     elf_i386_size_dynamic_sections
+#define elf_backend_always_size_sections      elf_i386_always_size_sections
+#define elf_backend_omit_section_dynsym \
+  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
+#define elf_backend_plt_sym_val		      elf_i386_plt_sym_val
+#define elf_backend_hash_symbol		      elf_i386_hash_symbol
+#define elf_backend_add_symbol_hook           elf_i386_add_symbol_hook
+#undef	elf_backend_post_process_headers
+#define	elf_backend_post_process_headers	_bfd_elf_set_osabi
+
+#endif
+
+#include "elf32-target.h"
+
diff -rupN gdb-7.3.orig/bfd/elflink.c gdb-7.3/bfd/elflink.c
--- gdb-7.3.orig/bfd/elflink.c	2011-03-14 18:54:58.000000000 +0300
+++ gdb-7.3/bfd/elflink.c	2014-10-11 21:51:26.000000000 +0400
@@ -12456,7 +12456,7 @@ _bfd_elf_section_already_linked (bfd *ab
 		   abfd, sec);
 	      else if (sec->size != 0)
 		{
-		  bfd_byte *sec_contents, *l_sec_contents;
+		  bfd_byte *sec_contents=0, *l_sec_contents=0;
 
 		  if (!bfd_malloc_and_get_section (abfd, sec, &sec_contents))
 		    (*_bfd_error_handler)
diff -rupN gdb-7.3.orig/bfd/targets.c gdb-7.3/bfd/targets.c
--- gdb-7.3.orig/bfd/targets.c	2010-12-31 14:00:53.000000000 +0300
+++ gdb-7.3/bfd/targets.c	2014-10-11 21:51:26.000000000 +0400
@@ -560,6 +560,7 @@ extern const bfd_target aout_arm_little_
 extern const bfd_target aout_mips_big_vec;
 extern const bfd_target aout_mips_little_vec;
 extern const bfd_target apollocoff_vec;
+extern const bfd_target bfd_avm2_vec;
 extern const bfd_target arm_epoc_pe_big_vec;
 extern const bfd_target arm_epoc_pe_little_vec;
 extern const bfd_target arm_epoc_pei_big_vec;
@@ -903,6 +904,7 @@ static const bfd_target * const _bfd_tar
 #if 0
 	&apollocoff_vec,
 #endif
+	&bfd_avm2_vec,
 	&arm_epoc_pe_big_vec,
 	&arm_epoc_pe_little_vec,
 	&arm_epoc_pei_big_vec,
diff -rupN gdb-7.3.orig/config.sub gdb-7.3/config.sub
--- gdb-7.3.orig/config.sub	2011-03-24 14:13:32.000000000 +0300
+++ gdb-7.3/config.sub	2014-10-11 21:51:26.000000000 +0400
@@ -251,6 +251,7 @@ case $basic_machine in
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
 	| am33_2.0 \
 	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
+	| avm2 \
 	| bfin \
 	| c4x | clipper \
 	| d10v | d30v | dlx | dsp16xx \
@@ -356,6 +357,7 @@ case $basic_machine in
 	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
 	| avr-* | avr32-* \
+	| avm2-* \
 	| bfin-* | bs2000-* \
 	| c[123]* | c30-* | [cjt]90-* | c4x-* \
 	| clipper-* | craynv-* | cydra-* \
diff -rupN gdb-7.3.orig/gdb/arch-utils.c gdb-7.3/gdb/arch-utils.c
--- gdb-7.3.orig/gdb/arch-utils.c	2011-01-06 01:22:47.000000000 +0300
+++ gdb-7.3/gdb/arch-utils.c	2014-10-11 21:51:26.000000000 +0400
@@ -794,10 +794,12 @@ extern initialize_file_ftype _initialize
 void
 _initialize_gdbarch_utils (void)
 {
+#if 0
   add_setshow_enum_cmd ("endian", class_support,
 			endian_enum, &set_endian_string, 
 			_("Set endianness of target."),
 			_("Show endianness of target."),
 			NULL, set_endian, show_endian,
 			&setlist, &showlist);
+#endif
 }
diff -rupN gdb-7.3.orig/gdb/avm2-tdep.c gdb-7.3/gdb/avm2-tdep.c
--- gdb-7.3.orig/gdb/avm2-tdep.c	1970-01-01 03:00:00.000000000 +0300
+++ gdb-7.3/gdb/avm2-tdep.c	2014-10-11 21:51:26.000000000 +0400
@@ -0,0 +1,3776 @@
+/* Intel 386 target-dependent stuff.
+
+   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+   2010, 2011 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "opcode/i386.h"
+#include "arch-utils.h"
+#include "command.h"
+#include "dummy-frame.h"
+#include "dwarf2-frame.h"
+#include "doublest.h"
+#include "frame.h"
+#include "frame-base.h"
+#include "frame-unwind.h"
+#include "inferior.h"
+#include "gdbcmd.h"
+#include "gdbcore.h"
+#include "gdbtypes.h"
+#include "objfiles.h"
+#include "osabi.h"
+#include "regcache.h"
+#include "reggroups.h"
+#include "regset.h"
+#include "symfile.h"
+#include "symtab.h"
+#include "target.h"
+#include "value.h"
+#include "dis-asm.h"
+#include "disasm.h"
+#include "remote.h"
+#include "exceptions.h"
+#include "gdb_assert.h"
+#include "gdb_string.h"
+
+#include "i386-tdep.h"
+#include "i387-tdep.h"
+#include "i386-xstate.h"
+
+#include "record.h"
+#include <stdint.h>
+
+#include "features/i386/i386.c"
+#include "features/i386/i386-avx.c"
+#include "features/i386/i386-mmx.c"
+
+/* Register names.  */
+
+static const char *i386_register_names[] =
+{
+  "eax",   "ecx",    "edx",   "ebx",
+  "esp",   "ebp",    "esi",   "edi",
+  "eip",   "eflags", "cs",    "ss",
+  "ds",    "es",     "fs",    "gs",
+  "st0",   "st1",    "st2",   "st3",
+  "st4",   "st5",    "st6",   "st7",
+  "fctrl", "fstat",  "ftag",  "fiseg",
+  "fioff", "foseg",  "fooff", "fop",
+  "xmm0",  "xmm1",   "xmm2",  "xmm3",
+  "xmm4",  "xmm5",   "xmm6",  "xmm7",
+  "mxcsr"
+};
+
+static const char *i386_ymm_names[] =
+{
+  "ymm0",  "ymm1",   "ymm2",  "ymm3",
+  "ymm4",  "ymm5",   "ymm6",  "ymm7",
+};
+
+static const char *i386_ymmh_names[] =
+{
+  "ymm0h",  "ymm1h",   "ymm2h",  "ymm3h",
+  "ymm4h",  "ymm5h",   "ymm6h",  "ymm7h",
+};
+
+/* Register names for MMX pseudo-registers.  */
+
+static const char *i386_mmx_names[] =
+{
+  "mm0", "mm1", "mm2", "mm3",
+  "mm4", "mm5", "mm6", "mm7"
+};
+
+/* Register names for byte pseudo-registers.  */
+
+static const char *i386_byte_names[] =
+{
+  "al", "cl", "dl", "bl", 
+  "ah", "ch", "dh", "bh"
+};
+
+/* Register names for word pseudo-registers.  */
+
+static const char *i386_word_names[] =
+{
+  "ax", "cx", "dx", "bx",
+  "", "bp", "si", "di"
+};
+
+/* MMX register?  */
+
+static int
+i386_mmx_regnum_p (struct gdbarch *gdbarch, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int mm0_regnum = tdep->mm0_regnum;
+
+  if (mm0_regnum < 0)
+    return 0;
+
+  regnum -= mm0_regnum;
+  return regnum >= 0 && regnum < tdep->num_mmx_regs;
+}
+
+/* Byte register?  */
+
+int
+i386_byte_regnum_p (struct gdbarch *gdbarch, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  regnum -= tdep->al_regnum;
+  return regnum >= 0 && regnum < tdep->num_byte_regs;
+}
+
+/* Word register?  */
+
+int
+i386_word_regnum_p (struct gdbarch *gdbarch, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  regnum -= tdep->ax_regnum;
+  return regnum >= 0 && regnum < tdep->num_word_regs;
+}
+
+/* Dword register?  */
+
+int
+i386_dword_regnum_p (struct gdbarch *gdbarch, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int eax_regnum = tdep->eax_regnum;
+
+  if (eax_regnum < 0)
+    return 0;
+
+  regnum -= eax_regnum;
+  return regnum >= 0 && regnum < tdep->num_dword_regs;
+}
+
+static int
+i386_ymmh_regnum_p (struct gdbarch *gdbarch, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int ymm0h_regnum = tdep->ymm0h_regnum;
+
+  if (ymm0h_regnum < 0)
+    return 0;
+
+  regnum -= ymm0h_regnum;
+  return regnum >= 0 && regnum < tdep->num_ymm_regs;
+}
+
+/* AVX register?  */
+
+int
+i386_ymm_regnum_p (struct gdbarch *gdbarch, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int ymm0_regnum = tdep->ymm0_regnum;
+
+  if (ymm0_regnum < 0)
+    return 0;
+
+  regnum -= ymm0_regnum;
+  return regnum >= 0 && regnum < tdep->num_ymm_regs;
+}
+
+/* SSE register?  */
+
+int
+i386_xmm_regnum_p (struct gdbarch *gdbarch, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int num_xmm_regs = I387_NUM_XMM_REGS (tdep);
+
+  if (num_xmm_regs == 0)
+    return 0;
+
+  regnum -= I387_XMM0_REGNUM (tdep);
+  return regnum >= 0 && regnum < num_xmm_regs;
+}
+
+static int
+i386_mxcsr_regnum_p (struct gdbarch *gdbarch, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  if (I387_NUM_XMM_REGS (tdep) == 0)
+    return 0;
+
+  return (regnum == I387_MXCSR_REGNUM (tdep));
+}
+
+/* FP register?  */
+
+int
+i386_fp_regnum_p (struct gdbarch *gdbarch, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  if (I387_ST0_REGNUM (tdep) < 0)
+    return 0;
+
+  return (I387_ST0_REGNUM (tdep) <= regnum
+	  && regnum < I387_FCTRL_REGNUM (tdep));
+}
+
+int
+i386_fpc_regnum_p (struct gdbarch *gdbarch, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  if (I387_ST0_REGNUM (tdep) < 0)
+    return 0;
+
+  return (I387_FCTRL_REGNUM (tdep) <= regnum 
+	  && regnum < I387_XMM0_REGNUM (tdep));
+}
+
+/* Return the name of register REGNUM, or the empty string if it is
+   an anonymous register.  */
+
+static const char *
+i386_register_name (struct gdbarch *gdbarch, int regnum)
+{
+  /* Hide the upper YMM registers.  */
+  if (i386_ymmh_regnum_p (gdbarch, regnum))
+    return "";
+
+  return tdesc_register_name (gdbarch, regnum);
+}
+
+/* Return the name of register REGNUM.  */
+
+const char *
+i386_pseudo_register_name (struct gdbarch *gdbarch, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  if (i386_mmx_regnum_p (gdbarch, regnum))
+    return i386_mmx_names[regnum - I387_MM0_REGNUM (tdep)];
+  else if (i386_ymm_regnum_p (gdbarch, regnum))
+    return i386_ymm_names[regnum - tdep->ymm0_regnum];
+  else if (i386_byte_regnum_p (gdbarch, regnum))
+    return i386_byte_names[regnum - tdep->al_regnum];
+  else if (i386_word_regnum_p (gdbarch, regnum))
+    return i386_word_names[regnum - tdep->ax_regnum];
+
+  internal_error (__FILE__, __LINE__, _("invalid regnum"));
+}
+
+/* Convert a dbx register number REG to the appropriate register
+   number used by GDB.  */
+
+static int
+i386_dbx_reg_to_regnum (struct gdbarch *gdbarch, int reg)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  /* This implements what GCC calls the "default" register map
+     (dbx_register_map[]).  */
+
+  if (reg >= 0 && reg <= 7)
+    {
+      /* General-purpose registers.  The debug info calls %ebp
+         register 4, and %esp register 5.  */
+      if (reg == 4)
+        return 5;
+      else if (reg == 5)
+        return 4;
+      else return reg;
+    }
+  else if (reg >= 12 && reg <= 19)
+    {
+      /* Floating-point registers.  */
+      return reg - 12 + I387_ST0_REGNUM (tdep);
+    }
+  else if (reg >= 21 && reg <= 28)
+    {
+      /* SSE registers.  */
+      int ymm0_regnum = tdep->ymm0_regnum;
+
+      if (ymm0_regnum >= 0
+	  && i386_xmm_regnum_p (gdbarch, reg))
+	return reg - 21 + ymm0_regnum;
+      else
+	return reg - 21 + I387_XMM0_REGNUM (tdep);
+    }
+  else if (reg >= 29 && reg <= 36)
+    {
+      /* MMX registers.  */
+      return reg - 29 + I387_MM0_REGNUM (tdep);
+    }
+
+  /* This will hopefully provoke a warning.  */
+  return gdbarch_num_regs (gdbarch) + gdbarch_num_pseudo_regs (gdbarch);
+}
+
+/* Convert SVR4 register number REG to the appropriate register number
+   used by GDB.  */
+
+static int
+i386_svr4_reg_to_regnum (struct gdbarch *gdbarch, int reg)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  /* This implements the GCC register map that tries to be compatible
+     with the SVR4 C compiler for DWARF (svr4_dbx_register_map[]).  */
+
+  /* The SVR4 register numbering includes %eip and %eflags, and
+     numbers the floating point registers differently.  */
+  if (reg >= 0 && reg <= 9)
+    {
+      /* General-purpose registers.  */
+      return reg;
+    }
+  else if (reg >= 11 && reg <= 18)
+    {
+      /* Floating-point registers.  */
+      return reg - 11 + I387_ST0_REGNUM (tdep);
+    }
+  else if (reg >= 21 && reg <= 36)
+    {
+      /* The SSE and MMX registers have the same numbers as with dbx.  */
+      return i386_dbx_reg_to_regnum (gdbarch, reg);
+    }
+
+  switch (reg)
+    {
+    case 37: return I387_FCTRL_REGNUM (tdep);
+    case 38: return I387_FSTAT_REGNUM (tdep);
+    case 39: return I387_MXCSR_REGNUM (tdep);
+    case 40: return I386_ES_REGNUM;
+    case 41: return I386_CS_REGNUM;
+    case 42: return I386_SS_REGNUM;
+    case 43: return I386_DS_REGNUM;
+    case 44: return I386_FS_REGNUM;
+    case 45: return I386_GS_REGNUM;
+    }
+
+  /* This will hopefully provoke a warning.  */
+  return gdbarch_num_regs (gdbarch) + gdbarch_num_pseudo_regs (gdbarch);
+}
+
+
+
+/* This is the variable that is set with "set disassembly-flavor", and
+   its legitimate values.  */
+static const char att_flavor[] = "att";
+static const char intel_flavor[] = "intel";
+static const char *valid_flavors[] =
+{
+  att_flavor,
+  intel_flavor,
+  NULL
+};
+static const char *disassembly_flavor = att_flavor;
+
+
+/* Use the program counter to determine the contents and size of a
+   breakpoint instruction.  Return a pointer to a string of bytes that
+   encode a breakpoint instruction, store the length of the string in
+   *LEN and optionally adjust *PC to point to the correct memory
+   location for inserting the breakpoint.
+
+   On the i386 we have a single breakpoint that fits in a single byte
+   and can be inserted anywhere.
+
+   This function is 64-bit safe.  */
+
+static const gdb_byte *
+i386_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pc, int *len)
+{
+  static gdb_byte break_insn[] = { 0xcc }; /* int 3 */
+
+  *len = sizeof (break_insn);
+  return break_insn;
+}
+
+/* Displaced instruction handling.  */
+
+/* Skip the legacy instruction prefixes in INSN.
+   Not all prefixes are valid for any particular insn
+   but we needn't care, the insn will fault if it's invalid.
+   The result is a pointer to the first opcode byte,
+   or NULL if we run off the end of the buffer.  */
+
+static gdb_byte *
+i386_skip_prefixes (gdb_byte *insn, size_t max_len)
+{
+  gdb_byte *end = insn + max_len;
+
+  while (insn < end)
+    {
+      switch (*insn)
+	{
+	case DATA_PREFIX_OPCODE:
+	case ADDR_PREFIX_OPCODE:
+	case CS_PREFIX_OPCODE:
+	case DS_PREFIX_OPCODE:
+	case ES_PREFIX_OPCODE:
+	case FS_PREFIX_OPCODE:
+	case GS_PREFIX_OPCODE:
+	case SS_PREFIX_OPCODE:
+	case LOCK_PREFIX_OPCODE:
+	case REPE_PREFIX_OPCODE:
+	case REPNE_PREFIX_OPCODE:
+	  ++insn;
+	  continue;
+	default:
+	  return insn;
+	}
+    }
+
+  return NULL;
+}
+
+static int
+i386_absolute_jmp_p (const gdb_byte *insn)
+{
+  /* jmp far (absolute address in operand).  */
+  if (insn[0] == 0xea)
+    return 1;
+
+  if (insn[0] == 0xff)
+    {
+      /* jump near, absolute indirect (/4).  */
+      if ((insn[1] & 0x38) == 0x20)
+        return 1;
+
+      /* jump far, absolute indirect (/5).  */
+      if ((insn[1] & 0x38) == 0x28)
+        return 1;
+    }
+
+  return 0;
+}
+
+static int
+i386_absolute_call_p (const gdb_byte *insn)
+{
+  /* call far, absolute.  */
+  if (insn[0] == 0x9a)
+    return 1;
+
+  if (insn[0] == 0xff)
+    {
+      /* Call near, absolute indirect (/2).  */
+      if ((insn[1] & 0x38) == 0x10)
+        return 1;
+
+      /* Call far, absolute indirect (/3).  */
+      if ((insn[1] & 0x38) == 0x18)
+        return 1;
+    }
+
+  return 0;
+}
+
+static int
+i386_ret_p (const gdb_byte *insn)
+{
+  switch (insn[0])
+    {
+    case 0xc2: /* ret near, pop N bytes.  */
+    case 0xc3: /* ret near */
+    case 0xca: /* ret far, pop N bytes.  */
+    case 0xcb: /* ret far */
+    case 0xcf: /* iret */
+      return 1;
+
+    default:
+      return 0;
+    }
+}
+
+static int
+i386_call_p (const gdb_byte *insn)
+{
+  if (i386_absolute_call_p (insn))
+    return 1;
+
+  /* call near, relative.  */
+  if (insn[0] == 0xe8)
+    return 1;
+
+  return 0;
+}
+
+/* Return non-zero if INSN is a system call, and set *LENGTHP to its
+   length in bytes.  Otherwise, return zero.  */
+
+static int
+i386_syscall_p (const gdb_byte *insn, int *lengthp)
+{
+  if (insn[0] == 0xcd)
+    {
+      *lengthp = 2;
+      return 1;
+    }
+
+  return 0;
+}
+
+/* Some kernels may run one past a syscall insn, so we have to cope.
+   Otherwise this is just simple_displaced_step_copy_insn.  */
+
+struct displaced_step_closure *
+i386_displaced_step_copy_insn (struct gdbarch *gdbarch,
+			       CORE_ADDR from, CORE_ADDR to,
+			       struct regcache *regs)
+{
+  size_t len = gdbarch_max_insn_length (gdbarch);
+  gdb_byte *buf = xmalloc (len);
+
+  read_memory (from, buf, len);
+
+  /* GDB may get control back after the insn after the syscall.
+     Presumably this is a kernel bug.
+     If this is a syscall, make sure there's a nop afterwards.  */
+  {
+    int syscall_length;
+    gdb_byte *insn;
+
+    insn = i386_skip_prefixes (buf, len);
+    if (insn != NULL && i386_syscall_p (insn, &syscall_length))
+      insn[syscall_length] = NOP_OPCODE;
+  }
+
+  write_memory (to, buf, len);
+
+  if (debug_displaced)
+    {
+      fprintf_unfiltered (gdb_stdlog, "displaced: copy %s->%s: ",
+                          paddress (gdbarch, from), paddress (gdbarch, to));
+      displaced_step_dump_bytes (gdb_stdlog, buf, len);
+    }
+
+  return (struct displaced_step_closure *) buf;
+}
+
+/* Fix up the state of registers and memory after having single-stepped
+   a displaced instruction.  */
+
+void
+i386_displaced_step_fixup (struct gdbarch *gdbarch,
+                           struct displaced_step_closure *closure,
+                           CORE_ADDR from, CORE_ADDR to,
+                           struct regcache *regs)
+{
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+
+  /* The offset we applied to the instruction's address.
+     This could well be negative (when viewed as a signed 32-bit
+     value), but ULONGEST won't reflect that, so take care when
+     applying it.  */
+  ULONGEST insn_offset = to - from;
+
+  /* Since we use simple_displaced_step_copy_insn, our closure is a
+     copy of the instruction.  */
+  gdb_byte *insn = (gdb_byte *) closure;
+  /* The start of the insn, needed in case we see some prefixes.  */
+  gdb_byte *insn_start = insn;
+
+  if (debug_displaced)
+    fprintf_unfiltered (gdb_stdlog,
+                        "displaced: fixup (%s, %s), "
+                        "insn = 0x%02x 0x%02x ...\n",
+                        paddress (gdbarch, from), paddress (gdbarch, to),
+			insn[0], insn[1]);
+
+  /* The list of issues to contend with here is taken from
+     resume_execution in arch/i386/kernel/kprobes.c, Linux 2.6.20.
+     Yay for Free Software!  */
+
+  /* Relocate the %eip, if necessary.  */
+
+  /* The instruction recognizers we use assume any leading prefixes
+     have been skipped.  */
+  {
+    /* This is the size of the buffer in closure.  */
+    size_t max_insn_len = gdbarch_max_insn_length (gdbarch);
+    gdb_byte *opcode = i386_skip_prefixes (insn, max_insn_len);
+    /* If there are too many prefixes, just ignore the insn.
+       It will fault when run.  */
+    if (opcode != NULL)
+      insn = opcode;
+  }
+
+  /* Except in the case of absolute or indirect jump or call
+     instructions, or a return instruction, the new eip is relative to
+     the displaced instruction; make it relative.  Well, signal
+     handler returns don't need relocation either, but we use the
+     value of %eip to recognize those; see below.  */
+  if (! i386_absolute_jmp_p (insn)
+      && ! i386_absolute_call_p (insn)
+      && ! i386_ret_p (insn))
+    {
+      ULONGEST orig_eip;
+      int insn_len;
+
+      regcache_cooked_read_unsigned (regs, I386_EIP_REGNUM, &orig_eip);
+
+      /* A signal trampoline system call changes the %eip, resuming
+         execution of the main program after the signal handler has
+         returned.  That makes them like 'return' instructions; we
+         shouldn't relocate %eip.
+
+         But most system calls don't, and we do need to relocate %eip.
+
+         Our heuristic for distinguishing these cases: if stepping
+         over the system call instruction left control directly after
+         the instruction, the we relocate --- control almost certainly
+         doesn't belong in the displaced copy.  Otherwise, we assume
+         the instruction has put control where it belongs, and leave
+         it unrelocated.  Goodness help us if there are PC-relative
+         system calls.  */
+      if (i386_syscall_p (insn, &insn_len)
+          && orig_eip != to + (insn - insn_start) + insn_len
+	  /* GDB can get control back after the insn after the syscall.
+	     Presumably this is a kernel bug.
+	     i386_displaced_step_copy_insn ensures its a nop,
+	     we add one to the length for it.  */
+          && orig_eip != to + (insn - insn_start) + insn_len + 1)
+        {
+          if (debug_displaced)
+            fprintf_unfiltered (gdb_stdlog,
+                                "displaced: syscall changed %%eip; "
+                                "not relocating\n");
+        }
+      else
+        {
+          ULONGEST eip = (orig_eip - insn_offset) & 0xffffffffUL;
+
+	  /* If we just stepped over a breakpoint insn, we don't backup
+	     the pc on purpose; this is to match behaviour without
+	     stepping.  */
+
+          regcache_cooked_write_unsigned (regs, I386_EIP_REGNUM, eip);
+
+          if (debug_displaced)
+            fprintf_unfiltered (gdb_stdlog,
+                                "displaced: "
+                                "relocated %%eip from %s to %s\n",
+                                paddress (gdbarch, orig_eip),
+				paddress (gdbarch, eip));
+        }
+    }
+
+  /* If the instruction was PUSHFL, then the TF bit will be set in the
+     pushed value, and should be cleared.  We'll leave this for later,
+     since GDB already messes up the TF flag when stepping over a
+     pushfl.  */
+
+  /* If the instruction was a call, the return address now atop the
+     stack is the address following the copied instruction.  We need
+     to make it the address following the original instruction.  */
+  if (i386_call_p (insn))
+    {
+      ULONGEST esp;
+      ULONGEST retaddr;
+      const ULONGEST retaddr_len = 4;
+
+      regcache_cooked_read_unsigned (regs, I386_ESP_REGNUM, &esp);
+      retaddr = read_memory_unsigned_integer (esp, retaddr_len, byte_order);
+      retaddr = (retaddr - insn_offset) & 0xffffffffUL;
+      write_memory_unsigned_integer (esp, retaddr_len, byte_order, retaddr);
+
+      if (debug_displaced)
+        fprintf_unfiltered (gdb_stdlog,
+                            "displaced: relocated return addr at %s to %s\n",
+                            paddress (gdbarch, esp),
+                            paddress (gdbarch, retaddr));
+    }
+}
+
+static void
+append_insns (CORE_ADDR *to, ULONGEST len, const gdb_byte *buf)
+{
+  target_write_memory (*to, buf, len);
+  *to += len;
+}
+
+static void
+i386_relocate_instruction (struct gdbarch *gdbarch,
+			   CORE_ADDR *to, CORE_ADDR oldloc)
+{
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  gdb_byte buf[I386_MAX_INSN_LEN];
+  int offset = 0, rel32, newrel;
+  int insn_length;
+  gdb_byte *insn = buf;
+
+  read_memory (oldloc, buf, I386_MAX_INSN_LEN);
+
+  insn_length = gdb_buffered_insn_length (gdbarch, insn,
+					  I386_MAX_INSN_LEN, oldloc);
+
+  /* Get past the prefixes.  */
+  insn = i386_skip_prefixes (insn, I386_MAX_INSN_LEN);
+
+  /* Adjust calls with 32-bit relative addresses as push/jump, with
+     the address pushed being the location where the original call in
+     the user program would return to.  */
+  if (insn[0] == 0xe8)
+    {
+      gdb_byte push_buf[16];
+      unsigned int ret_addr;
+
+      /* Where "ret" in the original code will return to.  */
+      ret_addr = oldloc + insn_length;
+      push_buf[0] = 0x68; /* pushq $...  */
+      memcpy (&push_buf[1], &ret_addr, 4);
+      /* Push the push.  */
+      append_insns (to, 5, push_buf);
+
+      /* Convert the relative call to a relative jump.  */
+      insn[0] = 0xe9;
+
+      /* Adjust the destination offset.  */
+      rel32 = extract_signed_integer (insn + 1, 4, byte_order);
+      newrel = (oldloc - *to) + rel32;
+      store_signed_integer (insn + 1, 4, byte_order, newrel);
+
+      if (debug_displaced)
+	fprintf_unfiltered (gdb_stdlog,
+			    "Adjusted insn rel32=%s at %s to"
+			    " rel32=%s at %s\n",
+			    hex_string (rel32), paddress (gdbarch, oldloc),
+			    hex_string (newrel), paddress (gdbarch, *to));
+
+      /* Write the adjusted jump into its displaced location.  */
+      append_insns (to, 5, insn);
+      return;
+    }
+
+  /* Adjust jumps with 32-bit relative addresses.  Calls are already
+     handled above.  */
+  if (insn[0] == 0xe9)
+    offset = 1;
+  /* Adjust conditional jumps.  */
+  else if (insn[0] == 0x0f && (insn[1] & 0xf0) == 0x80)
+    offset = 2;
+
+  if (offset)
+    {
+      rel32 = extract_signed_integer (insn + offset, 4, byte_order);
+      newrel = (oldloc - *to) + rel32;
+      store_signed_integer (insn + offset, 4, byte_order, newrel);
+      if (debug_displaced)
+	fprintf_unfiltered (gdb_stdlog,
+			    "Adjusted insn rel32=%s at %s to"
+			    " rel32=%s at %s\n",
+			    hex_string (rel32), paddress (gdbarch, oldloc),
+			    hex_string (newrel), paddress (gdbarch, *to));
+    }
+
+  /* Write the adjusted instructions into their displaced
+     location.  */
+  append_insns (to, insn_length, buf);
+}
+
+
+#ifdef I386_REGNO_TO_SYMMETRY
+#error "The Sequent Symmetry is no longer supported."
+#endif
+
+/* According to the System V ABI, the registers %ebp, %ebx, %edi, %esi
+   and %esp "belong" to the calling function.  Therefore these
+   registers should be saved if they're going to be modified.  */
+
+/* The maximum number of saved registers.  This should include all
+   registers mentioned above, and %eip.  */
+#define I386_NUM_SAVED_REGS	I386_NUM_GREGS
+
+struct i386_frame_cache
+{
+  /* Base address.  */
+  CORE_ADDR base;
+  int base_p;
+  LONGEST sp_offset;
+  CORE_ADDR pc;
+
+  /* Saved registers.  */
+  CORE_ADDR saved_regs[I386_NUM_SAVED_REGS];
+  CORE_ADDR saved_sp;
+  int saved_sp_reg;
+  int pc_in_eax;
+
+  /* Stack space reserved for local variables.  */
+  long locals;
+};
+
+/* Allocate and initialize a frame cache.  */
+
+static struct i386_frame_cache *
+i386_alloc_frame_cache (void)
+{
+  struct i386_frame_cache *cache;
+  int i;
+
+  cache = FRAME_OBSTACK_ZALLOC (struct i386_frame_cache);
+
+  /* Base address.  */
+  cache->base_p = 0;
+  cache->base = 0;
+  cache->sp_offset = -4;
+  cache->pc = 0;
+
+  /* Saved registers.  We initialize these to -1 since zero is a valid
+     offset (that's where %ebp is supposed to be stored).  */
+  for (i = 0; i < I386_NUM_SAVED_REGS; i++)
+    cache->saved_regs[i] = -1;
+  cache->saved_sp = 0;
+  cache->saved_sp_reg = -1;
+  cache->pc_in_eax = 0;
+
+  /* Frameless until proven otherwise.  */
+  cache->locals = -1;
+
+  return cache;
+}
+
+/* If the instruction at PC is a jump, return the address of its
+   target.  Otherwise, return PC.  */
+
+static CORE_ADDR
+i386_follow_jump (struct gdbarch *gdbarch, CORE_ADDR pc)
+{
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  gdb_byte op;
+  long delta = 0;
+  int data16 = 0;
+
+  if (target_read_memory (pc, &op, 1))
+    return pc;
+
+  if (op == 0x66)
+    {
+      data16 = 1;
+      op = read_memory_unsigned_integer (pc + 1, 1, byte_order);
+    }
+
+  switch (op)
+    {
+    case 0xe9:
+      /* Relative jump: if data16 == 0, disp32, else disp16.  */
+      if (data16)
+	{
+	  delta = read_memory_integer (pc + 2, 2, byte_order);
+
+	  /* Include the size of the jmp instruction (including the
+             0x66 prefix).  */
+	  delta += 4;
+	}
+      else
+	{
+	  delta = read_memory_integer (pc + 1, 4, byte_order);
+
+	  /* Include the size of the jmp instruction.  */
+	  delta += 5;
+	}
+      break;
+    case 0xeb:
+      /* Relative jump, disp8 (ignore data16).  */
+      delta = read_memory_integer (pc + data16 + 1, 1, byte_order);
+
+      delta += data16 + 2;
+      break;
+    }
+
+  return pc + delta;
+}
+
+/* Check whether PC points at a prologue for a function returning a
+   structure or union.  If so, it updates CACHE and returns the
+   address of the first instruction after the code sequence that
+   removes the "hidden" argument from the stack or CURRENT_PC,
+   whichever is smaller.  Otherwise, return PC.  */
+
+static CORE_ADDR
+i386_analyze_struct_return (CORE_ADDR pc, CORE_ADDR current_pc,
+			    struct i386_frame_cache *cache)
+{
+    return pc;
+}
+
+static CORE_ADDR
+i386_skip_probe (CORE_ADDR pc)
+{
+   return pc;
+}
+
+
+static CORE_ADDR
+i386_analyze_stack_align (CORE_ADDR pc, CORE_ADDR current_pc,
+			  struct i386_frame_cache *cache)
+{
+  return current_pc;
+}
+
+/* Maximum instruction length we need to handle.  */
+#define I386_MAX_MATCHED_INSN_LEN	6
+
+/* Instruction description.  */
+struct i386_insn
+{
+  size_t len;
+  gdb_byte insn[I386_MAX_MATCHED_INSN_LEN];
+  gdb_byte mask[I386_MAX_MATCHED_INSN_LEN];
+};
+
+/* Search for the instruction at PC in the list SKIP_INSNS.  Return
+   the first instruction description that matches.  Otherwise, return
+   NULL.  */
+
+static struct i386_insn *
+i386_match_insn (CORE_ADDR pc, struct i386_insn *skip_insns)
+{
+  return NULL;
+}
+
+
+/* Check whether PC points to a no-op instruction.  */
+static CORE_ADDR
+i386_skip_noop (CORE_ADDR pc)
+{
+  return pc; 
+}
+
+/* Check whether PC points at a code that sets up a new stack frame.
+   If so, it updates CACHE and returns the address of the first
+   instruction after the sequence that sets up the frame or LIMIT,
+   whichever is smaller.  If we don't recognize the code, return PC.  */
+
+static CORE_ADDR
+i386_analyze_frame_setup (struct gdbarch *gdbarch,
+			  CORE_ADDR pc, CORE_ADDR limit,
+			  struct i386_frame_cache *cache)
+{
+  return pc;
+}
+
+/* Check whether PC points at code that saves registers on the stack.
+   If so, it updates CACHE and returns the address of the first
+   instruction after the register saves or CURRENT_PC, whichever is
+   smaller.  Otherwise, return PC.  */
+
+static CORE_ADDR
+i386_analyze_register_saves (CORE_ADDR pc, CORE_ADDR current_pc,
+			     struct i386_frame_cache *cache)
+{
+  return pc;
+}
+
+/* Do a full analysis of the prologue at PC and update CACHE
+   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
+   address where the analysis stopped.
+
+   We handle these cases:
+
+   The startup sequence can be at the start of the function, or the
+   function can start with a branch to startup code at the end.
+
+   %ebp can be set up with either the 'enter' instruction, or "pushl
+   %ebp, movl %esp, %ebp" (`enter' is too slow to be useful, but was
+   once used in the System V compiler).
+
+   Local space is allocated just below the saved %ebp by either the
+   'enter' instruction, or by "subl $<size>, %esp".  'enter' has a
+   16-bit unsigned argument for space to allocate, and the 'addl'
+   instruction could have either a signed byte, or 32-bit immediate.
+
+   Next, the registers used by this function are pushed.  With the
+   System V compiler they will always be in the order: %edi, %esi,
+   %ebx (and sometimes a harmless bug causes it to also save but not
+   restore %eax); however, the code below is willing to see the pushes
+   in any order, and will handle up to 8 of them.
+ 
+   If the setup sequence is at the end of the function, then the next
+   instruction will be a branch back to the start.  */
+
+static CORE_ADDR
+i386_analyze_prologue (struct gdbarch *gdbarch,
+		       CORE_ADDR pc, CORE_ADDR current_pc,
+		       struct i386_frame_cache *cache)
+{
+  return pc;
+}
+
+/* Return PC of first real instruction.  */
+
+static CORE_ADDR
+i386_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
+{
+  CORE_ADDR func_start, func_end;
+  struct linetable_entry *item;
+  struct linetable *l;
+  struct symtab *symtab;
+  int i, count;
+
+  symtab = find_pc_symtab(start_pc);
+  if(!symtab)
+    return start_pc;
+
+  // This logic was based on 'skip_prologue_using_lineinfo' in symtab.c
+  l = LINETABLE (symtab);
+  if (l == NULL)
+    return start_pc;
+
+  if (!find_pc_partial_function (start_pc, NULL, &func_start, &func_end))
+    return start_pc;
+
+  count = 0;
+  for (i = 0; i < l->nitems; i++)
+  {
+    item = &(l->item[i]);
+    if (item->line > 0 && func_start <= item->pc && item->pc < func_end) {
+      count++;
+      if(count == 2) // Skip to the second line in the function so stack frame is good
+        return item->pc;
+    }
+  }
+
+  return start_pc;
+}
+
+/* Check that the code pointed to by PC corresponds to a call to
+   __main, skip it if so.  Return PC otherwise.  */
+
+CORE_ADDR
+i386_skip_main_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
+{
+  return pc;
+}
+
+/* This function is 64-bit safe.  */
+
+static CORE_ADDR
+i386_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  CORE_ADDR uloc;
+  gdb_byte buf[8];
+  int edp;
+  enum bfd_endian byte_order;
+
+  get_frame_register (next_frame, I386_ESP_REGNUM, &edp);
+
+  if(edp == 0xdddddddd) {
+    frame_unwind_register (next_frame, gdbarch_pc_regnum (gdbarch), buf);
+    uloc = extract_typed_address (buf, builtin_type (gdbarch)->builtin_func_ptr);
+  } else {
+    
+    /*fprintf(stderr, "edp+40 : %X\n", read_memory_unsigned_integer (edp+40, 4, byte_order)); 
+    fprintf(stderr, "edp+36 : %X\n", read_memory_unsigned_integer (edp+36, 4, byte_order)); 
+    fprintf(stderr, "edp+32 : %X\n", read_memory_unsigned_integer (edp+32, 4, byte_order)); 
+    fprintf(stderr, "edp+28 : %X\n", read_memory_unsigned_integer (edp+28, 4, byte_order));
+    fprintf(stderr, "edp+24 : %X\n", read_memory_unsigned_integer (edp+24, 4, byte_order));
+    fprintf(stderr, "edp+20 : %X\n", read_memory_unsigned_integer (edp+20, 4, byte_order)); 
+    fprintf(stderr, "edp+16 : %X\n", read_memory_unsigned_integer (edp+16, 4, byte_order)); 
+    fprintf(stderr, "edp+12 : %X\n", read_memory_unsigned_integer (edp+12, 4, byte_order)); 
+    fprintf(stderr, "edp+8 : %X\n", read_memory_unsigned_integer (edp+8, 4, byte_order));
+    fprintf(stderr, "edp+4 : %X\n", read_memory_unsigned_integer (edp+4, 4, byte_order)); 
+    fprintf(stderr, "edp-0 : %X\n", read_memory_unsigned_integer (edp, 4, byte_order));
+    fprintf(stderr, "edp-4 : %X\n", read_memory_unsigned_integer (edp-4, 4, byte_order));
+    fprintf(stderr, "edp-8 : %X\n", read_memory_unsigned_integer (edp-8, 4, byte_order));
+    fprintf(stderr, "edp-12: %X\n", read_memory_unsigned_integer (edp-12, 4, byte_order));
+    fprintf(stderr, "edp-16: %X\n", read_memory_unsigned_integer (edp-16, 4, byte_order));
+    fprintf(stderr, "edp-20: %X\n", read_memory_unsigned_integer (edp-20, 4, byte_order));*/
+    
+
+    byte_order = gdbarch_byte_order (gdbarch);
+    uloc = read_memory_unsigned_integer (edp, 4, byte_order);
+
+    //fprintf(stderr, "## level: %X\n", frame_relative_level(next_frame));
+    if(frame_relative_level(next_frame) >= 0)
+      uloc = read_memory_unsigned_integer (edp+20, 4, byte_order);
+
+    if(uloc == 1)
+      uloc = 0;
+  }
+
+  //fprintf(stderr, "### unwind: %X %X\n", edp, uloc);
+  return uloc;
+}
+
+
+/* Normal frames.  */
+
+static void
+i386_frame_cache_1 (struct frame_info *this_frame,
+		    struct i386_frame_cache *cache)
+{
+  struct gdbarch *gdbarch = get_frame_arch (this_frame);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  gdb_byte buf[4];
+  int i, edp;
+
+  /* In principle, for normal frames, %ebp holds the frame pointer,
+     which holds the base address for the current stack frame.
+     However, for functions that don't need it, the frame pointer is
+     optional.  For these "frameless" functions the frame pointer is
+     actually the frame pointer of the calling frame.  Signal
+     trampolines are just a special case of a "frameless" function.
+     They (usually) share their frame pointer with the frame that was
+     in progress when the signal occurred.  */
+
+  get_frame_register (this_frame, I386_ESP_REGNUM, &edp);
+  if(edp == 0xdddddddd) {
+    //fprintf(stderr, "i386_frame_cache_1: no edp\n");
+    cache->base = 0;
+    cache->base_p = 1;
+  } else {
+    cache->base = (ULONGEST)(edp+20);
+    cache->base = (cache->base << 32) >> 32;
+    cache->saved_sp = (ULONGEST)(edp+20);
+    cache->sp_offset = 0; //-20;
+    cache->saved_sp_reg = I386_ESP_REGNUM;
+    cache->pc = read_memory_unsigned_integer (edp+20, 4, byte_order);
+    cache->base_p = 1;
+    cache->saved_regs[I386_EIP_REGNUM] = edp+20;
+
+
+    /*fprintf(stderr, "pc   : %X\n", cache->pc);
+    fprintf(stderr, "edp, %llu, base: %llu\n", edp, cache->base);
+    fprintf(stderr, "edp+40 : %X\n", read_memory_unsigned_integer (edp+40, 4, byte_order)); 
+    fprintf(stderr, "edp+36 : %X\n", read_memory_unsigned_integer (edp+36, 4, byte_order)); 
+    fprintf(stderr, "edp+32 : %X\n", read_memory_unsigned_integer (edp+32, 4, byte_order)); 
+    fprintf(stderr, "edp+28 : %X\n", read_memory_unsigned_integer (edp+28, 4, byte_order));
+    fprintf(stderr, "edp+24 : %X\n", read_memory_unsigned_integer (edp+24, 4, byte_order)); 
+    fprintf(stderr, "edp+20 : %X\n", read_memory_unsigned_integer (edp+20, 4, byte_order)); 
+    fprintf(stderr, "edp+16 : %X\n", read_memory_unsigned_integer (edp+16, 4, byte_order)); 
+    fprintf(stderr, "edp+12 : %X\n", read_memory_unsigned_integer (edp+12, 4, byte_order)); 
+    fprintf(stderr, "edp+8 : %X\n", read_memory_unsigned_integer (edp+8, 4, byte_order));
+    fprintf(stderr, "edp+4 : %X\n", read_memory_unsigned_integer (edp+4, 4, byte_order)); 
+    fprintf(stderr, "edp-0 : %X\n", read_memory_unsigned_integer (edp, 4, byte_order));
+    fprintf(stderr, "edp-4 : %X\n", read_memory_unsigned_integer (edp-4, 4, byte_order));
+    fprintf(stderr, "edp-8 : %X\n", read_memory_unsigned_integer (edp-8, 4, byte_order));
+    fprintf(stderr, "edp-12: %X\n", read_memory_unsigned_integer (edp-12, 4, byte_order));
+    fprintf(stderr, "edp-16: %X\n", read_memory_unsigned_integer (edp-16, 4, byte_order));
+    fprintf(stderr, "edp-20: %X\n", read_memory_unsigned_integer (edp-20, 4, byte_order));*/
+  }
+}
+
+static struct i386_frame_cache *
+i386_frame_cache (struct frame_info *this_frame, void **this_cache)
+{
+  volatile struct gdb_exception ex;
+  struct i386_frame_cache *cache;
+
+  if (*this_cache)
+    return *this_cache;
+
+  cache = i386_alloc_frame_cache ();
+  *this_cache = cache;
+
+  TRY_CATCH (ex, RETURN_MASK_ERROR)
+    {
+      i386_frame_cache_1 (this_frame, cache);
+    }
+  if (ex.reason < 0 && ex.error != NOT_AVAILABLE_ERROR)
+    throw_exception (ex);
+
+  return cache;
+}
+
+static void
+i386_frame_this_id (struct frame_info *this_frame, void **this_cache,
+		    struct frame_id *this_id)
+{
+  struct i386_frame_cache *cache = i386_frame_cache (this_frame, this_cache);
+
+  /* This marks the outermost frame.  */
+  if (cache->base == 0)
+    return;
+
+  /* See the end of i386_push_dummy_call.  */
+  (*this_id) = frame_id_build (cache->base + 8, cache->pc);
+}
+
+static enum unwind_stop_reason
+i386_frame_unwind_stop_reason (struct frame_info *this_frame,
+			       void **this_cache)
+{
+  struct i386_frame_cache *cache = i386_frame_cache (this_frame, this_cache);
+
+  if (!cache->base_p)
+    return UNWIND_UNAVAILABLE;
+
+  /* This marks the outermost frame.  */
+  if (cache->base == 0)
+    return UNWIND_OUTERMOST;
+
+  return UNWIND_NO_REASON;
+}
+
+static struct value *
+i386_frame_prev_register (struct frame_info *this_frame, void **this_cache,
+			  int regnum)
+{
+  struct i386_frame_cache *cache = i386_frame_cache (this_frame, this_cache);
+
+  gdb_assert (regnum >= 0);
+
+  /* The System V ABI says that:
+
+     "The flags register contains the system flags, such as the
+     direction flag and the carry flag.  The direction flag must be
+     set to the forward (that is, zero) direction before entry and
+     upon exit from a function.  Other user flags have no specified
+     role in the standard calling sequence and are not preserved."
+
+     To guarantee the "upon exit" part of that statement we fake a
+     saved flags register that has its direction flag cleared.
+
+     Note that GCC doesn't seem to rely on the fact that the direction
+     flag is cleared after a function return; it always explicitly
+     clears the flag before operations where it matters.
+
+     FIXME: kettenis/20030316: I'm not quite sure whether this is the
+     right thing to do.  The way we fake the flags register here makes
+     it impossible to change it.  */
+
+  if (regnum == I386_EFLAGS_REGNUM)
+    {
+      ULONGEST val;
+
+      val = get_frame_register_unsigned (this_frame, regnum);
+      val &= ~(1 << 10);
+      return frame_unwind_got_constant (this_frame, regnum, val);
+    }
+
+  if (regnum == I386_EIP_REGNUM && cache->pc_in_eax)
+    return frame_unwind_got_register (this_frame, regnum, I386_EAX_REGNUM);
+
+  if (regnum == I386_ESP_REGNUM
+      && (cache->saved_sp != 0 || cache->saved_sp_reg != -1))
+    {
+      /* If the SP has been saved, but we don't know where, then this
+	 means that SAVED_SP_REG register was found unavailable back
+	 when we built the cache.  */
+      if (cache->saved_sp == 0)
+	return frame_unwind_got_register (this_frame, regnum,
+					  cache->saved_sp_reg);
+      else
+	return frame_unwind_got_constant (this_frame, regnum,
+					  cache->saved_sp);
+    }
+
+  if (regnum < I386_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
+    return frame_unwind_got_memory (this_frame, regnum,
+				    cache->saved_regs[regnum]);
+
+  return frame_unwind_got_register (this_frame, regnum, regnum);
+}
+
+static const struct frame_unwind i386_frame_unwind =
+{
+  NORMAL_FRAME,
+  i386_frame_unwind_stop_reason,
+  i386_frame_this_id,
+  i386_frame_prev_register,
+  NULL,
+  default_frame_sniffer
+};
+
+/* Normal frames, but in a function epilogue.  */
+
+/* The epilogue is defined here as the 'ret' instruction, which will
+   follow any instruction such as 'leave' or 'pop %ebp' that destroys
+   the function's stack frame.  */
+
+static int
+i386_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
+{
+  gdb_byte insn;
+
+  if (target_read_memory (pc, &insn, 1))
+    return 0;	/* Can't read memory at pc.  */
+
+  if (insn != 0xc3)	/* 'ret' instruction.  */
+    return 0;
+
+  return 1;
+}
+
+static int
+i386_epilogue_frame_sniffer (const struct frame_unwind *self,
+			     struct frame_info *this_frame,
+			     void **this_prologue_cache)
+{
+  if (frame_relative_level (this_frame) == 0)
+    return i386_in_function_epilogue_p (get_frame_arch (this_frame),
+					get_frame_pc (this_frame));
+  else
+    return 0;
+}
+
+static struct i386_frame_cache *
+i386_epilogue_frame_cache (struct frame_info *this_frame, void **this_cache)
+{
+  struct gdbarch *gdbarch = get_frame_arch (this_frame);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  volatile struct gdb_exception ex;
+  struct i386_frame_cache *cache;
+  gdb_byte buf[4];
+
+  if (*this_cache)
+    return *this_cache;
+
+  cache = i386_alloc_frame_cache ();
+  *this_cache = cache;
+
+  TRY_CATCH (ex, RETURN_MASK_ERROR)
+    {
+      /* Cache base will be %esp plus cache->sp_offset (-4).  */
+      get_frame_register (this_frame, I386_ESP_REGNUM, buf);
+      cache->base = extract_unsigned_integer (buf, 4,
+					      byte_order) + cache->sp_offset;
+
+      /* Cache pc will be the frame func.  */
+      cache->pc = get_frame_pc (this_frame);
+
+      /* The saved %esp will be at cache->base plus 8.  */
+      cache->saved_sp = cache->base + 8;
+
+      /* The saved %eip will be at cache->base plus 4.  */
+      cache->saved_regs[I386_EIP_REGNUM] = cache->base + 4;
+
+      cache->base_p = 1;
+    }
+  if (ex.reason < 0 && ex.error != NOT_AVAILABLE_ERROR)
+    throw_exception (ex);
+
+  return cache;
+}
+
+static enum unwind_stop_reason
+i386_epilogue_frame_unwind_stop_reason (struct frame_info *this_frame,
+					void **this_cache)
+{
+  struct i386_frame_cache *cache
+    = i386_epilogue_frame_cache (this_frame, this_cache);
+
+  if (!cache->base_p)
+    return UNWIND_UNAVAILABLE;
+
+  return UNWIND_NO_REASON;
+}
+
+static void
+i386_epilogue_frame_this_id (struct frame_info *this_frame,
+			     void **this_cache,
+			     struct frame_id *this_id)
+{
+  struct i386_frame_cache *cache = i386_epilogue_frame_cache (this_frame,
+							      this_cache);
+
+  if (!cache->base_p)
+    return;
+
+  (*this_id) = frame_id_build (cache->base + 8, cache->pc);
+}
+
+static const struct frame_unwind i386_epilogue_frame_unwind =
+{
+  NORMAL_FRAME,
+  i386_epilogue_frame_unwind_stop_reason,
+  i386_epilogue_frame_this_id,
+  i386_frame_prev_register,
+  NULL, 
+  i386_epilogue_frame_sniffer
+};
+
+
+/* Signal trampolines.  */
+
+static struct i386_frame_cache *
+i386_sigtramp_frame_cache (struct frame_info *this_frame, void **this_cache)
+{
+  struct gdbarch *gdbarch = get_frame_arch (this_frame);
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  volatile struct gdb_exception ex;
+  struct i386_frame_cache *cache;
+  CORE_ADDR addr;
+  gdb_byte buf[4];
+
+  if (*this_cache)
+    return *this_cache;
+
+  cache = i386_alloc_frame_cache ();
+
+  TRY_CATCH (ex, RETURN_MASK_ERROR)
+    {
+      get_frame_register (this_frame, I386_ESP_REGNUM, buf);
+      cache->base = extract_unsigned_integer (buf, 4, byte_order) - 4;
+
+      addr = tdep->sigcontext_addr (this_frame);
+      if (tdep->sc_reg_offset)
+	{
+	  int i;
+
+	  gdb_assert (tdep->sc_num_regs <= I386_NUM_SAVED_REGS);
+
+	  for (i = 0; i < tdep->sc_num_regs; i++)
+	    if (tdep->sc_reg_offset[i] != -1)
+	      cache->saved_regs[i] = addr + tdep->sc_reg_offset[i];
+	}
+      else
+	{
+	  cache->saved_regs[I386_EIP_REGNUM] = addr + tdep->sc_pc_offset;
+	  cache->saved_regs[I386_ESP_REGNUM] = addr + tdep->sc_sp_offset;
+	}
+
+      cache->base_p = 1;
+    }
+  if (ex.reason < 0 && ex.error != NOT_AVAILABLE_ERROR)
+    throw_exception (ex);
+
+  *this_cache = cache;
+  return cache;
+}
+
+static enum unwind_stop_reason
+i386_sigtramp_frame_unwind_stop_reason (struct frame_info *this_frame,
+					void **this_cache)
+{
+  struct i386_frame_cache *cache =
+    i386_sigtramp_frame_cache (this_frame, this_cache);
+
+  if (!cache->base_p)
+    return UNWIND_UNAVAILABLE;
+
+  return UNWIND_NO_REASON;
+}
+
+static void
+i386_sigtramp_frame_this_id (struct frame_info *this_frame, void **this_cache,
+			     struct frame_id *this_id)
+{
+  struct i386_frame_cache *cache =
+    i386_sigtramp_frame_cache (this_frame, this_cache);
+
+  if (!cache->base_p)
+    return;
+
+  /* See the end of i386_push_dummy_call.  */
+  (*this_id) = frame_id_build (cache->base + 8, get_frame_pc (this_frame));
+}
+
+static struct value *
+i386_sigtramp_frame_prev_register (struct frame_info *this_frame,
+				   void **this_cache, int regnum)
+{
+  /* Make sure we've initialized the cache.  */
+  i386_sigtramp_frame_cache (this_frame, this_cache);
+
+  return i386_frame_prev_register (this_frame, this_cache, regnum);
+}
+
+static int
+i386_sigtramp_frame_sniffer (const struct frame_unwind *self,
+			     struct frame_info *this_frame,
+			     void **this_prologue_cache)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));
+
+  /* We shouldn't even bother if we don't have a sigcontext_addr
+     handler.  */
+  if (tdep->sigcontext_addr == NULL)
+    return 0;
+
+  if (tdep->sigtramp_p != NULL)
+    {
+      if (tdep->sigtramp_p (this_frame))
+	return 1;
+    }
+
+  if (tdep->sigtramp_start != 0)
+    {
+      CORE_ADDR pc = get_frame_pc (this_frame);
+
+      gdb_assert (tdep->sigtramp_end != 0);
+      if (pc >= tdep->sigtramp_start && pc < tdep->sigtramp_end)
+	return 1;
+    }
+
+  return 0;
+}
+
+static const struct frame_unwind i386_sigtramp_frame_unwind =
+{
+  SIGTRAMP_FRAME,
+  i386_sigtramp_frame_unwind_stop_reason,
+  i386_sigtramp_frame_this_id,
+  i386_sigtramp_frame_prev_register,
+  NULL,
+  i386_sigtramp_frame_sniffer
+};
+
+
+static CORE_ADDR
+i386_frame_base_address (struct frame_info *this_frame, void **this_cache)
+{
+  struct i386_frame_cache *cache = i386_frame_cache (this_frame, this_cache);
+
+  return cache->base;
+}
+
+static const struct frame_base i386_frame_base =
+{
+  &i386_frame_unwind,
+  i386_frame_base_address,
+  i386_frame_base_address,
+  i386_frame_base_address
+};
+
+static struct frame_id
+i386_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
+{
+  CORE_ADDR fp;
+
+  fp = get_frame_register_unsigned (this_frame, I386_EBP_REGNUM);
+
+  /* See the end of i386_push_dummy_call.  */
+  return frame_id_build (fp + 8, get_frame_pc (this_frame));
+}
+
+
+/* Figure out where the longjmp will land.  Slurp the args out of the
+   stack.  We expect the first arg to be a pointer to the jmp_buf
+   structure from which we extract the address that we will land at.
+   This address is copied into PC.  This routine returns non-zero on
+   success.  */
+
+static int
+i386_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)
+{
+  gdb_byte buf[4];
+  CORE_ADDR sp, jb_addr;
+  struct gdbarch *gdbarch = get_frame_arch (frame);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  int jb_pc_offset = gdbarch_tdep (gdbarch)->jb_pc_offset;
+
+  /* If JB_PC_OFFSET is -1, we have no way to find out where the
+     longjmp will land.  */
+  if (jb_pc_offset == -1)
+    return 0;
+
+  get_frame_register (frame, I386_ESP_REGNUM, buf);
+  sp = extract_unsigned_integer (buf, 4, byte_order);
+  if (target_read_memory (sp + 4, buf, 4))
+    return 0;
+
+  jb_addr = extract_unsigned_integer (buf, 4, byte_order);
+  if (target_read_memory (jb_addr + jb_pc_offset, buf, 4))
+    return 0;
+
+  *pc = extract_unsigned_integer (buf, 4, byte_order);
+  return 1;
+}
+
+
+/* Check whether TYPE must be 16-byte-aligned when passed as a
+   function argument.  16-byte vectors, _Decimal128 and structures or
+   unions containing such types must be 16-byte-aligned; other
+   arguments are 4-byte-aligned.  */
+
+static int
+i386_16_byte_align_p (struct type *type)
+{
+  return 1;
+#if 0
+  type = check_typedef (type);
+  if ((TYPE_CODE (type) == TYPE_CODE_DECFLOAT
+       || (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type)))
+      && TYPE_LENGTH (type) == 16)
+    return 1;
+  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
+    return i386_16_byte_align_p (TYPE_TARGET_TYPE (type));
+  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
+      || TYPE_CODE (type) == TYPE_CODE_UNION)
+    {
+      int i;
+      for (i = 0; i < TYPE_NFIELDS (type); i++)
+	{
+	  if (i386_16_byte_align_p (TYPE_FIELD_TYPE (type, i)))
+	    return 1;
+	}
+    }
+  return 0;
+#endif
+}
+
+static CORE_ADDR
+i386_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
+		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
+		      struct value **args, CORE_ADDR sp, int struct_return,
+		      CORE_ADDR struct_addr)
+{
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  gdb_byte buf[4];
+  int i;
+  int write_pass;
+  int args_space = 0;
+
+  /* Determine the total space required for arguments and struct
+     return address in a first pass (allowing for 16-byte-aligned
+     arguments), then push arguments in a second pass.  */
+
+  for (write_pass = 0; write_pass < 2; write_pass++)
+    {
+      int args_space_used = 0;
+      int have_16_byte_aligned_arg = 0;
+
+      if (struct_return)
+	{
+	  if (write_pass)
+	    {
+	      /* Push value address.  */
+	      store_unsigned_integer (buf, 4, byte_order, struct_addr);
+	      write_memory (sp, buf, 4);
+	      args_space_used += 4;
+	    }
+	  else
+	    args_space += 4;
+	}
+
+      for (i = 0; i < nargs; i++)
+	{
+	  int len = TYPE_LENGTH (value_enclosing_type (args[i]));
+
+	  if (write_pass)
+	    {
+	      if (i386_16_byte_align_p (value_enclosing_type (args[i])))
+		args_space_used = align_up (args_space_used, 16);
+
+	      write_memory (sp + args_space_used,
+			    value_contents_all (args[i]), len);
+	      /* The System V ABI says that:
+
+	      "An argument's size is increased, if necessary, to make it a
+	      multiple of [32-bit] words.  This may require tail padding,
+	      depending on the size of the argument."
+
+	      This makes sure the stack stays word-aligned.  */
+	      args_space_used += align_up (len, 4);
+	    }
+	  else
+	    {
+	      if (i386_16_byte_align_p (value_enclosing_type (args[i])))
+		{
+		  args_space = align_up (args_space, 16);
+		  have_16_byte_aligned_arg = 1;
+		}
+	      args_space += align_up (len, 4);
+	    }
+	}
+
+      if (!write_pass)
+	{
+	  if (have_16_byte_aligned_arg)
+	    args_space = align_up (args_space, 16);
+	  sp -= args_space;
+	}
+    }
+
+  // no return address in avm2 stack frame
+#if 0
+  /* Store return address.  */
+  sp -= 4;
+  store_unsigned_integer (buf, 4, byte_order, bp_addr);
+  write_memory (sp, buf, 4);
+#endif
+
+  /* Finally, update the stack pointer...  */
+  store_unsigned_integer (buf, 4, byte_order, sp);
+  regcache_cooked_write (regcache, I386_ESP_REGNUM, buf);
+
+  /* ...and fake a frame pointer.  */
+  regcache_cooked_write (regcache, I386_EBP_REGNUM, buf);
+
+  /* MarkK wrote: This "+ 8" is all over the place:
+     (i386_frame_this_id, i386_sigtramp_frame_this_id,
+     i386_dummy_id).  It's there, since all frame unwinders for
+     a given target have to agree (within a certain margin) on the
+     definition of the stack address of a frame.  Otherwise frame id
+     comparison might not work correctly.  Since DWARF2/GCC uses the
+     stack address *before* the function call as a frame's CFA.  On
+     the i386, when %ebp is used as a frame pointer, the offset
+     between the contents %ebp and the CFA as defined by GCC.  */
+  return sp + 8;
+}
+
+/* These registers are used for returning integers (and on some
+   targets also for returning `struct' and `union' values when their
+   size and alignment match an integer type).  */
+#define LOW_RETURN_REGNUM	I386_EAX_REGNUM /* %eax */
+#define HIGH_RETURN_REGNUM	I386_EDX_REGNUM /* %edx */
+
+/* Read, for architecture GDBARCH, a function return value of TYPE
+   from REGCACHE, and copy that into VALBUF.  */
+
+static void
+i386_extract_return_value (struct gdbarch *gdbarch, struct type *type,
+			   struct regcache *regcache, gdb_byte *valbuf)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int len = TYPE_LENGTH (type);
+  gdb_byte buf[I386_MAX_REGISTER_SIZE];
+
+  if (TYPE_CODE (type) == TYPE_CODE_FLT)
+    {
+      if (tdep->st0_regnum < 0)
+	{
+	  warning (_("Cannot find floating-point return value."));
+	  memset (valbuf, 0, len);
+	  return;
+	}
+
+      /* Floating-point return values can be found in %st(0).  Convert
+	 its contents to the desired type.  This is probably not
+	 exactly how it would happen on the target itself, but it is
+	 the best we can do.  */
+      regcache_raw_read (regcache, I386_ST0_REGNUM, buf);
+      struct type *dbltype = tdesc_find_type (gdbarch, "ieee_double");
+      convert_typed_floating (buf, dbltype, valbuf, type);
+    }
+  else
+    {
+      int low_size = register_size (gdbarch, LOW_RETURN_REGNUM);
+      int high_size = register_size (gdbarch, HIGH_RETURN_REGNUM);
+
+      if (len <= low_size)
+	{
+	  regcache_raw_read (regcache, LOW_RETURN_REGNUM, buf);
+	  memcpy (valbuf, buf, len);
+	}
+      else if (len <= (low_size + high_size))
+	{
+	  regcache_raw_read (regcache, LOW_RETURN_REGNUM, buf);
+	  memcpy (valbuf, buf, low_size);
+	  regcache_raw_read (regcache, HIGH_RETURN_REGNUM, buf);
+	  memcpy (valbuf + low_size, buf, len - low_size);
+	}
+      else
+	internal_error (__FILE__, __LINE__,
+			_("Cannot extract return value of %d bytes long."),
+			len);
+    }
+}
+
+/* Write, for architecture GDBARCH, a function return value of TYPE
+   from VALBUF into REGCACHE.  */
+
+static void
+i386_store_return_value (struct gdbarch *gdbarch, struct type *type,
+			 struct regcache *regcache, const gdb_byte *valbuf)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int len = TYPE_LENGTH (type);
+
+  if (TYPE_CODE (type) == TYPE_CODE_FLT)
+    {
+      ULONGEST fstat;
+      gdb_byte buf[I386_MAX_REGISTER_SIZE];
+
+      if (tdep->st0_regnum < 0)
+	{
+	  warning (_("Cannot set floating-point return value."));
+	  return;
+	}
+
+      /* Returning floating-point values is a bit tricky.  Apart from
+         storing the return value in %st(0), we have to simulate the
+         state of the FPU at function return point.  */
+
+      /* Convert the value found in VALBUF to the extended
+	 floating-point format used by the FPU.  This is probably
+	 not exactly how it would happen on the target itself, but
+	 it is the best we can do.  */
+      convert_typed_floating (valbuf, type, buf, i387_ext_type (gdbarch));
+      regcache_raw_write (regcache, I386_ST0_REGNUM, buf);
+
+      /* Set the top of the floating-point register stack to 7.  The
+         actual value doesn't really matter, but 7 is what a normal
+         function return would end up with if the program started out
+         with a freshly initialized FPU.  */
+      regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM (tdep), &fstat);
+      fstat |= (7 << 11);
+      regcache_raw_write_unsigned (regcache, I387_FSTAT_REGNUM (tdep), fstat);
+
+      /* Mark %st(1) through %st(7) as empty.  Since we set the top of
+         the floating-point register stack to 7, the appropriate value
+         for the tag word is 0x3fff.  */
+      regcache_raw_write_unsigned (regcache, I387_FTAG_REGNUM (tdep), 0x3fff);
+    }
+  else
+    {
+      int low_size = register_size (gdbarch, LOW_RETURN_REGNUM);
+      int high_size = register_size (gdbarch, HIGH_RETURN_REGNUM);
+
+      if (len <= low_size)
+	regcache_raw_write_part (regcache, LOW_RETURN_REGNUM, 0, len, valbuf);
+      else if (len <= (low_size + high_size))
+	{
+	  regcache_raw_write (regcache, LOW_RETURN_REGNUM, valbuf);
+	  regcache_raw_write_part (regcache, HIGH_RETURN_REGNUM, 0,
+				   len - low_size, valbuf + low_size);
+	}
+      else
+	internal_error (__FILE__, __LINE__,
+			_("Cannot store return value of %d bytes long."), len);
+    }
+}
+
+
+/* This is the variable that is set with "set struct-convention", and
+   its legitimate values.  */
+static const char default_struct_convention[] = "default";
+static const char pcc_struct_convention[] = "pcc";
+static const char reg_struct_convention[] = "reg";
+static const char *valid_conventions[] =
+{
+  default_struct_convention,
+  pcc_struct_convention,
+  reg_struct_convention,
+  NULL
+};
+static const char *struct_convention = default_struct_convention;
+
+/* Return non-zero if TYPE, which is assumed to be a structure,
+   a union type, or an array type, should be returned in registers
+   for architecture GDBARCH.  */
+
+static int
+i386_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  enum type_code code = TYPE_CODE (type);
+  int len = TYPE_LENGTH (type);
+
+  gdb_assert (code == TYPE_CODE_STRUCT
+              || code == TYPE_CODE_UNION
+              || code == TYPE_CODE_ARRAY);
+
+/*
+  if (struct_convention == pcc_struct_convention
+      || (struct_convention == default_struct_convention
+	  && tdep->struct_return == pcc_struct_return))
+    return 0;
+    */
+
+  /* Structures consisting of a single `float', `double' or 'long
+     double' member are returned in %st(0).  */
+  if (code == TYPE_CODE_STRUCT && TYPE_NFIELDS (type) == 1)
+    {
+      type = check_typedef (TYPE_FIELD_TYPE (type, 0));
+      if (TYPE_CODE (type) == TYPE_CODE_FLT)
+	return (len == 4 || len == 8 || len == 12);
+    }
+
+  return (len == 1 || len == 2 || len == 4 || len == 8);
+}
+
+/* Determine, for architecture GDBARCH, how a return value of TYPE
+   should be returned.  If it is supposed to be returned in registers,
+   and READBUF is non-zero, read the appropriate value from REGCACHE,
+   and copy it into READBUF.  If WRITEBUF is non-zero, write the value
+   from WRITEBUF into REGCACHE.  */
+
+static enum return_value_convention
+i386_return_value (struct gdbarch *gdbarch, struct type *func_type,
+		   struct type *type, struct regcache *regcache,
+		   gdb_byte *readbuf, const gdb_byte *writebuf)
+{
+  enum type_code code = TYPE_CODE (type);
+
+  if (((code == TYPE_CODE_STRUCT
+	|| code == TYPE_CODE_UNION
+	|| code == TYPE_CODE_ARRAY)
+       && !i386_reg_struct_return_p (gdbarch, type))
+      /* 128-bit decimal float uses the struct return convention.  */
+      || (code == TYPE_CODE_DECFLOAT && TYPE_LENGTH (type) == 16))
+    {
+      /* The System V ABI says that:
+
+	 "A function that returns a structure or union also sets %eax
+	 to the value of the original address of the caller's area
+	 before it returns.  Thus when the caller receives control
+	 again, the address of the returned object resides in register
+	 %eax and can be used to access the object."
+
+	 So the ABI guarantees that we can always find the return
+	 value just after the function has returned.  */
+
+      /* Note that the ABI doesn't mention functions returning arrays,
+         which is something possible in certain languages such as Ada.
+         In this case, the value is returned as if it was wrapped in
+         a record, so the convention applied to records also applies
+         to arrays.  */
+
+#if 0
+      if (readbuf)
+	{
+	  ULONGEST addr;
+
+	  regcache_raw_read_unsigned (regcache, I386_EAX_REGNUM, &addr);
+	  read_memory (addr, readbuf, TYPE_LENGTH (type));
+	}
+      return RETURN_VALUE_ABI_RETURNS_ADDRESS;
+#endif
+
+      return RETURN_VALUE_STRUCT_CONVENTION;
+    }
+
+  /* This special case is for structures consisting of a single
+     `float', `double' or 'long double' member.  These structures are
+     returned in %st(0).  For these structures, we call ourselves
+     recursively, changing TYPE into the type of the first member of
+     the structure.  Since that should work for all structures that
+     have only one member, we don't bother to check the member's type
+     here.  */
+  if (code == TYPE_CODE_STRUCT && TYPE_NFIELDS (type) == 1)
+    {
+      type = check_typedef (TYPE_FIELD_TYPE (type, 0));
+      return i386_return_value (gdbarch, func_type, type, regcache,
+				readbuf, writebuf);
+    }
+
+  if (readbuf)
+    i386_extract_return_value (gdbarch, type, regcache, readbuf);
+  if (writebuf)
+    i386_store_return_value (gdbarch, type, regcache, writebuf);
+
+  return RETURN_VALUE_REGISTER_CONVENTION;
+}
+
+
+struct type *
+i387_ext_type (struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  if (!tdep->i387_ext_type)
+    {
+      tdep->i387_ext_type = tdesc_find_type (gdbarch, "i387_ext");
+      gdb_assert (tdep->i387_ext_type != NULL);
+    }
+
+  return tdep->i387_ext_type;
+}
+
+/* Construct vector type for pseudo YMM registers.  We can't use
+   tdesc_find_type since YMM isn't described in target description.  */
+
+static struct type *
+i386_ymm_type (struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  if (!tdep->i386_ymm_type)
+    {
+      const struct builtin_type *bt = builtin_type (gdbarch);
+
+      /* The type we're building is this: */
+#if 0
+      union __gdb_builtin_type_vec256i
+      {
+        int128_t uint128[2];
+        int64_t v2_int64[4];
+        int32_t v4_int32[8];
+        int16_t v8_int16[16];
+        int8_t v16_int8[32];
+        double v2_double[4];
+        float v4_float[8];
+      };
+#endif
+
+      struct type *t;
+
+      t = arch_composite_type (gdbarch,
+			       "__gdb_builtin_type_vec256i", TYPE_CODE_UNION);
+      append_composite_type_field (t, "v8_float",
+				   init_vector_type (bt->builtin_float, 8));
+      append_composite_type_field (t, "v4_double",
+				   init_vector_type (bt->builtin_double, 4));
+      append_composite_type_field (t, "v32_int8",
+				   init_vector_type (bt->builtin_int8, 32));
+      append_composite_type_field (t, "v16_int16",
+				   init_vector_type (bt->builtin_int16, 16));
+      append_composite_type_field (t, "v8_int32",
+				   init_vector_type (bt->builtin_int32, 8));
+      append_composite_type_field (t, "v4_int64",
+				   init_vector_type (bt->builtin_int64, 4));
+      append_composite_type_field (t, "v2_int128",
+				   init_vector_type (bt->builtin_int128, 2));
+
+      TYPE_VECTOR (t) = 1;
+      TYPE_NAME (t) = "builtin_type_vec256i";
+      tdep->i386_ymm_type = t;
+    }
+
+  return tdep->i386_ymm_type;
+}
+
+/* Construct vector type for MMX registers.  */
+static struct type *
+i386_mmx_type (struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  if (!tdep->i386_mmx_type)
+    {
+      const struct builtin_type *bt = builtin_type (gdbarch);
+
+      /* The type we're building is this: */
+#if 0
+      union __gdb_builtin_type_vec64i
+      {
+        int64_t uint64;
+        int32_t v2_int32[2];
+        int16_t v4_int16[4];
+        int8_t v8_int8[8];
+      };
+#endif
+
+      struct type *t;
+
+      t = arch_composite_type (gdbarch,
+			       "__gdb_builtin_type_vec64i", TYPE_CODE_UNION);
+
+      append_composite_type_field (t, "uint64", bt->builtin_int64);
+      append_composite_type_field (t, "v2_int32",
+				   init_vector_type (bt->builtin_int32, 2));
+      append_composite_type_field (t, "v4_int16",
+				   init_vector_type (bt->builtin_int16, 4));
+      append_composite_type_field (t, "v8_int8",
+				   init_vector_type (bt->builtin_int8, 8));
+
+      TYPE_VECTOR (t) = 1;
+      TYPE_NAME (t) = "builtin_type_vec64i";
+      tdep->i386_mmx_type = t;
+    }
+
+  return tdep->i386_mmx_type;
+}
+
+/* Return the GDB type object for the "standard" data type of data in
+   register REGNUM.  */
+
+static struct type *
+i386_pseudo_register_type (struct gdbarch *gdbarch, int regnum)
+{
+  if (i386_mmx_regnum_p (gdbarch, regnum))
+    return i386_mmx_type (gdbarch);
+  else if (i386_ymm_regnum_p (gdbarch, regnum))
+    return i386_ymm_type (gdbarch);
+  else
+    {
+      const struct builtin_type *bt = builtin_type (gdbarch);
+      if (i386_byte_regnum_p (gdbarch, regnum))
+	return bt->builtin_int8;
+      else if (i386_word_regnum_p (gdbarch, regnum))
+	return bt->builtin_int16;
+      else if (i386_dword_regnum_p (gdbarch, regnum))
+	return bt->builtin_int32;
+    }
+
+  internal_error (__FILE__, __LINE__, _("invalid regnum"));
+}
+
+/* Map a cooked register onto a raw register or memory.  For the i386,
+   the MMX registers need to be mapped onto floating point registers.  */
+
+static int
+i386_mmx_regnum_to_fp_regnum (struct regcache *regcache, int regnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
+  int mmxreg, fpreg;
+  ULONGEST fstat;
+  int tos;
+
+  mmxreg = regnum - tdep->mm0_regnum;
+  regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM (tdep), &fstat);
+  tos = (fstat >> 11) & 0x7;
+  fpreg = (mmxreg + tos) % 8;
+
+  return (I387_ST0_REGNUM (tdep) + fpreg);
+}
+
+enum register_status
+i386_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
+			   int regnum, gdb_byte *buf)
+{
+  gdb_byte raw_buf[MAX_REGISTER_SIZE];
+  enum register_status status;
+
+  if (i386_mmx_regnum_p (gdbarch, regnum))
+    {
+      int fpnum = i386_mmx_regnum_to_fp_regnum (regcache, regnum);
+
+      /* Extract (always little endian).  */
+      status = regcache_raw_read (regcache, fpnum, raw_buf);
+      if (status != REG_VALID)
+	return status;
+      memcpy (buf, raw_buf, register_size (gdbarch, regnum));
+    }
+  else
+    {
+      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+      if (i386_ymm_regnum_p (gdbarch, regnum))
+	{
+	  regnum -= tdep->ymm0_regnum;
+
+	  /* Extract (always little endian).  Read lower 128bits.  */
+	  status = regcache_raw_read (regcache,
+				      I387_XMM0_REGNUM (tdep) + regnum,
+				      raw_buf);
+	  if (status != REG_VALID)
+	    return status;
+	  memcpy (buf, raw_buf, 16);
+	  /* Read upper 128bits.  */
+	  status = regcache_raw_read (regcache,
+				      tdep->ymm0h_regnum + regnum,
+				      raw_buf);
+	  if (status != REG_VALID)
+	    return status;
+	  memcpy (buf + 16, raw_buf, 16);
+	}
+      else if (i386_word_regnum_p (gdbarch, regnum))
+	{
+	  int gpnum = regnum - tdep->ax_regnum;
+
+	  /* Extract (always little endian).  */
+	  status = regcache_raw_read (regcache, gpnum, raw_buf);
+	  if (status != REG_VALID)
+	    return status;
+	  memcpy (buf, raw_buf, 2);
+	}
+      else if (i386_byte_regnum_p (gdbarch, regnum))
+	{
+	  /* Check byte pseudo registers last since this function will
+	     be called from amd64_pseudo_register_read, which handles
+	     byte pseudo registers differently.  */
+	  int gpnum = regnum - tdep->al_regnum;
+
+	  /* Extract (always little endian).  We read both lower and
+	     upper registers.  */
+	  status = regcache_raw_read (regcache, gpnum % 4, raw_buf);
+	  if (status != REG_VALID)
+	    return status;
+	  if (gpnum >= 4)
+	    memcpy (buf, raw_buf + 1, 1);
+	  else
+	    memcpy (buf, raw_buf, 1);
+	}
+      else
+	internal_error (__FILE__, __LINE__, _("invalid regnum"));
+    }
+
+  return REG_VALID;
+}
+
+void
+i386_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
+			    int regnum, const gdb_byte *buf)
+{
+  gdb_byte raw_buf[MAX_REGISTER_SIZE];
+
+  if (i386_mmx_regnum_p (gdbarch, regnum))
+    {
+      int fpnum = i386_mmx_regnum_to_fp_regnum (regcache, regnum);
+
+      /* Read ...  */
+      regcache_raw_read (regcache, fpnum, raw_buf);
+      /* ... Modify ... (always little endian).  */
+      memcpy (raw_buf, buf, register_size (gdbarch, regnum));
+      /* ... Write.  */
+      regcache_raw_write (regcache, fpnum, raw_buf);
+    }
+  else
+    {
+      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+      if (i386_ymm_regnum_p (gdbarch, regnum))
+	{
+	  regnum -= tdep->ymm0_regnum;
+
+	  /* ... Write lower 128bits.  */
+	  regcache_raw_write (regcache,
+			     I387_XMM0_REGNUM (tdep) + regnum,
+			     buf);
+	  /* ... Write upper 128bits.  */
+	  regcache_raw_write (regcache,
+			     tdep->ymm0h_regnum + regnum,
+			     buf + 16);
+	}
+      else if (i386_word_regnum_p (gdbarch, regnum))
+	{
+	  int gpnum = regnum - tdep->ax_regnum;
+
+	  /* Read ...  */
+	  regcache_raw_read (regcache, gpnum, raw_buf);
+	  /* ... Modify ... (always little endian).  */
+	  memcpy (raw_buf, buf, 2);
+	  /* ... Write.  */
+	  regcache_raw_write (regcache, gpnum, raw_buf);
+	}
+      else if (i386_byte_regnum_p (gdbarch, regnum))
+	{
+	  /* Check byte pseudo registers last since this function will
+	     be called from amd64_pseudo_register_read, which handles
+	     byte pseudo registers differently.  */
+	  int gpnum = regnum - tdep->al_regnum;
+
+	  /* Read ...  We read both lower and upper registers.  */
+	  regcache_raw_read (regcache, gpnum % 4, raw_buf);
+	  /* ... Modify ... (always little endian).  */
+	  if (gpnum >= 4)
+	    memcpy (raw_buf + 1, buf, 1);
+	  else
+	    memcpy (raw_buf, buf, 1);
+	  /* ... Write.  */
+	  regcache_raw_write (regcache, gpnum % 4, raw_buf);
+	}
+      else
+	internal_error (__FILE__, __LINE__, _("invalid regnum"));
+    }
+}
+
+
+/* Return the register number of the register allocated by GCC after
+   REGNUM, or -1 if there is no such register.  */
+
+static int
+i386_next_regnum (int regnum)
+{
+  /* GCC allocates the registers in the order:
+
+     %eax, %edx, %ecx, %ebx, %esi, %edi, %ebp, %esp, ...
+
+     Since storing a variable in %esp doesn't make any sense we return
+     -1 for %ebp and for %esp itself.  */
+  static int next_regnum[] =
+  {
+    I386_EDX_REGNUM,		/* Slot for %eax.  */
+    I386_EBX_REGNUM,		/* Slot for %ecx.  */
+    I386_ECX_REGNUM,		/* Slot for %edx.  */
+    I386_ESI_REGNUM,		/* Slot for %ebx.  */
+    -1, -1,			/* Slots for %esp and %ebp.  */
+    I386_EDI_REGNUM,		/* Slot for %esi.  */
+    I386_EBP_REGNUM		/* Slot for %edi.  */
+  };
+
+  if (regnum >= 0 && regnum < sizeof (next_regnum) / sizeof (next_regnum[0]))
+    return next_regnum[regnum];
+
+  return -1;
+}
+
+/* Return nonzero if a value of type TYPE stored in register REGNUM
+   needs any special handling.  */
+
+static int
+i386_convert_register_p (struct gdbarch *gdbarch,
+			 int regnum, struct type *type)
+{
+  int len = TYPE_LENGTH (type);
+
+  /* Values may be spread across multiple registers.  Most debugging
+     formats aren't expressive enough to specify the locations, so
+     some heuristics is involved.  Right now we only handle types that
+     have a length that is a multiple of the word size, since GCC
+     doesn't seem to put any other types into registers.  */
+  if (len > 4 && len % 4 == 0)
+    {
+      int last_regnum = regnum;
+
+      while (len > 4)
+	{
+	  last_regnum = i386_next_regnum (last_regnum);
+	  len -= 4;
+	}
+
+      if (last_regnum != -1)
+	return 1;
+    }
+
+  return 0;
+  //return i387_convert_register_p (gdbarch, regnum, type);
+}
+
+/* Read a value of type TYPE from register REGNUM in frame FRAME, and
+   return its contents in TO.  */
+
+static int
+i386_register_to_value (struct frame_info *frame, int regnum,
+			struct type *type, gdb_byte *to,
+			int *optimizedp, int *unavailablep)
+{
+  struct gdbarch *gdbarch = get_frame_arch (frame);
+  int len = TYPE_LENGTH (type);
+
+  if (i386_fp_regnum_p (gdbarch, regnum))
+    return 1;
+    //return i387_register_to_value (frame, regnum, type, to,
+    //				   optimizedp, unavailablep);
+
+  /* Read a value spread across multiple registers.  */
+
+  gdb_assert (len > 4 && len % 4 == 0);
+
+  while (len > 0)
+    {
+      gdb_assert (regnum != -1);
+      gdb_assert (register_size (gdbarch, regnum) == 4);
+
+      if (!get_frame_register_bytes (frame, regnum, 0,
+				     register_size (gdbarch, regnum),
+				     to, optimizedp, unavailablep))
+	return 0;
+
+      regnum = i386_next_regnum (regnum);
+      len -= 4;
+      to += 4;
+    }
+
+  *optimizedp = *unavailablep = 0;
+  return 1;
+}
+
+/* Write the contents FROM of a value of type TYPE into register
+   REGNUM in frame FRAME.  */
+
+static void
+i386_value_to_register (struct frame_info *frame, int regnum,
+			struct type *type, const gdb_byte *from)
+{
+  int len = TYPE_LENGTH (type);
+
+  if (i386_fp_regnum_p (get_frame_arch (frame), regnum))
+    {
+      //i387_value_to_register (frame, regnum, type, from);
+      return;
+    }
+
+  /* Write a value spread across multiple registers.  */
+
+  gdb_assert (len > 4 && len % 4 == 0);
+
+  while (len > 0)
+    {
+      gdb_assert (regnum != -1);
+      gdb_assert (register_size (get_frame_arch (frame), regnum) == 4);
+
+      put_frame_register (frame, regnum, from);
+      regnum = i386_next_regnum (regnum);
+      len -= 4;
+      from += 4;
+    }
+}
+
+/* Supply register REGNUM from the buffer specified by GREGS and LEN
+   in the general-purpose register set REGSET to register cache
+   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
+
+void
+i386_supply_gregset (const struct regset *regset, struct regcache *regcache,
+		     int regnum, const void *gregs, size_t len)
+{
+  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
+  const gdb_byte *regs = gregs;
+  int i;
+
+  gdb_assert (len == tdep->sizeof_gregset);
+
+  for (i = 0; i < tdep->gregset_num_regs; i++)
+    {
+      if ((regnum == i || regnum == -1)
+	  && tdep->gregset_reg_offset[i] != -1)
+	regcache_raw_supply (regcache, i, regs + tdep->gregset_reg_offset[i]);
+    }
+}
+
+/* Collect register REGNUM from the register cache REGCACHE and store
+   it in the buffer specified by GREGS and LEN as described by the
+   general-purpose register set REGSET.  If REGNUM is -1, do this for
+   all registers in REGSET.  */
+
+void
+i386_collect_gregset (const struct regset *regset,
+		      const struct regcache *regcache,
+		      int regnum, void *gregs, size_t len)
+{
+  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
+  gdb_byte *regs = gregs;
+  int i;
+
+  gdb_assert (len == tdep->sizeof_gregset);
+
+  for (i = 0; i < tdep->gregset_num_regs; i++)
+    {
+      if ((regnum == i || regnum == -1)
+	  && tdep->gregset_reg_offset[i] != -1)
+	regcache_raw_collect (regcache, i, regs + tdep->gregset_reg_offset[i]);
+    }
+}
+
+/* Supply register REGNUM from the buffer specified by FPREGS and LEN
+   in the floating-point register set REGSET to register cache
+   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
+
+static void
+i386_supply_fpregset (const struct regset *regset, struct regcache *regcache,
+		      int regnum, const void *fpregs, size_t len)
+{
+  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
+
+  if (len == I387_SIZEOF_FXSAVE)
+    {
+      //i387_supply_fxsave (regcache, regnum, fpregs);
+      return;
+    }
+
+  gdb_assert (len == tdep->sizeof_fpregset);
+  //i387_supply_fsave (regcache, regnum, fpregs);
+}
+
+/* Collect register REGNUM from the register cache REGCACHE and store
+   it in the buffer specified by FPREGS and LEN as described by the
+   floating-point register set REGSET.  If REGNUM is -1, do this for
+   all registers in REGSET.  */
+
+static void
+i386_collect_fpregset (const struct regset *regset,
+		       const struct regcache *regcache,
+		       int regnum, void *fpregs, size_t len)
+{
+  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
+
+  if (len == I387_SIZEOF_FXSAVE)
+    {
+      //i387_collect_fxsave (regcache, regnum, fpregs);
+      return;
+    }
+
+  gdb_assert (len == tdep->sizeof_fpregset);
+  //i387_collect_fsave (regcache, regnum, fpregs);
+}
+
+/* Similar to i386_supply_fpregset, but use XSAVE extended state.  */
+
+static void
+i386_supply_xstateregset (const struct regset *regset,
+			  struct regcache *regcache, int regnum,
+			  const void *xstateregs, size_t len)
+{
+  //i387_supply_xsave (regcache, regnum, xstateregs);
+}
+
+/* Similar to i386_collect_fpregset , but use XSAVE extended state.  */
+
+static void
+i386_collect_xstateregset (const struct regset *regset,
+			   const struct regcache *regcache,
+			   int regnum, void *xstateregs, size_t len)
+{
+  //i387_collect_xsave (regcache, regnum, xstateregs, 1);
+}
+
+/* Return the appropriate register set for the core section identified
+   by SECT_NAME and SECT_SIZE.  */
+
+const struct regset *
+i386_regset_from_core_section (struct gdbarch *gdbarch,
+			       const char *sect_name, size_t sect_size)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  if (strcmp (sect_name, ".reg") == 0 && sect_size == tdep->sizeof_gregset)
+    {
+      if (tdep->gregset == NULL)
+	tdep->gregset = regset_alloc (gdbarch, i386_supply_gregset,
+				      i386_collect_gregset);
+      return tdep->gregset;
+    }
+
+  if ((strcmp (sect_name, ".reg2") == 0 && sect_size == tdep->sizeof_fpregset)
+      || (strcmp (sect_name, ".reg-xfp") == 0
+	  && sect_size == I387_SIZEOF_FXSAVE))
+    {
+      if (tdep->fpregset == NULL)
+	tdep->fpregset = regset_alloc (gdbarch, i386_supply_fpregset,
+				       i386_collect_fpregset);
+      return tdep->fpregset;
+    }
+
+  if (strcmp (sect_name, ".reg-xstate") == 0)
+    {
+      if (tdep->xstateregset == NULL)
+	tdep->xstateregset = regset_alloc (gdbarch,
+					   i386_supply_xstateregset,
+					   i386_collect_xstateregset);
+
+      return tdep->xstateregset;
+    }
+
+  return NULL;
+}
+
+
+/* Stuff for WIN32 PE style DLL's but is pretty generic really.  */
+
+CORE_ADDR
+i386_pe_skip_trampoline_code (struct frame_info *frame,
+			      CORE_ADDR pc, char *name)
+{
+  struct gdbarch *gdbarch = get_frame_arch (frame);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+
+  /* jmp *(dest) */
+  if (pc && read_memory_unsigned_integer (pc, 2, byte_order) == 0x25ff)
+    {
+      unsigned long indirect =
+	read_memory_unsigned_integer (pc + 2, 4, byte_order);
+      struct minimal_symbol *indsym =
+	indirect ? lookup_minimal_symbol_by_pc (indirect) : 0;
+      char *symname = indsym ? SYMBOL_LINKAGE_NAME (indsym) : 0;
+
+      if (symname)
+	{
+	  if (strncmp (symname, "__imp_", 6) == 0
+	      || strncmp (symname, "_imp_", 5) == 0)
+	    return name ? 1 :
+		   read_memory_unsigned_integer (indirect, 4, byte_order);
+	}
+    }
+  return 0;			/* Not a trampoline.  */
+}
+
+
+/* Return whether the THIS_FRAME corresponds to a sigtramp
+   routine.  */
+
+int
+i386_sigtramp_p (struct frame_info *this_frame)
+{
+  CORE_ADDR pc = get_frame_pc (this_frame);
+  char *name;
+
+  find_pc_partial_function (pc, &name, NULL, NULL);
+  return (name && strcmp ("_sigtramp", name) == 0);
+}
+
+
+/* We have two flavours of disassembly.  The machinery on this page
+   deals with switching between those.  */
+static int
+avm2_print_insn(bfd_vma pc, struct disassemble_info *info)
+{
+  return 0;
+}
+
+#if 0
+static int
+i386_print_insn (bfd_vma pc, struct disassemble_info *info)
+{
+  gdb_assert (disassembly_flavor == att_flavor
+	      || disassembly_flavor == intel_flavor);
+
+  /* FIXME: kettenis/20020915: Until disassembler_options is properly
+     constified, cast to prevent a compiler warning.  */
+  info->disassembler_options = (char *) disassembly_flavor;
+
+  return print_insn_i386 (pc, info);
+}
+#endif
+
+/* There are a few i386 architecture variants that differ only
+   slightly from the generic i386 target.  For now, we don't give them
+   their own source file, but include them here.  As a consequence,
+   they'll always be included.  */
+
+/* System V Release 4 (SVR4).  */
+
+/* Return whether THIS_FRAME corresponds to a SVR4 sigtramp
+   routine.  */
+
+static int
+i386_svr4_sigtramp_p (struct frame_info *this_frame)
+{
+  CORE_ADDR pc = get_frame_pc (this_frame);
+  char *name;
+
+  /* UnixWare uses _sigacthandler.  The origin of the other symbols is
+     currently unknown.  */
+  find_pc_partial_function (pc, &name, NULL, NULL);
+  return (name && (strcmp ("_sigreturn", name) == 0
+		   || strcmp ("_sigacthandler", name) == 0
+		   || strcmp ("sigvechandler", name) == 0));
+}
+
+/* Assuming THIS_FRAME is for a SVR4 sigtramp routine, return the
+   address of the associated sigcontext (ucontext) structure.  */
+
+static CORE_ADDR
+i386_svr4_sigcontext_addr (struct frame_info *this_frame)
+{
+  struct gdbarch *gdbarch = get_frame_arch (this_frame);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  gdb_byte buf[4];
+  CORE_ADDR sp;
+
+  get_frame_register (this_frame, I386_ESP_REGNUM, buf);
+  sp = extract_unsigned_integer (buf, 4, byte_order);
+
+  return read_memory_unsigned_integer (sp + 8, 4, byte_order);
+}
+
+
+/* Generic ELF.  */
+
+void
+i386_elf_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  /* We typically use stabs-in-ELF with the SVR4 register numbering.  */
+  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);
+}
+
+
+/* i386 register groups.  In addition to the normal groups, add "mmx"
+   and "sse".  */
+
+static struct reggroup *i386_sse_reggroup;
+static struct reggroup *i386_mmx_reggroup;
+
+static void
+i386_init_reggroups (void)
+{
+  i386_sse_reggroup = reggroup_new ("sse", USER_REGGROUP);
+  i386_mmx_reggroup = reggroup_new ("mmx", USER_REGGROUP);
+}
+
+static void
+i386_add_reggroups (struct gdbarch *gdbarch)
+{
+  reggroup_add (gdbarch, i386_sse_reggroup);
+  reggroup_add (gdbarch, i386_mmx_reggroup);
+  reggroup_add (gdbarch, general_reggroup);
+  reggroup_add (gdbarch, float_reggroup);
+  reggroup_add (gdbarch, all_reggroup);
+  reggroup_add (gdbarch, save_reggroup);
+  reggroup_add (gdbarch, restore_reggroup);
+  reggroup_add (gdbarch, vector_reggroup);
+  reggroup_add (gdbarch, system_reggroup);
+}
+
+int
+i386_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
+			  struct reggroup *group)
+{
+  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int fp_regnum_p, mmx_regnum_p, xmm_regnum_p, mxcsr_regnum_p,
+      ymm_regnum_p, ymmh_regnum_p;
+
+  /* Don't include pseudo registers, except for MMX, in any register
+     groups.  */
+  if (i386_byte_regnum_p (gdbarch, regnum))
+    return 0;
+
+  if (i386_word_regnum_p (gdbarch, regnum))
+    return 0;
+
+  if (i386_dword_regnum_p (gdbarch, regnum))
+    return 0;
+
+  mmx_regnum_p = i386_mmx_regnum_p (gdbarch, regnum);
+  if (group == i386_mmx_reggroup)
+    return mmx_regnum_p;
+
+  xmm_regnum_p = i386_xmm_regnum_p (gdbarch, regnum);
+  mxcsr_regnum_p = i386_mxcsr_regnum_p (gdbarch, regnum);
+  if (group == i386_sse_reggroup)
+    return xmm_regnum_p || mxcsr_regnum_p;
+
+  ymm_regnum_p = i386_ymm_regnum_p (gdbarch, regnum);
+  if (group == vector_reggroup)
+    return (mmx_regnum_p
+	    || ymm_regnum_p
+	    || mxcsr_regnum_p
+	    || (xmm_regnum_p
+		&& ((tdep->xcr0 & I386_XSTATE_AVX_MASK)
+		    == I386_XSTATE_SSE_MASK)));
+
+  fp_regnum_p = (i386_fp_regnum_p (gdbarch, regnum)
+		 || i386_fpc_regnum_p (gdbarch, regnum));
+  if (group == float_reggroup)
+    return fp_regnum_p;
+
+  /* For "info reg all", don't include upper YMM registers nor XMM
+     registers when AVX is supported.  */
+  ymmh_regnum_p = i386_ymmh_regnum_p (gdbarch, regnum);
+  if (group == all_reggroup
+      && ((xmm_regnum_p
+	   && (tdep->xcr0 & I386_XSTATE_AVX))
+	  || ymmh_regnum_p))
+    return 0;
+
+  if (group == general_reggroup)
+    return (!fp_regnum_p
+	    && !mmx_regnum_p
+	    && !mxcsr_regnum_p
+	    && !xmm_regnum_p
+	    && !ymm_regnum_p
+	    && !ymmh_regnum_p);
+
+  return default_register_reggroup_p (gdbarch, regnum, group);
+}
+
+
+/* Get the ARGIth function argument for the current function.  */
+
+static CORE_ADDR
+i386_fetch_pointer_argument (struct frame_info *frame, int argi, 
+			     struct type *type)
+{
+  struct gdbarch *gdbarch = get_frame_arch (frame);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  CORE_ADDR sp = get_frame_register_unsigned  (frame, I386_ESP_REGNUM);
+  return read_memory_unsigned_integer (sp + (4 * (argi + 1)), 4, byte_order);
+}
+
+static void
+i386_skip_permanent_breakpoint (struct regcache *regcache)
+{
+  CORE_ADDR current_pc = regcache_read_pc (regcache);
+
+ /* On i386, breakpoint is exactly 1 byte long, so we just
+    adjust the PC in the regcache.  */
+  current_pc += 1;
+  regcache_write_pc (regcache, current_pc);
+}
+
+
+#define PREFIX_REPZ	0x01
+#define PREFIX_REPNZ	0x02
+#define PREFIX_LOCK	0x04
+#define PREFIX_DATA	0x08
+#define PREFIX_ADDR	0x10
+
+/* operand size */
+enum
+{
+  OT_BYTE = 0,
+  OT_WORD,
+  OT_LONG,
+  OT_QUAD,
+  OT_DQUAD,
+};
+
+/* i386 arith/logic operations */
+enum
+{
+  OP_ADDL,
+  OP_ORL,
+  OP_ADCL,
+  OP_SBBL,
+  OP_ANDL,
+  OP_SUBL,
+  OP_XORL,
+  OP_CMPL,
+};
+
+struct i386_record_s
+{
+  struct gdbarch *gdbarch;
+  struct regcache *regcache;
+  CORE_ADDR orig_addr;
+  CORE_ADDR addr;
+  int aflag;
+  int dflag;
+  int override;
+  uint8_t modrm;
+  uint8_t mod, reg, rm;
+  int ot;
+  uint8_t rex_x;
+  uint8_t rex_b;
+  int rip_offset;
+  int popl_esp_hack;
+  const int *regmap;
+};
+
+/* Parse "modrm" part in current memory address that irp->addr point to
+   Return -1 if something wrong.  */
+
+static int
+i386_record_modrm (struct i386_record_s *irp)
+{
+  struct gdbarch *gdbarch = irp->gdbarch;
+
+  if (target_read_memory (irp->addr, &irp->modrm, 1))
+    {
+      if (record_debug)
+	printf_unfiltered (_("Process record: error reading memory at "
+			     "addr %s len = 1.\n"),
+			   paddress (gdbarch, irp->addr));
+      return -1;
+    }
+  irp->addr++;
+  irp->mod = (irp->modrm >> 6) & 3;
+  irp->reg = (irp->modrm >> 3) & 7;
+  irp->rm = irp->modrm & 7;
+
+  return 0;
+}
+
+/* Get the memory address that current instruction  write to and set it to
+   the argument "addr".
+   Return -1 if something wrong.  */
+
+static int
+i386_record_lea_modrm_addr (struct i386_record_s *irp, uint64_t *addr)
+{
+  struct gdbarch *gdbarch = irp->gdbarch;
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  gdb_byte buf[4];
+  ULONGEST offset64;
+
+  *addr = 0;
+  if (irp->aflag)
+    {
+      /* 32 bits */
+      int havesib = 0;
+      uint8_t scale = 0;
+      uint8_t byte;
+      uint8_t index = 0;
+      uint8_t base = irp->rm;
+
+      if (base == 4)
+	{
+	  havesib = 1;
+	  if (target_read_memory (irp->addr, &byte, 1))
+	    {
+	      if (record_debug)
+		printf_unfiltered (_("Process record: error reading memory "
+				     "at addr %s len = 1.\n"),
+				   paddress (gdbarch, irp->addr));
+	      return -1;
+	    }
+	  irp->addr++;
+	  scale = (byte >> 6) & 3;
+	  index = ((byte >> 3) & 7) | irp->rex_x;
+	  base = (byte & 7);
+	}
+      base |= irp->rex_b;
+
+      switch (irp->mod)
+	{
+	case 0:
+	  if ((base & 7) == 5)
+	    {
+	      base = 0xff;
+	      if (target_read_memory (irp->addr, buf, 4))
+		{
+		  if (record_debug)
+		    printf_unfiltered (_("Process record: error reading "
+				         "memory at addr %s len = 4.\n"),
+				       paddress (gdbarch, irp->addr));
+		  return -1;
+		}
+	      irp->addr += 4;
+	      *addr = extract_signed_integer (buf, 4, byte_order);
+	      if (irp->regmap[X86_RECORD_R8_REGNUM] && !havesib)
+		*addr += irp->addr + irp->rip_offset;
+	    }
+	  break;
+	case 1:
+	  if (target_read_memory (irp->addr, buf, 1))
+	    {
+	      if (record_debug)
+		printf_unfiltered (_("Process record: error reading memory "
+				     "at addr %s len = 1.\n"),
+				   paddress (gdbarch, irp->addr));
+	      return -1;
+	    }
+	  irp->addr++;
+	  *addr = (int8_t) buf[0];
+	  break;
+	case 2:
+	  if (target_read_memory (irp->addr, buf, 4))
+	    {
+	      if (record_debug)
+		printf_unfiltered (_("Process record: error reading memory "
+				     "at addr %s len = 4.\n"),
+				   paddress (gdbarch, irp->addr));
+	      return -1;
+	    }
+	  *addr = extract_signed_integer (buf, 4, byte_order);
+	  irp->addr += 4;
+	  break;
+	}
+
+      offset64 = 0;
+      if (base != 0xff)
+        {
+	  if (base == 4 && irp->popl_esp_hack)
+	    *addr += irp->popl_esp_hack;
+	  regcache_raw_read_unsigned (irp->regcache, irp->regmap[base],
+                                      &offset64);
+	}
+      if (irp->aflag == 2)
+        {
+	  *addr += offset64;
+        }
+      else
+        *addr = (uint32_t) (offset64 + *addr);
+
+      if (havesib && (index != 4 || scale != 0))
+	{
+	  regcache_raw_read_unsigned (irp->regcache, irp->regmap[index],
+                                      &offset64);
+	  if (irp->aflag == 2)
+	    *addr += offset64 << scale;
+	  else
+	    *addr = (uint32_t) (*addr + (offset64 << scale));
+	}
+    }
+  else
+    {
+      /* 16 bits */
+      switch (irp->mod)
+	{
+	case 0:
+	  if (irp->rm == 6)
+	    {
+	      if (target_read_memory (irp->addr, buf, 2))
+		{
+		  if (record_debug)
+		    printf_unfiltered (_("Process record: error reading "
+					 "memory at addr %s len = 2.\n"),
+				       paddress (gdbarch, irp->addr));
+		  return -1;
+		}
+	      irp->addr += 2;
+	      *addr = extract_signed_integer (buf, 2, byte_order);
+	      irp->rm = 0;
+	      goto no_rm;
+	    }
+	  break;
+	case 1:
+	  if (target_read_memory (irp->addr, buf, 1))
+	    {
+	      if (record_debug)
+		printf_unfiltered (_("Process record: error reading memory "
+				     "at addr %s len = 1.\n"),
+				   paddress (gdbarch, irp->addr));
+	      return -1;
+	    }
+	  irp->addr++;
+	  *addr = (int8_t) buf[0];
+	  break;
+	case 2:
+	  if (target_read_memory (irp->addr, buf, 2))
+	    {
+	      if (record_debug)
+		printf_unfiltered (_("Process record: error reading memory "
+				     "at addr %s len = 2.\n"),
+				   paddress (gdbarch, irp->addr));
+	      return -1;
+	    }
+	  irp->addr += 2;
+	  *addr = extract_signed_integer (buf, 2, byte_order);
+	  break;
+	}
+
+      switch (irp->rm)
+	{
+	case 0:
+	  regcache_raw_read_unsigned (irp->regcache,
+				      irp->regmap[X86_RECORD_REBX_REGNUM],
+                                      &offset64);
+	  *addr = (uint32_t) (*addr + offset64);
+	  regcache_raw_read_unsigned (irp->regcache,
+				      irp->regmap[X86_RECORD_RESI_REGNUM],
+                                      &offset64);
+	  *addr = (uint32_t) (*addr + offset64);
+	  break;
+	case 1:
+	  regcache_raw_read_unsigned (irp->regcache,
+				      irp->regmap[X86_RECORD_REBX_REGNUM],
+                                      &offset64);
+	  *addr = (uint32_t) (*addr + offset64);
+	  regcache_raw_read_unsigned (irp->regcache,
+				      irp->regmap[X86_RECORD_REDI_REGNUM],
+                                      &offset64);
+	  *addr = (uint32_t) (*addr + offset64);
+	  break;
+	case 2:
+	  regcache_raw_read_unsigned (irp->regcache,
+				      irp->regmap[X86_RECORD_REBP_REGNUM],
+                                      &offset64);
+	  *addr = (uint32_t) (*addr + offset64);
+	  regcache_raw_read_unsigned (irp->regcache,
+				      irp->regmap[X86_RECORD_RESI_REGNUM],
+                                      &offset64);
+	  *addr = (uint32_t) (*addr + offset64);
+	  break;
+	case 3:
+	  regcache_raw_read_unsigned (irp->regcache,
+				      irp->regmap[X86_RECORD_REBP_REGNUM],
+                                      &offset64);
+	  *addr = (uint32_t) (*addr + offset64);
+	  regcache_raw_read_unsigned (irp->regcache,
+				      irp->regmap[X86_RECORD_REDI_REGNUM],
+                                      &offset64);
+	  *addr = (uint32_t) (*addr + offset64);
+	  break;
+	case 4:
+	  regcache_raw_read_unsigned (irp->regcache,
+				      irp->regmap[X86_RECORD_RESI_REGNUM],
+                                      &offset64);
+	  *addr = (uint32_t) (*addr + offset64);
+	  break;
+	case 5:
+	  regcache_raw_read_unsigned (irp->regcache,
+				      irp->regmap[X86_RECORD_REDI_REGNUM],
+                                      &offset64);
+	  *addr = (uint32_t) (*addr + offset64);
+	  break;
+	case 6:
+	  regcache_raw_read_unsigned (irp->regcache,
+				      irp->regmap[X86_RECORD_REBP_REGNUM],
+                                      &offset64);
+	  *addr = (uint32_t) (*addr + offset64);
+	  break;
+	case 7:
+	  regcache_raw_read_unsigned (irp->regcache,
+				      irp->regmap[X86_RECORD_REBX_REGNUM],
+                                      &offset64);
+	  *addr = (uint32_t) (*addr + offset64);
+	  break;
+	}
+      *addr &= 0xffff;
+    }
+
+ no_rm:
+  return 0;
+}
+
+/* Record the value of the memory that willbe changed in current instruction
+   to "record_arch_list".
+   Return -1 if something wrong.  */
+
+static int
+i386_record_lea_modrm (struct i386_record_s *irp)
+{
+  struct gdbarch *gdbarch = irp->gdbarch;
+  uint64_t addr;
+
+  if (irp->override >= 0)
+    {
+      if (record_memory_query)
+        {
+	  int q;
+
+          target_terminal_ours ();
+          q = yquery (_("\
+Process record ignores the memory change of instruction at address %s\n\
+because it can't get the value of the segment register.\n\
+Do you want to stop the program?"),
+                      paddress (gdbarch, irp->orig_addr));
+            target_terminal_inferior ();
+            if (q)
+              return -1;
+        }
+
+      return 0;
+    }
+
+  if (i386_record_lea_modrm_addr (irp, &addr))
+    return -1;
+
+  if (record_arch_list_add_mem (addr, 1 << irp->ot))
+    return -1;
+
+  return 0;
+}
+
+/* Record the push operation to "record_arch_list".
+   Return -1 if something wrong.  */
+
+static int
+i386_record_push (struct i386_record_s *irp, int size)
+{
+  ULONGEST addr;
+
+  if (record_arch_list_add_reg (irp->regcache,
+				irp->regmap[X86_RECORD_RESP_REGNUM]))
+    return -1;
+  regcache_raw_read_unsigned (irp->regcache,
+			      irp->regmap[X86_RECORD_RESP_REGNUM],
+			      &addr);
+  if (record_arch_list_add_mem ((CORE_ADDR) addr - size, size))
+    return -1;
+
+  return 0;
+}
+
+
+/* Defines contents to record.  */
+#define I386_SAVE_FPU_REGS              0xfffd
+#define I386_SAVE_FPU_ENV               0xfffe
+#define I386_SAVE_FPU_ENV_REG_STACK     0xffff
+
+/* Record the value of floating point registers which will be changed
+   by the current instruction to "record_arch_list".  Return -1 if
+   something is wrong.  */
+
+static int i386_record_floats (struct gdbarch *gdbarch,
+                               struct i386_record_s *ir,
+                               uint32_t iregnum)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  int i;
+
+  /* Oza: Because of floating point insn push/pop of fpu stack is going to
+     happen.  Currently we store st0-st7 registers, but we need not store all
+     registers all the time, in future we use ftag register and record only
+     those who are not marked as an empty.  */
+
+  if (I386_SAVE_FPU_REGS == iregnum)
+    {
+      for (i = I387_ST0_REGNUM (tdep); i <= I387_ST0_REGNUM (tdep) + 7; i++)
+        {
+          if (record_arch_list_add_reg (ir->regcache, i))
+            return -1;
+        }
+    }
+  else if (I386_SAVE_FPU_ENV == iregnum)
+    {
+      for (i = I387_FCTRL_REGNUM (tdep); i <= I387_FOP_REGNUM (tdep); i++)
+	      {
+	      if (record_arch_list_add_reg (ir->regcache, i))
+	        return -1;
+	      }
+    }
+  else if (I386_SAVE_FPU_ENV_REG_STACK == iregnum)
+    {
+      for (i = I387_ST0_REGNUM (tdep); i <= I387_FOP_REGNUM (tdep); i++)
+      {
+        if (record_arch_list_add_reg (ir->regcache, i))
+          return -1;
+      }
+    }
+  else if ((iregnum >= I387_ST0_REGNUM (tdep)) &&
+           (iregnum <= I387_FOP_REGNUM (tdep)))
+    {
+      if (record_arch_list_add_reg (ir->regcache,iregnum))
+        return -1;
+    }
+  else
+    {
+      /* Parameter error.  */
+      return -1;
+    }
+  if(I386_SAVE_FPU_ENV != iregnum)
+    {
+    for (i = I387_FCTRL_REGNUM (tdep); i <= I387_FOP_REGNUM (tdep); i++)
+      {
+      if (record_arch_list_add_reg (ir->regcache, i))
+        return -1;
+      }
+    }
+  return 0;
+}
+
+/* Parse the current instruction and record the values of the registers and
+   memory that will be changed in current instruction to "record_arch_list".
+   Return -1 if something wrong.  */
+
+#define I386_RECORD_ARCH_LIST_ADD_REG(regnum) \
+    record_arch_list_add_reg (ir.regcache, ir.regmap[(regnum)])
+
+int
+i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,
+		     CORE_ADDR input_addr)
+{
+  return 0;
+}
+
+static const int i386_record_regmap[] =
+{
+  I386_EAX_REGNUM, I386_ECX_REGNUM, I386_EDX_REGNUM, I386_EBX_REGNUM,
+  I386_ESP_REGNUM, I386_EBP_REGNUM, I386_ESI_REGNUM, I386_EDI_REGNUM,
+  0, 0, 0, 0, 0, 0, 0, 0,
+  I386_EIP_REGNUM, I386_EFLAGS_REGNUM, I386_CS_REGNUM, I386_SS_REGNUM,
+  I386_DS_REGNUM, I386_ES_REGNUM, I386_FS_REGNUM, I386_GS_REGNUM
+};
+
+/* Check that the given address appears suitable for a fast
+   tracepoint, which on x86 means that we need an instruction of at
+   least 5 bytes, so that we can overwrite it with a 4-byte-offset
+   jump and not have to worry about program jumps to an address in the
+   middle of the tracepoint jump.  Returns 1 if OK, and writes a size
+   of instruction to replace, and 0 if not, plus an explanatory
+   string.  */
+
+static int
+i386_fast_tracepoint_valid_at (struct gdbarch *gdbarch,
+			       CORE_ADDR addr, int *isize, char **msg)
+{
+  int len, jumplen;
+  static struct ui_file *gdb_null = NULL;
+
+  /* This is based on the target agent using a 4-byte relative jump.
+     Alternate future possibilities include 8-byte offset for x86-84,
+     or 3-byte jumps if the program has trampoline space close by.  */
+  jumplen = 5;
+
+  /* Dummy file descriptor for the disassembler.  */
+  if (!gdb_null)
+    gdb_null = ui_file_new ();
+
+  /* Check for fit.  */
+  len = gdb_print_insn (gdbarch, addr, gdb_null, NULL);
+  if (len < jumplen)
+    {
+      /* Return a bit of target-specific detail to add to the caller's
+	 generic failure message.  */
+      if (msg)
+	*msg = xstrprintf (_("; instruction is only %d bytes long, "
+			     "need at least %d bytes for the jump"),
+			   len, jumplen);
+      return 0;
+    }
+
+  if (isize)
+    *isize = len;
+  if (msg)
+    *msg = NULL;
+  return 1;
+}
+
+static int
+i386_validate_tdesc_p (struct gdbarch_tdep *tdep,
+		       struct tdesc_arch_data *tdesc_data)
+{
+  const struct target_desc *tdesc = tdep->tdesc;
+  const struct tdesc_feature *feature_core;
+  const struct tdesc_feature *feature_sse, *feature_avx;
+  int i, num_regs, valid_p;
+
+  if (! tdesc_has_registers (tdesc))
+    return 0;
+
+  /* Get core registers.  */
+  feature_core = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.core");
+  if (feature_core == NULL)
+    return 0;
+
+  /* Get SSE registers.  */
+  feature_sse = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.sse");
+
+  /* Try AVX registers.  */
+  feature_avx = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.avx");
+
+  valid_p = 1;
+
+  /* The XCR0 bits.  */
+  if (feature_avx)
+    {
+      /* AVX register description requires SSE register description.  */
+      if (!feature_sse)
+	return 0;
+
+      tdep->xcr0 = I386_XSTATE_AVX_MASK;
+
+      /* It may have been set by OSABI initialization function.  */
+      if (tdep->num_ymm_regs == 0)
+	{
+	  tdep->ymmh_register_names = i386_ymmh_names;
+	  tdep->num_ymm_regs = 8;
+	  tdep->ymm0h_regnum = I386_YMM0H_REGNUM;
+	}
+
+      for (i = 0; i < tdep->num_ymm_regs; i++)
+	valid_p &= tdesc_numbered_register (feature_avx, tdesc_data,
+					    tdep->ymm0h_regnum + i,
+					    tdep->ymmh_register_names[i]);
+    }
+  else if (feature_sse)
+    tdep->xcr0 = I386_XSTATE_SSE_MASK;
+  else
+    {
+      tdep->xcr0 = I386_XSTATE_X87_MASK;
+      tdep->num_xmm_regs = 0;
+    }
+
+  num_regs = tdep->num_core_regs;
+  for (i = 0; i < num_regs; i++)
+    valid_p &= tdesc_numbered_register (feature_core, tdesc_data, i,
+					tdep->register_names[i]);
+
+  if (feature_sse)
+    {
+      /* Need to include %mxcsr, so add one.  */
+      num_regs += tdep->num_xmm_regs + 1;
+      for (; i < num_regs; i++)
+	valid_p &= tdesc_numbered_register (feature_sse, tdesc_data, i,
+					    tdep->register_names[i]);
+    }
+
+  return valid_p;
+}
+
+static CORE_ADDR
+avm2_unwind_sp (struct gdbarch *gdbarch, struct frame_info *this_frame)
+{
+  CORE_ADDR sp = frame_unwind_register_unsigned (this_frame, 1);
+  return sp;
+}
+
+
+static struct gdbarch *
+i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
+{
+  struct gdbarch_tdep *tdep;
+  struct gdbarch *gdbarch;
+  struct tdesc_arch_data *tdesc_data;
+  const struct target_desc *tdesc;
+  int mm0_regnum;
+  int ymm0_regnum;
+
+  /* If there is already a candidate, use it.  */
+  arches = gdbarch_list_lookup_by_info (arches, &info);
+  if (arches != NULL)
+    return arches->gdbarch;
+
+  /* Allocate space for the new architecture.  */
+  tdep = XCALLOC (1, struct gdbarch_tdep);
+  gdbarch = gdbarch_alloc (&info, tdep);
+
+  /* General-purpose registers.  */
+  tdep->gregset = NULL;
+  tdep->gregset_reg_offset = NULL;
+  tdep->gregset_num_regs = I386_NUM_GREGS;
+  tdep->sizeof_gregset = 0;
+
+  /* Floating-point registers.  */
+  tdep->fpregset = NULL;
+  tdep->sizeof_fpregset = I387_SIZEOF_FSAVE;
+
+  tdep->xstateregset = NULL;
+
+  /* The default settings include the FPU registers, the MMX registers
+     and the SSE registers.  This can be overridden for a specific ABI
+     by adjusting the members `st0_regnum', `mm0_regnum' and
+     `num_xmm_regs' of `struct gdbarch_tdep', otherwise the registers
+     will show up in the output of "info all-registers".  */
+
+  tdep->st0_regnum = I386_ST0_REGNUM;
+
+  /* I386_NUM_XREGS includes %mxcsr, so substract one.  */
+  tdep->num_xmm_regs = I386_NUM_XREGS - 1;
+
+  tdep->jb_pc_offset = -1;
+  tdep->struct_return = pcc_struct_return;
+  tdep->sigtramp_start = 0;
+  tdep->sigtramp_end = 0;
+  tdep->sigtramp_p = i386_sigtramp_p;
+  tdep->sigcontext_addr = NULL;
+  tdep->sc_reg_offset = NULL;
+  tdep->sc_pc_offset = -1;
+  tdep->sc_sp_offset = -1;
+
+  tdep->xsave_xcr0_offset = -1;
+
+  tdep->record_regmap = i386_record_regmap;
+
+  /* The format used for `long double' on almost all i386 targets is
+     the i387 extended floating-point format.  In fact, of all targets
+     in the GCC 2.95 tree, only OSF/1 does it different, and insists
+     on having a `long double' that's not `long' at all.  */
+  set_gdbarch_long_double_format (gdbarch, floatformats_i387_ext);
+
+  /* Although the i387 extended floating-point has only 80 significant
+     bits, a `long double' actually takes up 96, probably to enforce
+     alignment.  */
+  set_gdbarch_long_double_bit (gdbarch, 96);
+
+  /* Register numbers of various important registers.  */
+  set_gdbarch_sp_regnum (gdbarch, I386_ESP_REGNUM); /* %esp */
+  set_gdbarch_pc_regnum (gdbarch, I386_EIP_REGNUM); /* %eip */
+  set_gdbarch_ps_regnum (gdbarch, I386_EFLAGS_REGNUM); /* %eflags */
+  set_gdbarch_fp0_regnum (gdbarch, I386_ST0_REGNUM); /* %st(0) */
+
+  /* NOTE: kettenis/20040418: GCC does have two possible register
+     numbering schemes on the i386: dbx and SVR4.  These schemes
+     differ in how they number %ebp, %esp, %eflags, and the
+     floating-point registers, and are implemented by the arrays
+     dbx_register_map[] and svr4_dbx_register_map in
+     gcc/config/i386.c.  GCC also defines a third numbering scheme in
+     gcc/config/i386.c, which it designates as the "default" register
+     map used in 64bit mode.  This last register numbering scheme is
+     implemented in dbx64_register_map, and is used for AMD64; see
+     amd64-tdep.c.
+
+     Currently, each GCC i386 target always uses the same register
+     numbering scheme across all its supported debugging formats
+     i.e. SDB (COFF), stabs and DWARF 2.  This is because
+     gcc/sdbout.c, gcc/dbxout.c and gcc/dwarf2out.c all use the
+     DBX_REGISTER_NUMBER macro which is defined by each target's
+     respective config header in a manner independent of the requested
+     output debugging format.
+
+     This does not match the arrangement below, which presumes that
+     the SDB and stabs numbering schemes differ from the DWARF and
+     DWARF 2 ones.  The reason for this arrangement is that it is
+     likely to get the numbering scheme for the target's
+     default/native debug format right.  For targets where GCC is the
+     native compiler (FreeBSD, NetBSD, OpenBSD, GNU/Linux) or for
+     targets where the native toolchain uses a different numbering
+     scheme for a particular debug format (stabs-in-ELF on Solaris)
+     the defaults below will have to be overridden, like
+     i386_elf_init_abi() does.  */
+
+  /* Use the dbx register numbering scheme for stabs and COFF.  */
+  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);
+  set_gdbarch_sdb_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);
+
+  /* Use the SVR4 register numbering scheme for DWARF 2.  */
+  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);
+
+  /* We don't set gdbarch_stab_reg_to_regnum, since ECOFF doesn't seem to
+     be in use on any of the supported i386 targets.  */
+
+  set_gdbarch_print_float_info (gdbarch, i387_print_float_info);
+
+  set_gdbarch_get_longjmp_target (gdbarch, i386_get_longjmp_target);
+
+  /* Call dummy code.  */
+  set_gdbarch_push_dummy_call (gdbarch, i386_push_dummy_call);
+
+  set_gdbarch_convert_register_p (gdbarch, i386_convert_register_p);
+  set_gdbarch_register_to_value (gdbarch,  i386_register_to_value);
+  set_gdbarch_value_to_register (gdbarch, i386_value_to_register);
+
+  set_gdbarch_return_value (gdbarch, i386_return_value);
+
+  set_gdbarch_skip_prologue (gdbarch, i386_skip_prologue);
+
+  /* Stack grows downward.  */
+  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
+
+  set_gdbarch_breakpoint_from_pc (gdbarch, i386_breakpoint_from_pc);
+  set_gdbarch_decr_pc_after_break (gdbarch, 0);
+  set_gdbarch_max_insn_length (gdbarch, I386_MAX_INSN_LEN);
+
+  set_gdbarch_frame_args_skip (gdbarch, 8);
+
+  set_gdbarch_print_insn (gdbarch, avm2_print_insn);
+
+  set_gdbarch_dummy_id (gdbarch, i386_dummy_id);
+
+  set_gdbarch_unwind_pc (gdbarch, i386_unwind_pc);
+  set_gdbarch_unwind_sp (gdbarch, avm2_unwind_sp);
+
+  /* Add the i386 register groups.  */
+  i386_add_reggroups (gdbarch);
+  tdep->register_reggroup_p = i386_register_reggroup_p;
+
+  /* Helper for function argument information.  */
+  set_gdbarch_fetch_pointer_argument (gdbarch, i386_fetch_pointer_argument);
+
+  /* Hook the function epilogue frame unwinder.  This unwinder is
+     appended to the list first, so that it supercedes the Dwarf
+     unwinder in function epilogues (where the Dwarf unwinder
+     currently fails).  */
+  frame_unwind_append_unwinder (gdbarch, &i386_epilogue_frame_unwind);
+
+  /* Hook in the DWARF CFI frame unwinder.  This unwinder is appended
+     to the list before the prologue-based unwinders, so that Dwarf
+     CFI info will be used if it is available.  */
+  dwarf2_append_unwinders (gdbarch);
+
+  frame_base_set_default (gdbarch, &i386_frame_base);
+
+  /* Pseudo registers may be changed by amd64_init_abi.  */
+  set_gdbarch_pseudo_register_read (gdbarch, i386_pseudo_register_read);
+  set_gdbarch_pseudo_register_write (gdbarch, i386_pseudo_register_write);
+
+  set_tdesc_pseudo_register_type (gdbarch, i386_pseudo_register_type);
+  set_tdesc_pseudo_register_name (gdbarch, i386_pseudo_register_name);
+
+  /* Override the normal target description method to make the AVX
+     upper halves anonymous.  */
+  set_gdbarch_register_name (gdbarch, i386_register_name);
+
+  /* Even though the default ABI only includes general-purpose registers,
+     floating-point registers and the SSE registers, we have to leave a
+     gap for the upper AVX registers.  */
+  set_gdbarch_num_regs (gdbarch, I386_AVX_NUM_REGS);
+
+  /* Get the x86 target description from INFO.  */
+  tdesc = info.target_desc;
+  if (! tdesc_has_registers (tdesc))
+    tdesc = tdesc_i386;
+  tdep->tdesc = tdesc;
+
+  tdep->num_core_regs = I386_NUM_GREGS + I387_NUM_REGS;
+  tdep->register_names = i386_register_names;
+
+  /* No upper YMM registers.  */
+  tdep->ymmh_register_names = NULL;
+  tdep->ymm0h_regnum = -1;
+
+  tdep->num_byte_regs = 8;
+  tdep->num_word_regs = 8;
+  tdep->num_dword_regs = 0;
+  tdep->num_mmx_regs = 8;
+  tdep->num_ymm_regs = 0;
+
+  tdesc_data = tdesc_data_alloc ();
+
+  set_gdbarch_relocate_instruction (gdbarch, i386_relocate_instruction);
+
+  /* Hook in ABI-specific overrides, if they have been registered.  */
+  info.tdep_info = (void *) tdesc_data;
+  gdbarch_init_osabi (info, gdbarch);
+
+  if (!i386_validate_tdesc_p (tdep, tdesc_data))
+    {
+      tdesc_data_cleanup (tdesc_data);
+      xfree (tdep);
+      gdbarch_free (gdbarch);
+      return NULL;
+    }
+
+  /* Wire in pseudo registers.  Number of pseudo registers may be
+     changed.  */
+  set_gdbarch_num_pseudo_regs (gdbarch, (tdep->num_byte_regs
+					 + tdep->num_word_regs
+					 + tdep->num_dword_regs
+					 + tdep->num_mmx_regs
+					 + tdep->num_ymm_regs));
+
+  /* Target description may be changed.  */
+  tdesc = tdep->tdesc;
+
+  tdesc_use_registers (gdbarch, tdesc, tdesc_data);
+
+  /* Override gdbarch_register_reggroup_p set in tdesc_use_registers.  */
+  set_gdbarch_register_reggroup_p (gdbarch, tdep->register_reggroup_p);
+
+  /* Make %al the first pseudo-register.  */
+  tdep->al_regnum = gdbarch_num_regs (gdbarch);
+  tdep->ax_regnum = tdep->al_regnum + tdep->num_byte_regs;
+
+  ymm0_regnum = tdep->ax_regnum + tdep->num_word_regs;
+  if (tdep->num_dword_regs)
+    {
+      /* Support dword pseudo-register if it hasn't been disabled.  */
+      tdep->eax_regnum = ymm0_regnum;
+      ymm0_regnum += tdep->num_dword_regs;
+    }
+  else
+    tdep->eax_regnum = -1;
+
+  mm0_regnum = ymm0_regnum;
+  if (tdep->num_ymm_regs)
+    {
+      /* Support YMM pseudo-register if it is available.  */
+      tdep->ymm0_regnum = ymm0_regnum;
+      mm0_regnum += tdep->num_ymm_regs;
+    }
+  else
+    tdep->ymm0_regnum = -1;
+
+  if (tdep->num_mmx_regs != 0)
+    {
+      /* Support MMX pseudo-register if MMX hasn't been disabled.  */
+      tdep->mm0_regnum = mm0_regnum;
+    }
+  else
+    tdep->mm0_regnum = -1;
+
+  /* Hook in the legacy prologue-based unwinders last (fallback).  */
+  frame_unwind_append_unwinder (gdbarch, &i386_sigtramp_frame_unwind);
+  frame_unwind_append_unwinder (gdbarch, &i386_frame_unwind);
+
+  /* If we have a register mapping, enable the generic core file
+     support, unless it has already been enabled.  */
+  if (tdep->gregset_reg_offset
+      && !gdbarch_regset_from_core_section_p (gdbarch))
+    set_gdbarch_regset_from_core_section (gdbarch,
+					  i386_regset_from_core_section);
+
+  set_gdbarch_skip_permanent_breakpoint (gdbarch,
+					 i386_skip_permanent_breakpoint);
+
+  set_gdbarch_fast_tracepoint_valid_at (gdbarch,
+					i386_fast_tracepoint_valid_at);
+
+  return gdbarch;
+}
+
+static enum gdb_osabi
+i386_coff_osabi_sniffer (bfd *abfd)
+{
+  return GDB_OSABI_FREEBSD_ELF;
+}
+
+
+/* Print out the i387 floating point state.  Note that we ignore FRAME
+   in the code below.  That's OK since floating-point registers are
+   never saved on the stack.  */
+
+void
+i387_print_float_info (struct gdbarch *gdbarch, struct ui_file *file,
+		       struct frame_info *frame, const char *args)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (frame));
+  ULONGEST fctrl;
+  ULONGEST fstat;
+  ULONGEST ftag;
+  ULONGEST fiseg;
+  ULONGEST fioff;
+  ULONGEST foseg;
+  ULONGEST fooff;
+  ULONGEST fop;
+  int fpreg;
+  int top;
+
+  gdb_assert (gdbarch == get_frame_arch (frame));
+
+  fctrl = get_frame_register_unsigned (frame, I387_FCTRL_REGNUM (tdep));
+  fstat = get_frame_register_unsigned (frame, I387_FSTAT_REGNUM (tdep));
+  ftag = get_frame_register_unsigned (frame, I387_FTAG_REGNUM (tdep));
+  fiseg = get_frame_register_unsigned (frame, I387_FISEG_REGNUM (tdep));
+  fioff = get_frame_register_unsigned (frame, I387_FIOFF_REGNUM (tdep));
+  foseg = get_frame_register_unsigned (frame, I387_FOSEG_REGNUM (tdep));
+  fooff = get_frame_register_unsigned (frame, I387_FOOFF_REGNUM (tdep));
+  fop = get_frame_register_unsigned (frame, I387_FOP_REGNUM (tdep));
+
+  top = ((fstat >> 11) & 7);
+
+  for (fpreg = 7; fpreg >= 0; fpreg--)
+    {
+      gdb_byte raw[I386_MAX_REGISTER_SIZE];
+      int tag = (ftag >> (fpreg * 2)) & 3;
+      int i;
+
+      fprintf_filtered (file, "%sR%d: ", fpreg == top ? "=>" : "  ", fpreg);
+
+      switch (tag)
+	{
+	case 0:
+	  fputs_filtered ("Valid   ", file);
+	  break;
+	case 1:
+	  fputs_filtered ("Zero    ", file);
+	  break;
+	case 2:
+	  fputs_filtered ("Special ", file);
+	  break;
+	case 3:
+	  fputs_filtered ("Empty   ", file);
+	  break;
+	}
+
+      get_frame_register (frame,
+			  (fpreg + 8 - top) % 8 + I387_ST0_REGNUM (tdep),
+			  raw);
+
+      fputs_filtered ("0x", file);
+      for (i = 9; i >= 0; i--)
+	fprintf_filtered (file, "%02x", raw[i]);
+
+      /*
+      if (tag != 3)
+	print_i387_ext (gdbarch, raw, file);
+       */
+
+      fputs_filtered ("\n", file);
+    }
+
+  fputs_filtered ("\n", file);
+
+  //print_i387_status_word (fstat, file);
+  //print_i387_control_word (fctrl, file);
+  fprintf_filtered (file, "Tag Word:            %s\n",
+		    hex_string_custom (ftag, 4));
+  fprintf_filtered (file, "Instruction Pointer: %s:",
+		    hex_string_custom (fiseg, 2));
+  fprintf_filtered (file, "%s\n", hex_string_custom (fioff, 8));
+  fprintf_filtered (file, "Operand Pointer:     %s:",
+		    hex_string_custom (foseg, 2));
+  fprintf_filtered (file, "%s\n", hex_string_custom (fooff, 8));
+  fprintf_filtered (file, "Opcode:              %s\n",
+		    hex_string_custom (fop ? (fop | 0xd800) : 0, 4));
+}
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+void _initialize_avm2_tdep (void);
+
+void
+_initialize_avm2_tdep (void)
+{
+  register_gdbarch_init (bfd_arch_avm2, i386_gdbarch_init);
+
+  /* Add the variable that controls the disassembly flavor.  */
+  add_setshow_enum_cmd ("disassembly-flavor", no_class, valid_flavors,
+			&disassembly_flavor, _("\
+Set the disassembly flavor."), _("\
+Show the disassembly flavor."), _("\
+The valid values are \"att\" and \"intel\", and the default value is \"att\"."),
+			NULL,
+			NULL, /* FIXME: i18n: */
+			&setlist, &showlist);
+
+  /* Add the variable that controls the convention for returning
+     structs.  */
+  add_setshow_enum_cmd ("struct-convention", no_class, valid_conventions,
+			&struct_convention, _("\
+Set the convention for returning small structs."), _("\
+Show the convention for returning small structs."), _("\
+Valid values are \"default\", \"pcc\" and \"reg\", and the default value\n\
+is \"default\"."),
+			NULL,
+			NULL, /* FIXME: i18n: */
+			&setlist, &showlist);
+
+  gdbarch_register_osabi (bfd_arch_avm2, 0, GDB_OSABI_FREEBSD_ELF,
+  			  i386_elf_init_abi);
+
+  /* Initialize the i386-specific register groups.  */
+  i386_init_reggroups ();
+
+  /* Initialize the standard target descriptions.  */
+  initialize_tdesc_i386 ();
+  initialize_tdesc_i386_mmx ();
+  initialize_tdesc_i386_avx ();
+
+  /* Tell remote stub that we support XML target description.  */
+  register_remote_support_xml ("i386");
+}
diff -rupN gdb-7.3.orig/gdb/cli/cli-cmds.c gdb-7.3/gdb/cli/cli-cmds.c
--- gdb-7.3.orig/gdb/cli/cli-cmds.c	2011-07-02 23:33:10.000000000 +0400
+++ gdb-7.3/gdb/cli/cli-cmds.c	2014-10-11 21:51:26.000000000 +0400
@@ -917,7 +917,7 @@ list_command (char *arg, int from_tty)
     dummy_beg = 1;
   else
     {
-      sals = decode_line_1 (&arg1, 0, 0, 0, 0);
+      sals = decode_line_1 (&arg1, 1, 0, 0, 0); //AVM2: find the first line for the function rather than expecting to have info for the PC
 
       if (!sals.nelts)
 	return;			/*  C++  */
@@ -1629,6 +1629,7 @@ the other arg."));
   if (dbx_commands)
     add_com_alias ("file", "list", class_files, 1);
 
+#if 0
   c = add_com ("disassemble", class_vars, disassemble_command, _("\
 Disassemble a specified section of memory.\n\
 Default is the function surrounding the pc of the selected frame.\n\
@@ -1640,6 +1641,7 @@ Two arguments (separated by a comma) are
   set_cmd_completer (c, location_completer);
   if (xdb_commands)
     add_com_alias ("va", "disassemble", class_xdb, 0);
+#endif
 
   /* NOTE: cagney/2000-03-20: Being able to enter ``(gdb) !ls'' would
      be a really useful feature.  Unfortunately, the below wont do
diff -rupN gdb-7.3.orig/gdb/configure.host gdb-7.3/gdb/configure.host
--- gdb-7.3.orig/gdb/configure.host	2011-01-13 19:24:12.000000000 +0300
+++ gdb-7.3/gdb/configure.host	2014-10-11 21:51:26.000000000 +0400
@@ -41,6 +41,7 @@ case "${host_cpu}" in
 
 alpha*)			gdb_host_cpu=alpha ;;
 arm*)			gdb_host_cpu=arm ;;
+avm2*)			gdb_host_cpu=avm2 ;;
 hppa*)			gdb_host_cpu=pa ;;
 i[34567]86*)		gdb_host_cpu=i386 ;;
 m68*)			gdb_host_cpu=m68k ;;
@@ -72,6 +73,7 @@ alpha*-*-netbsd* | alpha*-*-knetbsd*-gnu
 			gdb_host=nbsd ;;
 alpha*-*-openbsd*)	gdb_host=nbsd ;;
 
+avm2-*)		gdb_host=avm2 ;;
 arm*-*-linux*)		gdb_host=linux ;;
 arm*-*-netbsdelf* | arm*-*-knetbsd*-gnu)
 			gdb_host=nbsdelf ;;
diff -rupN gdb-7.3.orig/gdb/configure.tgt gdb-7.3/gdb/configure.tgt
--- gdb-7.3.orig/gdb/configure.tgt	2011-03-06 03:22:38.000000000 +0300
+++ gdb-7.3/gdb/configure.tgt	2014-10-11 21:51:26.000000000 +0400
@@ -62,7 +62,10 @@ alpha*-*-*)
 	# Target: Alpha
 	gdb_target_obs="alpha-tdep.o"
 	;;
-
+avm2-* )
+	# Target: AVM2
+	gdb_target_obs="avm2-tdep.o"
+	;;
 am33_2.0*-*-linux*)
 	# Target: Matsushita mn10300 (AM33) running Linux
 	gdb_target_obs="mn10300-tdep.o mn10300-linux-tdep.o linux-tdep.o \
diff -rupN gdb-7.3.orig/gdb/exec.c gdb-7.3/gdb/exec.c
--- gdb-7.3.orig/gdb/exec.c	2011-03-23 21:23:54.000000000 +0300
+++ gdb-7.3/gdb/exec.c	2014-10-11 21:51:26.000000000 +0400
@@ -47,6 +47,9 @@
 
 #include "xcoffsolib.h"
 
+extern char avm2_exec_file[PATH_MAX];
+void push_avm2_target();
+
 struct vmap *map_vmap (bfd *, bfd *);
 
 void (*deprecated_file_changed_hook) (char *);
@@ -200,6 +203,19 @@ exec_file_attach (char *filename, int fr
 {
   /* Remove any previous exec file.  */
   exec_close ();
+  if (!ptid_equal (inferior_ptid, null_ptid))
+    {
+      target_kill ();
+      init_thread_list ();
+
+      struct program_space *ss;
+      ALL_PSPACES (ss)
+      {
+          set_current_program_space (ss);
+          breakpoint_program_space_exit (ss);
+      }
+      symbol_file_clear (0);
+    }
 
   /* Now open and digest the file the user requested, if any.  */
 
@@ -212,6 +228,13 @@ exec_file_attach (char *filename, int fr
     }
   else
     {
+#if 1
+      /* Hack alert! Rather than setting the target by actually examining
+       * the "executable" we've been given, assume it's a SWF and just set
+       * the avm2-remote target. */
+      push_avm2_target ();
+      strcpy (&avm2_exec_file[0], filename);
+#else
       struct cleanup *cleanups;
       char *scratch_pathname;
       int scratch_chan;
@@ -299,11 +322,15 @@ exec_file_attach (char *filename, int fr
       add_target_sections (sections, sections_end);
       xfree (sections);
 
+#endif // AVM2
+
       /* Tell display code (if any) about the changed file name.  */
       if (deprecated_exec_file_display_hook)
 	(*deprecated_exec_file_display_hook) (filename);
 
+#if 0
       do_cleanups (cleanups);
+#endif
     }
   bfd_cache_close_all ();
   observer_notify_executable_changed ();
@@ -364,7 +391,8 @@ file_command (char *arg, int from_tty)
   /* FIXME, if we lose on reading the symbol file, we should revert
      the exec file, but that's rough.  */
   exec_file_command (arg, from_tty);
-  symbol_file_command (arg, from_tty);
+  /* AVM2 change: the file command shouldn't attempt to read symbols
+  symbol_file_command (arg, from_tty); */
   if (deprecated_file_changed_hook)
     deprecated_file_changed_hook (arg);
 }
diff -rupN gdb-7.3.orig/gdb/features/i386/i386.c gdb-7.3/gdb/features/i386/i386.c
--- gdb-7.3.orig/gdb/features/i386/i386.c	2010-03-01 20:26:03.000000000 +0300
+++ gdb-7.3/gdb/features/i386/i386.c	2014-10-11 21:51:26.000000000 +0400
@@ -50,7 +50,7 @@ initialize_tdesc_i386 (void)
   tdesc_create_reg (feature, "es", 13, 1, NULL, 32, "int32");
   tdesc_create_reg (feature, "fs", 14, 1, NULL, 32, "int32");
   tdesc_create_reg (feature, "gs", 15, 1, NULL, 32, "int32");
-  tdesc_create_reg (feature, "st0", 16, 1, NULL, 80, "i387_ext");
+  tdesc_create_reg (feature, "st0", 16, 1, NULL, 64, "ieee_double");
   tdesc_create_reg (feature, "st1", 17, 1, NULL, 80, "i387_ext");
   tdesc_create_reg (feature, "st2", 18, 1, NULL, 80, "i387_ext");
   tdesc_create_reg (feature, "st3", 19, 1, NULL, 80, "i387_ext");
diff -rupN gdb-7.3.orig/gdb/infcall.c gdb-7.3/gdb/infcall.c
--- gdb-7.3.orig/gdb/infcall.c	2011-03-29 20:21:24.000000000 +0400
+++ gdb-7.3/gdb/infcall.c	2014-10-11 21:51:26.000000000 +0400
@@ -635,7 +635,8 @@ call_function_by_hand (struct value *fun
 	CORE_ADDR dummy_addr;
 
 	real_pc = funaddr;
-	dummy_addr = entry_point_address ();
+	//dummy_addr = entry_point_address ();
+	dummy_addr = 0x0;
 	/* A call dummy always consists of just a single breakpoint, so
 	   its address is the same as the address of the dummy.  */
 	bp_addr = dummy_addr;
@@ -772,6 +773,7 @@ call_function_by_hand (struct value *fun
   /* Create a momentary breakpoint at the return address of the
      inferior.  That way it breaks when it returns.  */
 
+#if 0
   {
     struct breakpoint *bpt;
     struct symtab_and_line sal;
@@ -786,6 +788,7 @@ call_function_by_hand (struct value *fun
     bpt = set_momentary_breakpoint (gdbarch, sal, dummy_id, bp_call_dummy);
     bpt->disposition = disp_del;
   }
+#endif
 
   /* Create a breakpoint in std::terminate.
      If a C++ exception is raised in the dummy-frame, and the
@@ -805,7 +808,7 @@ call_function_by_hand (struct value *fun
   /* Everything's ready, push all the info needed to restore the
      caller (and identify the dummy-frame) onto the dummy-frame
      stack.  */
-  dummy_frame_push (caller_state, &dummy_id);
+  //dummy_frame_push (caller_state, &dummy_id);
 
   /* Discard both inf_status and caller_state cleanups.
      From this point on we explicitly restore the associated state
@@ -914,6 +917,7 @@ When the function is done executing, GDB
 	       name);
     }
 
+#if 0
   if (stopped_by_random_signal || stop_stack_dummy != STOP_STACK_DUMMY)
     {
       const char *name = get_function_name (funaddr,
@@ -1016,6 +1020,7 @@ When the function is done executing, GDB
       /* The above code errors out, so ...  */
       internal_error (__FILE__, __LINE__, _("... should not be here"));
     }
+#endif
 
   do_cleanups (terminate_bp_cleanup);
 
diff -rupN gdb-7.3.orig/gdb/infcmd.c gdb-7.3/gdb/infcmd.c
--- gdb-7.3.orig/gdb/infcmd.c	2011-03-22 17:39:40.000000000 +0300
+++ gdb-7.3/gdb/infcmd.c	2014-10-11 21:51:26.000000000 +0400
@@ -56,6 +56,9 @@
 #include "inline-frame.h"
 #include "tracepoint.h"
 
+extern char avm2_exec_file[PATH_MAX];
+void push_avm2_target();
+
 /* Functions exported for general use, in inferior.h: */
 
 void all_registers_info (char *, int);
@@ -519,7 +522,12 @@ run_command_1 (char *args, int from_tty,
   if (tbreak_at_main)
     tbreak_command (main_name (), 0);
 
+#if 0
   exec_file = (char *) get_exec_file (0);
+#else
+  exec_file = avm2_exec_file;
+  push_avm2_target ();
+#endif
 
   if (non_stop && !target_supports_non_stop ())
     error (_("The target does not support running in non-stop mode."));
@@ -597,7 +605,11 @@ run_command_1 (char *args, int from_tty,
 
   /* Start the target running.  Do not use -1 continuation as it would skip
      breakpoint right at the entry point.  */
+  /* Don't actually proceed on avm2, since we want to stop at the begining
+     of the world anyway */
+#if 0
   proceed (regcache_read_pc (get_current_regcache ()), TARGET_SIGNAL_0, 0);
+#endif
 
   /* Since there was no error, there's no need to finish the thread
      states here.  */
@@ -2822,6 +2834,7 @@ needed."),
 		  _("Kill execution of program being debugged."),
 		  &killlist, "kill ", 0, &cmdlist);
 
+#if 0
   add_com ("attach", class_run, attach_command, _("\
 Attach to a process or file outside of GDB.\n\
 This command attaches to another target, of the same type as your last\n\
@@ -2840,6 +2853,7 @@ Detach a process or file previously atta
 If a process, it is no longer traced, and it continues its execution.  If\n\
 you were debugging a file, the file is closed and gdb no longer accesses it."),
 		  &detachlist, "detach ", 0, &cmdlist);
+#endif
 
   add_com ("disconnect", class_run, disconnect_command, _("\
 Disconnect from a target.\n\
@@ -2896,11 +2910,13 @@ command).\n\
 Execution will also stop upon exit from the current stack frame."));
   set_cmd_completer (c, location_completer);
 
+#if 0
   c = add_com ("jump", class_run, jump_command, _("\
 Continue program being debugged at specified line or address.\n\
 Give as argument either LINENUM or *ADDR, where ADDR is an expression\n\
 for an address to start at."));
   set_cmd_completer (c, location_completer);
+#endif
 
   if (xdb_commands)
     {
diff -rupN gdb-7.3.orig/gdb/inferior.h gdb-7.3/gdb/inferior.h
--- gdb-7.3.orig/gdb/inferior.h	2011-06-03 19:32:13.000000000 +0400
+++ gdb-7.3/gdb/inferior.h	2014-10-11 21:51:26.000000000 +0400
@@ -404,6 +404,17 @@ struct inferior_control_state
 {
   /* See the definition of stop_kind above.  */
   enum stop_kind stop_soon;
+
+  /* AVM2-specific field:
+     Running the AVM2 target entails attaching to a remote debugger
+     and gdb typically stops the inferior as part of the attach
+     process. However, the AVM2 target aims to preserve the behavior
+     of the "run" command, which does not stop the inferior until
+     it hits a breakpoint or other signal. This field is used to
+     decide whether the inferior should be automatically resumed
+     in order to mimic the behavior of "run".
+   */
+  int past_first_stop;
 };
 
 /* Inferior process specific part of `struct infcall_suspend_state'.
diff -rupN gdb-7.3.orig/gdb/infrun.c gdb-7.3/gdb/infrun.c
--- gdb-7.3.orig/gdb/infrun.c	2011-06-03 19:32:13.000000000 +0400
+++ gdb-7.3/gdb/infrun.c	2014-10-11 21:51:26.000000000 +0400
@@ -2697,10 +2697,9 @@ fetch_inferior_event (void *client_data)
   /* Now figure out what to do with the result of the result.  */
   handle_inferior_event (ecs);
 
+  struct inferior *inf = find_inferior_pid (ptid_get_pid (ecs->ptid));
   if (!ecs->wait_some_more)
     {
-      struct inferior *inf = find_inferior_pid (ptid_get_pid (ecs->ptid));
-
       delete_step_thread_step_resume_breakpoint ();
 
       /* We may not find an inferior if this was a process exit.  */
@@ -2725,8 +2724,14 @@ fetch_inferior_event (void *client_data)
 
   /* If the inferior was in sync execution mode, and now isn't,
      restore the prompt.  */
-  if (was_sync && !sync_execution)
+  if (was_sync && !sync_execution && 
+        (inf == NULL || inf->control.past_first_stop))
     display_gdb_prompt (0);
+
+  if (inf && !inf->control.past_first_stop) {
+    continue_command(NULL, 0);
+    inf->control.past_first_stop = 1;
+  }
 }
 
 /* Record the frame and location we're currently stepping through.  */
@@ -3197,7 +3202,12 @@ handle_inferior_event (struct execution_
 	 loading that we aren't interested in, resume the program.  If
 	 we're running the program normally, also resume.  But stop if
 	 we're attaching or setting up a remote connection.  */
-      if (stop_soon == STOP_QUIETLY || stop_soon == NO_STOP_QUIETLY)
+      
+      /* AVM2 change:
+         If we are stepping, don't resume the inferior in response to
+         a shared library load event. */
+      if (!ecs->wait_some_more &&  
+          (stop_soon == STOP_QUIETLY || stop_soon == NO_STOP_QUIETLY))
 	{
 	  /* Loading of shared libraries might have changed breakpoint
 	     addresses.  Make sure new breakpoints are inserted.  */
@@ -3207,6 +3217,11 @@ handle_inferior_event (struct execution_
 	  resume (0, TARGET_SIGNAL_0);
 	  prepare_to_wait (ecs);
 	  return;
+	} 
+      else if (ecs->wait_some_more) 
+	{ 
+          keep_going (ecs);
+          return;
 	}
 
       break;
@@ -4047,13 +4062,17 @@ process_event_stop_test:
 
       stopped_by_random_signal = 1;
 
-      if (signal_print[ecs->event_thread->suspend.stop_signal])
+      if (!ecs->event_thread->control.in_infcall 
+          && signal_print[ecs->event_thread->suspend.stop_signal])
 	{
 	  printed = 1;
 	  target_terminal_ours_for_output ();
 	  print_signal_received_reason
 				     (ecs->event_thread->suspend.stop_signal);
 	}
+      
+      if (ecs->event_thread->control.in_infcall)
+        stop_print_frame = 0;
       /* Always stop on signals if we're either just gaining control
 	 of the program, or the user explicitly requested this thread
 	 to remain stopped.  */
@@ -4268,7 +4287,10 @@ process_event_stop_test:
       case BPSTAT_WHAT_STOP_NOISY:
         if (debug_infrun)
 	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_STOP_NOISY\n");
-	stop_print_frame = 1;
+        if (ecs->event_thread->control.in_infcall)
+          stop_print_frame = 0;
+        else
+	  stop_print_frame = 1;
 
 	/* We are about to nuke the step_resume_breakpointt via the
 	   cleanup chain, so no need to worry about it here.  */
@@ -4554,6 +4576,21 @@ process_event_stop_test:
       return;
     }
 
+   /* AVM2-specific code:
+      stop_pc is zero if the debugger is stopped at a line in Actionscript
+      for which we don't have debugging information. This could be AS that
+      wasn't compiled from C/C++ and thus doesn't have debugging information,
+      or it could be script init code that is setting up a CModule. In the
+      latter case, we may need to stop after the init code has run, so
+      single step until we get out of the script init code.
+      See ALC-629.
+    */
+   if (!stop_pc)
+     {
+       keep_going (ecs);
+       return;
+     }
+
   /* Check for subroutine calls.  The check for the current frame
      equalling the step ID is not necessary - the check of the
      previous frame's ID is sufficient - but it is a common case and
@@ -4571,10 +4608,22 @@ process_event_stop_test:
      initial outermost frame, before sp was valid, would
      have code_addr == &_start.  See the comment in frame_id_eq
      for more.  */
+ 
+  /* AVM2-specific code:
+     In Actionscript, it's possible to call up to two functions before
+     hitting a debugline. So here gdb unwinds the stack up to two times
+     when attempting to detect a function call.
+   */
+  struct frame_id up = frame_unwind_caller_id (get_current_frame ());
+  struct frame_info *upin = frame_find_by_id (up);
+  struct frame_id ssfi = ecs->event_thread->control.step_stack_frame_id;
+  int one_frame_down = frame_id_eq(up, ssfi);
+  int two_frames_down = frame_id_eq(frame_unwind_caller_id(upin), ssfi);
+  struct frame_info *caller = one_frame_down ? frame : upin;
+
   if (!frame_id_eq (get_stack_frame_id (frame),
 		    ecs->event_thread->control.step_stack_frame_id)
-      && (frame_id_eq (frame_unwind_caller_id (get_current_frame ()),
-		       ecs->event_thread->control.step_stack_frame_id)
+      && ((one_frame_down || two_frames_down)
 	  && (!frame_id_eq (ecs->event_thread->control.step_stack_frame_id,
 			    outer_frame_id)
 	      || step_start_function != find_pc_function (stop_pc))))
@@ -4644,7 +4693,7 @@ process_event_stop_test:
 						    sr_sal, null_frame_id);
 	    }
 	  else
-	    insert_step_resume_breakpoint_at_caller (frame);
+	    insert_step_resume_breakpoint_at_caller (caller);
 
 	  keep_going (ecs);
 	  return;
@@ -4684,7 +4733,14 @@ process_event_stop_test:
       {
 	struct symtab_and_line tmp_sal;
 
-	tmp_sal = find_pc_line (ecs->stop_func_start, 0);
+        /* AVM2 change: If we have line number information, adjust the pc
+           to the first executable line in the function. Native does this
+           adjustment later, since it tends to have line number info
+           for fuctions' start pc values. We don't, so we'll miss the entire
+           function call if we don't adjust now. */
+	CORE_ADDR adjusted_pc = gdbarch_skip_prologue (gdbarch, 
+                                                       ecs->stop_func_start);
+	tmp_sal = find_pc_line (adjusted_pc, 0);
 	if (tmp_sal.line != 0)
 	  {
 	    if (execution_direction == EXEC_REVERSE)
@@ -4944,7 +5000,13 @@ process_event_stop_test:
       return;
     }
 
-  if ((stop_pc == stop_pc_sal.pc)
+
+  /* AVM2-specific change:
+     Contrary to the comment below, stop even if we end up in the
+     middle of a different line. Because of the way that debuglines are
+     generated, gdb often ends up in the middle of lines.
+   */
+  if ((stop_pc >= stop_pc_sal.pc)
       && (ecs->event_thread->current_line != stop_pc_sal.line
  	  || ecs->event_thread->current_symtab != stop_pc_sal.symtab))
     {
@@ -5636,8 +5698,13 @@ normal_stop (void)
   /* If an auto-display called a function and that got a signal,
      delete that auto-display to avoid an infinite recursion.  */
 
+  /* AVM2-specific change: don't disable auto-display expressions
+     because there is no risk of infinite recursion, and because of
+     the way that AVM2 calls functions, it always appears to be
+     stopped due to a signal.
   if (stopped_by_random_signal)
     disable_current_display ();
+    */
 
   /* Don't print a message if in the middle of doing a "step n"
      operation for n > 1 */
@@ -5995,6 +6062,10 @@ handle_command (char *args, int from_tty
 	{
 	  UNSET_SIGS (nsigs, sigs, signal_program);
 	}
+      else if (wordlen >= 4 && !strncmp(*argv, "stopnoprint", wordlen))
+	{
+	  UNSET_SIGS (nsigs, sigs, signal_print);
+	}
       else if (digits > 0)
 	{
 	  /* It is numeric.  The numeric signal refers to our own
diff -rupN gdb-7.3.orig/gdb/main.c gdb-7.3/gdb/main.c
--- gdb-7.3.orig/gdb/main.c	2011-03-07 21:34:31.000000000 +0300
+++ gdb-7.3/gdb/main.c	2014-10-11 21:51:26.000000000 +0400
@@ -44,6 +44,9 @@
 #include "python/python.h"
 #include "objfiles.h"
 
+char *SetFlasccSDKLocation(const char *);
+static char *flascc_sdk = NULL;
+
 /* The selected interpreter.  This will be used as a set command
    variable, so it should always be malloc'ed - since
    do_setshow_command will free it.  */
@@ -816,6 +819,15 @@ captured_main (void *data)
   if (home_gdbinit && !inhibit_gdbinit)
     catch_command_errors (source_script, home_gdbinit, 0, RETURN_MASK_ALL);
 
+  if (!flascc_sdk) 
+    {
+      flascc_sdk = SetFlasccSDKLocation("/../../usr");
+    }
+  
+  char *flascc_init;
+  asprintf (&flascc_init, "%s/share/flascc-init.gdb", flascc_sdk);
+  catch_command_errors (source_script, flascc_init, 0, RETURN_MASK_ALL);
+
   /* Now perform all the actions indicated by the arguments.  */
   if (cdarg != NULL)
     {
@@ -841,8 +853,10 @@ captured_main (void *data)
          catch_command_errors returns non-zero on success!  */
       if (catch_command_errors (exec_file_attach, execarg,
 				!batch_flag, RETURN_MASK_ALL))
+        ;
+        /* AVM2 change: the file command doesn't attempt to load symbols.
 	catch_command_errors (symbol_file_add_main, symarg,
-			      !batch_flag, RETURN_MASK_ALL);
+			      !batch_flag, RETURN_MASK_ALL); */
     }
   else
     {
diff -rupN gdb-7.3.orig/gdb/remote.c gdb-7.3/gdb/remote.c
--- gdb-7.3.orig/gdb/remote.c	2011-07-15 06:04:29.000000000 +0400
+++ gdb-7.3/gdb/remote.c	2014-10-11 21:51:26.000000000 +0400
@@ -68,6 +68,15 @@
 #include "ax.h"
 #include "ax-gdb.h"
 
+#include "SetAlchemySDKLocation.c"
+#include <dirent.h>
+
+char avm2_exec_file[PATH_MAX];
+static char *flascc_sdk = NULL;
+
+static pid_t avm2_player_pid = 0;
+static pid_t avm2_bridge_pid = 0;
+
 /* Temp hacks for tracepoint encoding migration.  */
 static char *target_buf;
 static long target_buf_size;
@@ -117,6 +126,8 @@ static void extended_remote_restart (voi
 
 static void extended_remote_mourn (struct target_ops *);
 
+static void avm2_remote_mourn (struct target_ops *);
+
 static void remote_mourn_1 (struct target_ops *);
 
 static void remote_send (char **buf, long *sizeof_buf_p);
@@ -680,6 +691,8 @@ static struct target_ops remote_ops;
 
 static struct target_ops extended_remote_ops;
 
+static struct target_ops avm2_remote_ops;
+
 static int remote_async_mask_value = 1;
 
 /* FIXME: cagney/1999-09-23: Even though getpkt was called with
@@ -788,6 +801,14 @@ static int remote_async_terminal_ours_p;
 
 static char *remote_exec_file = "";
 
+/* The AS3 namespace that contains the AlcDbgHelper to attach to. */
+
+static char *remote_as3_helper_namespace = NULL;
+
+/* The level of performance logging in the debug bridge. 0 means none. */
+
+static long remote_avm2_bridge_perf_log_level = 0;
+
 
 /* User configurable variables for the number of characters in a
    memory read/write packet.  MIN (rsa->remote_packet_size,
@@ -1434,6 +1455,7 @@ remote_add_inferior (int pid, int attach
     }
 
   inf->attach_flag = attached;
+  inf->control.past_first_stop = 0;
 
   return inf;
 }
@@ -3414,6 +3436,15 @@ extended_remote_open (char *name, int fr
   remote_open_1 (name, from_tty, &extended_remote_ops, 1 /*extended_p */);
 }
 
+/* Open a connection to a remote debugger using the avm2
+   remote gdb protocol.  NAME is the filename used for communication.  */
+
+static void
+avm2_remote_open (char *name, int from_tty)
+{
+  remote_open_1 (name, from_tty, &avm2_remote_ops, 0);
+}
+
 /* Generic code for opening a connection to a remote target.  */
 
 static void
@@ -4147,6 +4178,12 @@ extended_remote_detach (struct target_op
   remote_detach_1 (args, from_tty, 1);
 }
 
+static void
+avm2_remote_detach (struct target_ops *ops, char *args, int from_tty)
+{
+  remote_detach_1 (args, from_tty, 0);
+}
+
 /* Same as remote_detach, but don't send the "D" packet; just disconnect.  */
 
 static void
@@ -4278,6 +4315,120 @@ extended_remote_attach (struct target_op
   extended_remote_attach_1 (ops, args, from_tty);
 }
 
+/* Attach to the process specified by ARGS.  If FROM_TTY is non-zero,
+   be chatty about it.  */
+
+static void
+avm2_remote_attach_1 (struct target_ops *target, char *args, int from_tty)
+{
+  struct remote_state *rs = get_remote_state ();
+  int pid;
+  char *wait_status = NULL;
+
+  pid = parse_pid_to_attach (args);
+
+  /* Remote PID can be freely equal to getpid, do not check it here the same
+     way as in other targets.  */
+
+  if (remote_protocol_packets[PACKET_vAttach].support == PACKET_DISABLE)
+    error (_("This target does not support attaching to a process"));
+
+  sprintf (rs->buf, "vAttach;%x", pid);
+  putpkt (rs->buf);
+  getpkt (&rs->buf, &rs->buf_size, 0);
+
+  if (packet_ok (rs->buf,
+		 &remote_protocol_packets[PACKET_vAttach]) == PACKET_OK)
+    {
+      if (from_tty)
+	printf_unfiltered (_("Attached to %s\n"),
+			   target_pid_to_str (pid_to_ptid (pid)));
+
+      if (!non_stop)
+	{
+	  /* Save the reply for later.  */
+	  wait_status = alloca (strlen (rs->buf) + 1);
+	  strcpy (wait_status, rs->buf);
+	}
+      else if (strcmp (rs->buf, "OK") != 0)
+	error (_("Attaching to %s failed with: %s"),
+	       target_pid_to_str (pid_to_ptid (pid)),
+	       rs->buf);
+    }
+  else if (remote_protocol_packets[PACKET_vAttach].support == PACKET_DISABLE)
+    error (_("This target does not support attaching to a process"));
+  else
+    error (_("Attaching to %s failed"),
+	   target_pid_to_str (pid_to_ptid (pid)));
+
+  set_current_inferior (remote_add_inferior (pid, 1));
+
+  inferior_ptid = pid_to_ptid (pid);
+
+  if (non_stop)
+    {
+      struct thread_info *thread;
+
+      /* Get list of threads.  */
+      remote_threads_info (target);
+
+      thread = first_thread_of_process (pid);
+      if (thread)
+	inferior_ptid = thread->ptid;
+      else
+	inferior_ptid = pid_to_ptid (pid);
+
+      /* Invalidate our notion of the remote current thread.  */
+      record_currthread (minus_one_ptid);
+    }
+  else
+    {
+      /* Now, if we have thread information, update inferior_ptid.  */
+      inferior_ptid = remote_current_thread (inferior_ptid);
+
+      /* Add the main thread to the thread list.  */
+      add_thread_silent (inferior_ptid);
+    }
+
+  /* Next, if the target can specify a description, read it.  We do
+     this before anything involving memory or registers.  */
+  target_find_description ();
+
+  if (!non_stop)
+    {
+      /* Use the previously fetched status.  */
+      gdb_assert (wait_status != NULL);
+
+      if (target_can_async_p ())
+	{
+	  struct stop_reply *stop_reply;
+	  struct cleanup *old_chain;
+
+	  stop_reply = stop_reply_xmalloc ();
+	  old_chain = make_cleanup (do_stop_reply_xfree, stop_reply);
+	  remote_parse_stop_reply (wait_status, stop_reply);
+	  discard_cleanups (old_chain);
+	  push_stop_reply (stop_reply);
+
+	  target_async (inferior_event_handler, 0);
+	}
+      else
+	{
+	  gdb_assert (wait_status != NULL);
+	  strcpy (rs->buf, wait_status);
+	  rs->cached_wait_status = 1;
+	}
+    }
+  else
+    gdb_assert (wait_status == NULL);
+}
+
+static void
+avm2_remote_attach (struct target_ops *ops, char *args, int from_tty)
+{
+  avm2_remote_attach_1 (ops, args, from_tty);
+}
+
 /* Convert hex digit A to a number.  */
 
 static int
@@ -5084,8 +5235,9 @@ remote_parse_stop_reply (char *buf, stru
 		error (_("Malformed packet(a) (missing colon): %s\n\
 Packet: '%s'\n"),
 		       p, buf);
-	      if (strncmp (p, "thread", p1 - p) == 0)
+	      if (strncmp (p, "thread", p1 - p) == 0) {
 		event->ptid = read_ptid (++p1, &p);
+              }
 	      else if ((strncmp (p, "watch", p1 - p) == 0)
 		       || (strncmp (p, "rwatch", p1 - p) == 0)
 		       || (strncmp (p, "awatch", p1 - p) == 0))
@@ -5686,6 +5838,8 @@ send_g_packet (void)
   if (buf_len % 2 != 0)
     error (_("Remote 'g' packet reply is of odd length: %s"), rs->buf);
 
+  if (remote_debug)
+      fprintf_unfiltered(gdb_stdlog, "packet g okay\n");
   return buf_len / 2;
 }
 
@@ -7365,6 +7519,27 @@ extended_remote_kill (struct target_ops 
 }
 
 static void
+avm2_remote_kill (struct target_ops *ops)
+{
+  int statloc;
+  if (avm2_bridge_pid)
+  {
+    kill (avm2_bridge_pid, SIGTERM);
+    avm2_bridge_pid = 0;
+    waitpid (avm2_bridge_pid, &statloc, 0);
+  }
+  
+  if (avm2_player_pid)
+  {
+    kill (avm2_player_pid, SIGTERM);
+    avm2_player_pid = 0;
+    waitpid (avm2_player_pid, &statloc, 0);
+  }
+  
+  target_mourn_inferior ();
+}
+
+static void
 remote_mourn (struct target_ops *ops)
 {
   remote_mourn_1 (ops);
@@ -7450,6 +7625,21 @@ extended_remote_mourn (struct target_ops
   extended_remote_mourn_1 (ops);
 }
 
+static void
+avm2_remote_mourn_1 (struct target_ops *target)
+{
+  unpush_target (target);
+  
+  /* remote_close takes care of doing most of the clean up.  */
+  generic_mourn_inferior ();
+}
+
+static void
+avm2_remote_mourn (struct target_ops *ops)
+{
+  avm2_remote_mourn_1 (ops);
+}
+
 static int
 extended_remote_run (char *args)
 {
@@ -7571,6 +7761,195 @@ extended_remote_create_inferior (struct 
 }
 
 
+/* Convert cygwin style paths to native paths. Return zero
+   on success, non-zero on error. */
+#ifdef __CYGWIN__
+int
+cygwin_get_native_path (char *dest, char *cyg_path)
+{
+  char *escaped_path = malloc(strlen(cyg_path) * 2);
+  char *escape_ptr = escaped_path;
+
+  // escape any windows path separators that might be in the input
+  while (*cyg_path) {
+    if (*cyg_path == '\\') {
+      *escape_ptr = '\\';
+      escape_ptr++;
+     }
+    *escape_ptr = *cyg_path;
+    escape_ptr++;
+    cyg_path++;
+  }
+  *escape_ptr = '\0';
+
+  char *cygpath_cmd;
+  asprintf (&cygpath_cmd, "cygpath -w %s", escaped_path);
+  free(escaped_path);
+  FILE *cygpath_file = popen (cygpath_cmd, "r");
+  free (cygpath_cmd);
+  if (!cygpath_file)
+    return 1;
+  
+  memset (dest, 0, MAX_PATH);
+  fread (dest, 1, MAX_PATH, cygpath_file);
+  /* Get rid of trailing newline */
+  dest[strlen (dest) - 1] = '\0';
+  pclose (cygpath_file);
+
+  return 0;
+}
+#endif
+
+
+/* Whether we've already sourced the file containing avm2-specific
+ * command definitions. Only do this once. */
+static int avm2_sourced = 0;
+
+
+/* In the extended protocol we want to be able to do things like
+   "run" and have them basically work as expected.  So we need
+   a special create_inferior function.  We support changing the
+   executable file and the command line arguments, but not the
+   environment.  */
+
+static void
+avm2_remote_create_inferior_1 (char *exec_file, char *args,
+				   char **env, int from_tty)
+{
+  if (!flascc_sdk) 
+  {
+    flascc_sdk = SetFlasccSDKLocation("/../../usr");
+  }
+  
+
+  char *player = getenv("FLASCC_GDB_RUNTIME");
+  if (!player)
+  {
+    error("Please set the FLASCC_GDB_RUNTIME environment"
+      " variable to the path to a debugger player or browser.\n");
+    return;
+  }
+  
+  if ((avm2_bridge_pid = fork()))
+  {
+      if ((avm2_player_pid = fork())) 
+      {
+          char *defs, *run;
+          asprintf (&defs, "%s/share/flascc.gdb", flascc_sdk);
+          asprintf (&run, "%s/share/flascc-run.gdb", flascc_sdk);
+          // TODO: wait for bridge to listen
+          sleep(1);
+          if (!avm2_sourced)
+          {
+            source_script(defs, 1);
+            avm2_sourced = 1;
+          }
+          source_script(run, 1);
+          if (!target_can_async_p())
+          {
+              continue_command(NULL, 0);
+          }
+
+          free (defs);
+          free (run);
+
+      } else {
+        char *cmd;
+        char *args[3];
+        args[0] = player;
+        args[1] = NULL;
+	args[2] = NULL;
+	signal (SIGINT, SIG_IGN);
+#ifdef __CYGWIN__
+	char pathbuf[MAX_PATH];
+	if (cygwin_get_native_path (&pathbuf[0], exec_file))
+	  error ("Unable to determine path to program to be run.\n");
+	args[1] = &pathbuf[0];
+	execv (player, args);
+#else
+        char *player_exec_dir;
+        asprintf (&player_exec_dir, "%s/Contents/MacOS/", player);
+        DIR *player_dir = opendir (player_exec_dir);
+        if (!player_dir) {
+            error ("Unable to find player or browser executable.\n");
+            return;
+        }
+        char *player_exec = NULL;
+        while (!player_exec) {
+            struct dirent *ent = readdir (player_dir);
+            if (!ent) 
+            {
+                error ("Unable to find player or browser executable.\n");
+                return;
+            } else if (ent->d_name[0] != '.') 
+            {
+                asprintf (&player_exec, "%s/Contents/MacOS/%s", player,
+                    ent->d_name);
+            }
+        }
+        closedir (player_dir);
+        
+        if (fork())
+        {
+            // The player currently prints annoying debug messages when
+            // workers are created or destroyed. Redirect stdout and stderr
+            // so that the user doesn't see these messages.
+            freopen ("/dev/null", "w", stdout);
+            freopen ("/dev/null", "w", stderr);
+            execv (player_exec, args);
+        } else {
+            // Wait to give the player a chance to load. If we don't do this
+            // there's a chance this will happen first, causing two players
+            // to load, and we won't be able to kill the one launched here
+            sleep (1);
+            asprintf (&cmd, "open -g -a \"%s\" %s", player, exec_file);
+            system (cmd);
+            free (cmd);
+        }
+        free (player_exec);
+#endif
+        exit (0);
+      }
+  } else {
+      char *alcdb;
+#ifdef __CYGWIN__
+      char pathbuf[MAX_PATH];
+      asprintf (&alcdb, "%s/lib/alcdb.jar", flascc_sdk);
+      if (cygwin_get_native_path (&pathbuf[0], alcdb))
+      {
+        error ("Unable to determine path to debug bridge.\n");
+      }
+      free (alcdb);
+      alcdb = pathbuf;
+#else
+      asprintf (&alcdb, "%s/lib/alcdb.jar", flascc_sdk);
+#endif
+      char *args[9];
+      char log_level_buf[512];
+      snprintf(&log_level_buf[0], sizeof(log_level_buf), "%u", 
+                    remote_avm2_bridge_perf_log_level);
+      args[0] = "java";
+      args[1] = "-jar";
+      args[2] = alcdb;
+      args[3] = (getenv("ALC_GDB_VERBOSE")) ? "-v" : "-q";
+      args[4] = "-n";
+      args[5] = remote_as3_helper_namespace;
+      args[6] = "-p";
+      args[7] = &log_level_buf[0];
+      args[8] = NULL;
+      signal(SIGINT, SIG_IGN); 
+      execvp ("java", args);
+  }
+}
+
+static void
+avm2_remote_create_inferior (struct target_ops *ops, 
+				 char *exec_file, char *args,
+				 char **env, int from_tty)
+{
+  avm2_remote_create_inferior_1 (exec_file, args, env, from_tty);
+}
+
 /* Insert a breakpoint.  On targets that have software breakpoint
    support, we ask the remote target to do the work; on targets
    which don't, we insert a traditional memory breakpoint.  */
@@ -7626,6 +8005,12 @@ static int
 remote_remove_breakpoint (struct gdbarch *gdbarch,
 			  struct bp_target_info *bp_tgt)
 {
+  /* This can be called after the remote inferior has shut down, do
+   * nothing in that case. (See ALC-238). */
+  if (!remote_desc) {
+     return 0; 
+  }
+  
   CORE_ADDR addr = bp_tgt->placed_address;
   struct remote_state *rs = get_remote_state ();
 
@@ -7766,6 +8151,16 @@ remote_check_watch_resources (int type, 
 }
 
 static int
+avm2_remote_check_watch_resources (int type, int cnt, int ot)
+{
+  /* AVM2 does not allow hardware watchpoints. */
+  if (type == bp_hardware_watchpoint)
+    return 0;
+  else
+    return remote_check_watch_resources (type, cnt, ot);
+}
+
+static int
 remote_stopped_by_watchpoint (void)
 {
   return remote_stopped_by_watchpoint_p;
@@ -8502,6 +8897,41 @@ packet_command (char *args, int from_tty
   puts_filtered ("\n");
 }
 
+static void
+perf_logging_command (char *args, int from_tty)
+{
+  struct remote_state *rs = get_remote_state ();
+
+  if (args == NULL)
+    error ("Argument required (integer).");
+  else
+    {
+      char *end;
+      remote_avm2_bridge_perf_log_level = strtoul (args, &end, 0);
+      if (args == end)
+	error ("Invalid remote-perf-logging (bad syntax).");
+    }
+
+  if (remote_desc)
+    {
+      char buf[512];
+      snprintf (&buf, sizeof(buf), "monitor set-perf-log %u", 
+                        remote_avm2_bridge_perf_log_level);
+      target_rcmd (&buf, NULL);
+    }
+}
+
+static void
+perf_log_command (char *args, int from_tty)
+{
+  if (remote_desc)
+    {
+      target_rcmd ("monitor show-perf-log", gdb_stdtarg);
+    }
+  else
+    error (_("command can only be used with remote target"));
+}
+
 #if 0
 /* --------- UNIT_TEST for THREAD oriented PACKETS ------------------- */
 
@@ -8654,6 +9084,50 @@ init_remote_threadtests (void)
    buffer.  */
 
 static char *
+avm2_remote_pid_to_str (struct target_ops *ops, ptid_t ptid)
+{
+  static char buf[64];
+  struct remote_state *rs = get_remote_state ();
+
+  if (ptid_is_pid (ptid))
+    {
+      /* Printing an inferior target id.  */
+
+      /* When multi-process extensions are off, there's no way in the
+	 remote protocol to know the remote process id, if there's any
+	 at all.  There's one exception --- when we're connected with
+	 target extended-remote, and we manually attached to a process
+	 with "attach PID".  We don't record anywhere a flag that
+	 allows us to distinguish that case from the case of
+	 connecting with extended-remote and the stub already being
+	 attached to a process, and reporting yes to qAttached, hence
+	 no smart special casing here.  */
+      if (!remote_multi_process_p (rs))
+	{
+	  xsnprintf (buf, sizeof buf, "Remote target");
+	  return buf;
+	}
+
+      return normal_pid_to_str (ptid);
+    }
+  else
+    {
+      if (ptid_equal (magic_null_ptid, ptid))
+	xsnprintf (buf, sizeof buf, "Thread <main>");
+      else if (remote_multi_process_p (rs))
+	xsnprintf (buf, sizeof buf, "Thread %d.%ld",
+		   ptid_get_pid (ptid), ptid_get_tid (ptid));
+      else
+	xsnprintf (buf, sizeof buf, "Worker %ld",
+		   ptid_get_tid (ptid));
+      return buf;
+    }
+}
+
+/* Convert a thread ID to a string.  Returns the string in a static
+   buffer.  */
+
+static char *
 remote_pid_to_str (struct target_ops *ops, ptid_t ptid)
 {
   static char buf[64];
@@ -9079,6 +9553,24 @@ remote_hostio_send_command (int command_
   return ret;
 }
 
+/* AVM2 optimization:
+ * Since reading symbol files can take a long time, and most of this time is
+ * spent calling into the player to retrieve a small amount of data, we
+ * read and cache each symbol file once it is opened.
+ */
+struct cached_target_file {
+  gdb_byte *file_buffer;
+  int buffer_len;
+};
+
+static struct cached_target_file **target_files = NULL;
+static unsigned int num_target_files = 0;
+static const unsigned int READ_SIZE = 10 * 1024;
+
+static int
+remote_hostio_pread (int fd, gdb_byte *read_buf, int len,
+		     ULONGEST offset, int *remote_errno);
+
 /* Open FILENAME on the remote target, using FLAGS and MODE.  Return a
    remote file descriptor, or -1 if an error occurs (and set
    *REMOTE_ERRNO).  */
@@ -9102,8 +9594,32 @@ remote_hostio_open (const char *filename
 
   remote_buffer_add_int (&p, &left, mode);
 
-  return remote_hostio_send_command (p - rs->buf, PACKET_vFile_open,
+  int fd =  remote_hostio_send_command (p - rs->buf, PACKET_vFile_open,
 				     remote_errno, NULL, NULL);
+  if (fd != -1) {
+    if (fd >= num_target_files) {
+      num_target_files += 1024;
+      target_files = xrealloc (target_files, num_target_files * 
+                                sizeof (struct cached_target_file *));
+      gdb_assert (fd < num_target_files);
+    }
+    struct cached_target_file *cfile = xmalloc(
+                                        sizeof (struct cached_target_file));
+    cfile->file_buffer = NULL;
+    cfile->buffer_len = 0;
+    target_files[fd] = NULL;
+    int nread = 0;
+    do {
+        cfile->buffer_len += READ_SIZE;
+        cfile->file_buffer = xrealloc (cfile->file_buffer, 
+                                        cfile->buffer_len);
+        nread += remote_hostio_pread(fd, cfile->file_buffer + nread, 
+                                    READ_SIZE, nread, remote_errno);
+    } while (nread == cfile->buffer_len);
+    cfile->buffer_len = nread;
+    target_files[fd] = cfile;
+  }
+  return fd;
 }
 
 /* Write up to LEN bytes from WRITE_BUF to FD on the remote target.
@@ -9118,7 +9634,7 @@ remote_hostio_pwrite (int fd, const gdb_
   char *p = rs->buf;
   int left = get_remote_packet_size ();
   int out_len;
-
+ 
   remote_buffer_add_string (&p, &left, "vFile:pwrite:");
 
   remote_buffer_add_int (&p, &left, fd);
@@ -9149,6 +9665,15 @@ remote_hostio_pread (int fd, gdb_byte *r
   int ret, attachment_len;
   int read_len;
 
+  /* If possible, read the value out of the buffer and don't talk to
+   * the target at all. */
+  if (fd >= 0 && fd < num_target_files && target_files[fd] != NULL) {
+    if ((offset + len) <= target_files[fd]->buffer_len) {
+      memmove(read_buf, target_files[fd]->file_buffer + offset, len);
+      return len;
+    }
+  }
+
   remote_buffer_add_string (&p, &left, "vFile:pread:");
 
   remote_buffer_add_int (&p, &left, fd);
@@ -9184,6 +9709,12 @@ remote_hostio_close (int fd, int *remote
   char *p = rs->buf;
   int left = get_remote_packet_size () - 1;
 
+  if (fd >= 0) {
+    xfree (target_files[fd]->file_buffer);
+    xfree (target_files[fd]);
+    target_files[fd] = NULL;
+  }
+
   remote_buffer_add_string (&p, &left, "vFile:close:");
 
   remote_buffer_add_int (&p, &left, fd);
@@ -9974,6 +10505,12 @@ remote_trace_start (void)
 }
 
 static int
+avm2_remote_get_trace_status (struct trace_status *ts)
+{
+    return -1;
+}
+
+static int
 remote_get_trace_status (struct trace_status *ts)
 {
   /* Initialize it just to avoid a GCC false warning.  */
@@ -10262,6 +10799,12 @@ remote_traceframe_info (void)
   return NULL;
 }
 
+static int
+avm2_remote_can_async_p (void)
+{
+  return target_async_permitted;
+}
+
 static void
 init_remote_ops (void)
 {
@@ -10378,6 +10921,32 @@ Specify the serial device it is connecte
   extended_remote_ops.to_kill = extended_remote_kill;
 }
 
+/* Set up the avm2 remote vector by making a copy of the standard
+   remote vector and adding to it.  */
+
+static void
+init_avm2_remote_ops (void)
+{
+  avm2_remote_ops = remote_ops;
+
+  avm2_remote_ops.to_shortname = "avm2-remote";
+  avm2_remote_ops.to_longname =
+    "AVM2 remote target in gdb-specific protocol";
+  avm2_remote_ops.to_doc =
+    "Use a Flash Player Debugger on the local machine, "
+    "using a gdb-specific protocol.";
+  avm2_remote_ops.to_open = avm2_remote_open;
+  avm2_remote_ops.to_create_inferior = avm2_remote_create_inferior;
+  avm2_remote_ops.to_mourn_inferior = avm2_remote_mourn;
+  avm2_remote_ops.to_detach = avm2_remote_detach;
+  avm2_remote_ops.to_attach = avm2_remote_attach;
+  avm2_remote_ops.to_kill = avm2_remote_kill;
+  avm2_remote_ops.to_get_trace_status = avm2_remote_get_trace_status;
+  avm2_remote_ops.to_can_use_hw_breakpoint = avm2_remote_check_watch_resources;
+  avm2_remote_ops.to_can_async_p = avm2_remote_can_async_p;
+  avm2_remote_ops.to_pid_to_str = avm2_remote_pid_to_str;
+}
+
 static int
 remote_can_async_p (void)
 {
@@ -10554,6 +11123,32 @@ remote_upload_trace_state_variables (str
 }
 
 void
+push_avm2_target (void)
+{
+  push_target (&avm2_remote_ops);
+}
+
+void
+avm2_select_thread_for_continue_command (char *args, int from_tty)
+{
+  if (!non_stop)
+    return;
+  if (is_executing (inferior_ptid))
+    error ("Cannot execute this command while the selected thread is running.");
+  set_general_thread (inferior_ptid);
+}
+
+void
+avm2_select_thread_for_bt_command (char *args, int from_tty)
+{
+  if (!non_stop)
+    return;
+  if (is_executing (inferior_ptid))
+    error ("Target is executing.");
+  set_general_thread (inferior_ptid);
+}
+
+void
 _initialize_remote (void)
 {
   struct remote_state *rs;
@@ -10580,6 +11175,9 @@ _initialize_remote (void)
   init_extended_remote_ops ();
   add_target (&extended_remote_ops);
 
+  init_avm2_remote_ops ();
+  add_target (&avm2_remote_ops);
+
   /* Hook into new objfile notification.  */
   observer_attach_new_objfile (remote_new_objfile);
 
@@ -10713,6 +11311,35 @@ Show the maximum size of the address (in
 			   NULL, /* FIXME: i18n: */
 			   &setlist, &showlist);
 
+  char *default_ns = "com.adobe.flascc";
+  remote_as3_helper_namespace = malloc(strlen(default_ns) + 1);
+  strcpy(remote_as3_helper_namespace, default_ns);
+  add_setshow_string_cmd ("as3namespace", no_class,
+			   &remote_as3_helper_namespace, "\
+Set the AS3 namespace of the inferior.", "\
+Show the AS3 namespace of the inferior.", NULL,
+			   NULL,
+			   NULL, 
+			   &setlist, &showlist);
+
+  add_cmd ("avm2-select-thread-for-continue", class_obscure, 
+            avm2_select_thread_for_continue_command, "\
+Force the remote target to select the current thread to be resumed.",
+	   &cmdlist);
+
+  add_cmd ("avm2-select-thread-for-bt", class_obscure, 
+            avm2_select_thread_for_bt_command, "\
+Force the remote target to select the current thread to report a stacktrace.",
+	   &cmdlist);
+
+  add_cmd ("remote-perf-logging", class_maintenance, perf_logging_command, "\
+Instruct the remote target to turn on performance logging.\n",
+	   &maintenancelist);
+
+  add_cmd ("remote-perf-log", class_maintenance, perf_log_command, "\
+Display a performance summary of the remote target.\n",
+	   &maintenancelist);
+
   add_packet_config_cmd (&remote_protocol_packets[PACKET_X],
 			 "X", "binary-download", 1);
 
diff -rupN gdb-7.3.orig/gdb/stack.c gdb-7.3/gdb/stack.c
--- gdb-7.3.orig/gdb/stack.c	2011-03-18 21:48:56.000000000 +0300
+++ gdb-7.3/gdb/stack.c	2014-10-11 21:51:26.000000000 +0400
@@ -611,8 +611,15 @@ print_frame_info (struct frame_info *fra
   if (source_print && sal.symtab)
     {
       int done = 0;
+      /*
       int mid_statement = ((print_what == SRC_LINE)
 			   && frame_show_address (frame, sal));
+      */
+      /* AVM2 change: since the debugger always thinks it is in the middle of
+         a statement due to the way that debuglines are emitted, turn this
+         off to avoid printing the value of the pc each time the program stops.
+       */
+      int mid_statement = 0;
 
       if (annotation_level)
 	done = identify_source_line (sal.symtab, sal.line, mid_statement,
diff -rupN gdb-7.3.orig/opcodes/configure gdb-7.3/opcodes/configure
--- gdb-7.3.orig/opcodes/configure	2011-02-14 00:00:14.000000000 +0300
+++ gdb-7.3/opcodes/configure	2014-10-11 21:51:26.000000000 +0400
@@ -12408,6 +12408,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_alpha_arch)		ta="$ta alpha-dis.lo alpha-opc.lo" ;;
 	bfd_arc_arch)		ta="$ta arc-dis.lo arc-opc.lo arc-ext.lo" ;;
 	bfd_arm_arch)		ta="$ta arm-dis.lo" ;;
+	bfd_avm2_arch)		ta="$ta" ;;
 	bfd_avr_arch)		ta="$ta avr-dis.lo" ;;
 	bfd_bfin_arch)		ta="$ta bfin-dis.lo" ;;
 	bfd_cr16_arch)    	ta="$ta cr16-dis.lo cr16-opc.lo" ;;
